---
phase: 02-core-movement
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - client/src/scenes/GameScene.ts
  - client/src/systems/Prediction.ts
  - client/src/systems/Interpolation.ts
autonomous: false

must_haves:
  truths:
    - "Local player moves immediately on input (no waiting for server round-trip)"
    - "Local player position reconciles with server state without visible rubberbanding at <50ms latency"
    - "Remote players move smoothly between server updates (no teleporting)"
    - "Character faces movement direction automatically"
    - "Game remains playable at 150ms simulated latency"
  artifacts:
    - path: "client/src/systems/Prediction.ts"
      provides: "Client-side prediction with input replay reconciliation"
      contains: "reconcile"
    - path: "client/src/systems/Interpolation.ts"
      provides: "Entity interpolation for remote players"
      contains: "interpolate"
    - path: "client/src/scenes/GameScene.ts"
      provides: "Integrated prediction + interpolation in game loop"
      contains: "PredictionSystem"
  key_links:
    - from: "client/src/systems/Prediction.ts"
      to: "shared/physics.ts"
      via: "import applyMovementPhysics for local simulation"
      pattern: "applyMovementPhysics"
    - from: "client/src/scenes/GameScene.ts"
      to: "client/src/systems/Prediction.ts"
      via: "prediction.sendInput() in update loop"
      pattern: "sendInput"
    - from: "client/src/scenes/GameScene.ts"
      to: "client/src/systems/Interpolation.ts"
      via: "interpolation.update() for remote players each frame"
      pattern: "interpolation"
---

<objective>
Implement client-side prediction for responsive local movement and entity interpolation for smooth remote player rendering.

Purpose: Transform the pure server-authority model (which feels laggy) into a responsive experience. Local player sees immediate movement via prediction, with server reconciliation to maintain authority. Remote players render smoothly via interpolation between buffered server snapshots.

Output: PredictionSystem class, InterpolationSystem class, and GameScene rewritten to use both systems. Movement feels instant locally and smooth remotely, even at 150ms latency.
</objective>

<execution_context>
@/Users/jonasbrandvik/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jonasbrandvik/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-core-movement/02-RESEARCH.md
@.planning/phases/02-core-movement/02-01-SUMMARY.md
@shared/physics.ts
@client/src/scenes/GameScene.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PredictionSystem and InterpolationSystem</name>
  <files>client/src/systems/Prediction.ts, client/src/systems/Interpolation.ts</files>
  <action>
Create `client/src/systems/` directory with two files:

**Prediction.ts** — Client-side prediction with server reconciliation:

Import `applyMovementPhysics`, `updateFacingDirection`, `InputState`, `PHYSICS` from `../../shared/physics` (relative path from client/src/systems/).

```typescript
interface PendingInput {
  seq: number;
  input: InputState;
}

interface PlayerState {
  x: number;
  y: number;
  vx: number;
  vy: number;
  angle: number;
}
```

Class `PredictionSystem`:
- Private fields: `inputSequence: number = 0`, `pendingInputs: PendingInput[] = []`, `localState: PlayerState` (current predicted state)
- Constructor takes `initialState: PlayerState`
- `sendInput(input: InputState, room: Room): void`:
  1. Increment `inputSequence`
  2. Send to server: `room.send('input', { seq: this.inputSequence, left, right, up, down })`
  3. Apply prediction locally: call `applyMovementPhysics(this.localState, input, 1/60)` then `updateFacingDirection(this.localState)`
  4. Push `{ seq: this.inputSequence, input }` to `pendingInputs`
- `reconcile(serverState: { x, y, vx, vy, angle, lastProcessedSeq }): void`:
  1. Discard acknowledged inputs: `this.pendingInputs = this.pendingInputs.filter(p => p.seq > serverState.lastProcessedSeq)`
  2. Reset localState to server values: `x, y, vx, vy, angle`
  3. Replay all remaining pending inputs: for each, call `applyMovementPhysics(this.localState, pending.input, 1/60)` and `updateFacingDirection(this.localState)`
- `getState(): PlayerState` — returns current `localState` (readonly copy or direct reference)
- `reset(state: PlayerState): void` — reset localState and clear pendingInputs (for teleports/respawns)

**Interpolation.ts** — Entity interpolation for remote players:

```typescript
interface Snapshot {
  timestamp: number;
  x: number;
  y: number;
  angle: number;
}
```

Class `InterpolationSystem`:
- Private fields: `buffers: Map<string, Snapshot[]>`, `renderDelay: number` (default 100ms from NETWORK.interpolationDelay)
- `addSnapshot(sessionId: string, snapshot: Snapshot): void`:
  1. Get or create buffer for sessionId
  2. Push snapshot
  3. Prune old snapshots: keep only last 1000ms worth
- `removePlayer(sessionId: string): void` — delete buffer entry
- `getInterpolatedState(sessionId: string, currentTime: number): Snapshot | null`:
  1. Get buffer for sessionId; return null if not found or < 2 entries
  2. Calculate `targetTime = currentTime - this.renderDelay`
  3. Find two bracketing snapshots where `from.timestamp <= targetTime <= to.timestamp`
  4. Linear interpolate: `alpha = (targetTime - from.timestamp) / (to.timestamp - from.timestamp)`
  5. Return interpolated `{ x, y, angle, timestamp: targetTime }`
  6. Fallback: if targetTime is ahead of all snapshots, return last snapshot (extrapolation not needed yet)
  7. Fallback: if targetTime is behind all snapshots, return first snapshot

**Import notes:** Import `Room` type from `colyseus.js` in Prediction.ts. Both files must compile without Phaser dependencies (they are pure logic modules).
  </action>
  <verify>
TypeScript compiles: `cd /Users/jonasbrandvik/Projects/banger-game/client && npx tsc --noEmit`
Both files export their classes. No Phaser imports in either file.
  </verify>
  <done>
PredictionSystem handles input sequencing, local prediction, and server reconciliation. InterpolationSystem buffers snapshots and returns interpolated positions for remote players. Both are pure logic modules with no rendering code.
  </done>
</task>

<task type="auto">
  <name>Task 2: Rewrite GameScene to use prediction and interpolation</name>
  <files>client/src/scenes/GameScene.ts</files>
  <action>
Rewrite `GameScene.ts` to integrate PredictionSystem and InterpolationSystem. Keep existing tilemap setup and connection logic. Replace the pure-server-authority rendering with prediction for local player and interpolation for remote players.

**New imports:**
- `PredictionSystem` from `../systems/Prediction`
- `InterpolationSystem` from `../systems/Interpolation`
- `InputState` from `../../shared/physics` (relative from client/src/scenes/)

**New private fields:**
- `prediction: PredictionSystem | null = null`
- `interpolation: InterpolationSystem`  (instantiate in constructor or create())
- `lastInput: InputState = { left: false, right: false, up: false, down: false }`
- `remotePlayers: Set<string>` (track which sessionIds are remote)

**Changes to `create()` method:**

In the `onAdd` callback:
- If `sessionId === this.room.sessionId` (local player):
  - Create PredictionSystem with initial state `{ x: player.x, y: player.y, vx: player.vx, vy: player.vy, angle: player.angle }`
  - Set up `player.onChange()` to call `this.prediction.reconcile({ x: player.x, y: player.y, vx: player.vx, vy: player.vy, angle: player.angle, lastProcessedSeq: player.lastProcessedSeq })`
  - After reconciliation, update sprite position from `this.prediction.getState()`
- If remote player:
  - Add sessionId to `remotePlayers` set
  - Set up `player.onChange()` to call `this.interpolation.addSnapshot(sessionId, { timestamp: Date.now(), x: player.x, y: player.y, angle: player.angle })`
  - Do NOT directly set sprite position in onChange (interpolation handles it)

In the `onRemove` callback:
- Call `this.interpolation.removePlayer(sessionId)` for remote players
- Remove from `remotePlayers` set

**Changes to `update()` method:**

1. Read input (existing logic)
2. If any key pressed AND input differs from lastInput:
   - Call `this.prediction.sendInput(input, this.room)` — this sends to server AND predicts locally
   - Update lastInput
3. If no keys pressed AND lastInput had keys pressed:
   - Send empty input via prediction too (so server knows keys released — important for drag to work correctly on server)
   - Update lastInput
4. Update local player sprite from prediction state:
   ```
   const state = this.prediction.getState();
   localSprite.x = state.x;
   localSprite.y = state.y;
   // Optionally set rotation: localSprite.rotation = state.angle;
   ```
5. Update remote player sprites via interpolation:
   ```
   for (const sessionId of this.remotePlayers) {
     const interpolated = this.interpolation.getInterpolatedState(sessionId, Date.now());
     if (interpolated) {
       const sprite = this.playerSprites.get(sessionId);
       if (sprite) {
         sprite.x = interpolated.x;
         sprite.y = interpolated.y;
         // sprite.rotation = interpolated.angle;
       }
       const label = this.playerLabels.get(sessionId);
       if (label) {
         label.x = interpolated.x;
         label.y = interpolated.y - 20;
       }
     }
   }
   ```

**Critical detail — send input even when "no keys pressed" to communicate key release:**
The current Phase 1 code only sends input when keys are pressed. For acceleration physics, the server needs to know when keys are RELEASED so it applies drag correctly. Change logic to:
- Track `lastInput` state
- Send on ANY change (including all keys released → `{ left: false, right: false, up: false, down: false }`)
- Only skip sending if input is identical to lastInput AND lastInput was already all-false (truly idle)

**Keep existing:** Tilemap setup, connection error handling, status text, sprite creation/destruction, player labels.
  </action>
  <verify>
1. `cd /Users/jonasbrandvik/Projects/banger-game/client && npx tsc --noEmit` — compiles
2. Start server: `cd server && npm run dev`
3. Start client: `cd client && npm run dev`
4. Open http://localhost:8080 — player connects, green rectangle appears
5. Press WASD — movement should feel IMMEDIATE (no network delay visible)
6. Release keys — player should decelerate smoothly (drag effect)
7. Move diagonally — speed should be same as cardinal
8. Open second tab — remote player should move smoothly (interpolation)
9. Test with latency: `SIMULATE_LATENCY=100 npm run dev` on server, movement should still feel responsive locally
  </verify>
  <done>
GameScene uses PredictionSystem for local player (immediate movement feel) and InterpolationSystem for remote players (smooth rendering). Input changes communicated to server including key release. Facing direction updates with movement.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify movement feel at normal and high latency</name>
  <files>N/A (verification only)</files>
  <action>
Human verification checkpoint. Verify acceleration-based movement with client-side prediction and entity interpolation. Local player should move instantly, remote players should move smoothly, and the game should be playable at 150ms latency.

**Setup:**
1. Start server: `cd server && npm run dev`
2. Start client: `cd client && npm run dev`
3. Open http://localhost:8080

**Test 1 — Local movement feel (0ms latency):**
1. Press W — player should start moving UP immediately (no delay)
2. Release W — player should decelerate and stop (not instant stop)
3. Press W+D — diagonal movement should feel same speed as W alone
4. Quick tap A then D — should feel responsive direction changes

**Test 2 — Remote player smoothness:**
1. Open second browser tab to http://localhost:8080
2. Move player in tab 1 — watch tab 2, remote player should move smoothly (no teleporting/jumping)
3. Move player in tab 2 — watch tab 1, same smooth movement

**Test 3 — High latency (150ms):**
1. Stop server
2. Restart with latency: `cd server && SIMULATE_LATENCY=150 npm run dev`
3. Open http://localhost:8080
4. Move with WASD — local movement should STILL feel responsive (prediction masks the latency)
5. Look for "rubberbanding" (player snapping back) — minor corrections are OK, large snaps are not
6. Open second tab — remote player should still move (may be slightly delayed but smooth)
  </action>
  <verify>
User confirms: local movement instant, remote movement smooth, 150ms latency playable
  </verify>
  <done>
Local: instant response, smooth acceleration/deceleration. Remote: smooth movement, ~100ms behind real time. At 150ms: local still responsive, minor corrections acceptable but no game-breaking snaps. User typed "approved".
  </done>
</task>

</tasks>

<verification>
1. PredictionSystem exists with sendInput() and reconcile() methods
2. InterpolationSystem exists with addSnapshot() and getInterpolatedState() methods
3. GameScene uses prediction for local player and interpolation for remote players
4. Local player movement feels instant (prediction applied in same frame as input)
5. Remote players move smoothly (interpolation between buffered snapshots)
6. Key release is communicated to server (player decelerates when keys released)
7. Character faces movement direction (angle updates with velocity)
8. TypeScript compiles with zero errors
9. Game playable at 150ms simulated latency
</verification>

<success_criteria>
- Local player movement feels responsive (input-to-visual latency under 16ms — one frame)
- Remote players move smoothly without teleporting
- Facing direction follows movement
- No visible rubberbanding at <50ms latency
- Game remains playable at 150ms latency (minor corrections acceptable)
- Human verification approved
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-movement/02-02-SUMMARY.md`
</output>
