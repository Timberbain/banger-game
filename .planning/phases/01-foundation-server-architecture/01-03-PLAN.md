---
phase: 01-foundation-server-architecture
plan: 03
type: execute
wave: 2
depends_on: ["01-01", "01-02"]
files_modified:
  - client/src/scenes/GameScene.ts
  - client/src/scenes/BootScene.ts
  - client/src/main.ts
  - server/src/rooms/GameRoom.ts
  - server/src/index.ts
autonomous: false

must_haves:
  truths:
    - "Player opens browser, sees game canvas, connects to server, and a sprite appears at their position"
    - "WASD/arrow key input is sent to server, server processes it, and player sprite moves on screen"
    - "A second browser tab connects and both players see each other's sprites moving"
    - "Server rejects malformed input (non-boolean values, unknown keys) without crashing"
    - "Latency simulation at 100ms+ is configurable via SIMULATE_LATENCY env var"
    - "Delta state sync transmits only changed properties (verified by Colyseus monitor or network inspection)"
  artifacts:
    - path: "client/src/scenes/GameScene.ts"
      provides: "Main game scene with Colyseus connection, state sync rendering, input sending"
      contains: "colyseus.js"
    - path: "server/src/rooms/GameRoom.ts"
      provides: "Updated room with input validation logic"
      contains: "isValidInput"
    - path: "server/src/index.ts"
      provides: "Updated server with latency simulation middleware"
      contains: "simulate-latency"
  key_links:
    - from: "client/src/scenes/GameScene.ts"
      to: "server/src/rooms/GameRoom.ts"
      via: "client.joinOrCreate('game_room') -> WebSocket connection"
      pattern: "joinOrCreate.*game_room"
    - from: "client/src/scenes/GameScene.ts"
      to: "room.state.players.onAdd"
      via: "Schema state sync callbacks for rendering"
      pattern: "onAdd.*player"
    - from: "client/src/scenes/GameScene.ts"
      to: "room.send('input')"
      via: "Keyboard input sent as messages to server"
      pattern: "room\\.send.*input"
    - from: "server/src/rooms/GameRoom.ts"
      to: "isValidInput"
      via: "Input validation before queuing"
      pattern: "isValidInput"
---

<objective>
Wire the client to the server: connect via Colyseus, render player sprites from server state, send keyboard input, validate input on server, and configure latency simulation.

Purpose: This is the integration plan that proves the entire authority model works end-to-end. The client connects to the server, the server manages all state, and the client purely renders what the server tells it. Input validation prevents cheating. Latency simulation enables testing network conditions.

Output: A working multiplayer demo where multiple browser tabs can connect, see each other, and move around the arena with server-authoritative state.
</objective>

<execution_context>
@/Users/jonasbrandvik/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jonasbrandvik/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-server-architecture/01-RESEARCH.md
@.planning/phases/01-foundation-server-architecture/01-01-SUMMARY.md
@.planning/phases/01-foundation-server-architecture/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create GameScene with Colyseus connection and state-synced rendering</name>
  <files>
    client/src/scenes/GameScene.ts
    client/src/scenes/BootScene.ts
    client/src/main.ts
  </files>
  <action>
    Create the main GameScene that connects to the Colyseus server, renders players based on server state, and sends keyboard input.

    **client/src/scenes/GameScene.ts:**

    Properties:
    - client: Client (from colyseus.js) -- initialized with "ws://localhost:2567"
    - room: Room (nullable, set after joining)
    - playerSprites: Map<string, Phaser.GameObjects.Rectangle> (sessionId -> sprite, use rectangles as placeholder graphics)
    - playerLabels: Map<string, Phaser.GameObjects.Text> (sessionId -> name label)
    - cursors: Phaser.Types.Input.Keyboard.CursorKeys
    - wasd: { W, A, S, D } key objects
    - connected: boolean = false
    - statusText: Phaser.GameObjects.Text

    preload():
    - Load tileset and tilemap (same assets as BootScene -- they will be cached by Phaser if already loaded)
      ```
      this.load.image('tiles', 'tilesets/placeholder.png');
      this.load.tilemapTiledJSON('test_arena', 'maps/test_arena.json');
      ```

    create():
    - Set up tilemap (create map, add tileset, create ground and walls layers)
    - Set up keyboard: this.cursors = this.input.keyboard.createCursorKeys() for arrow keys
    - Set up WASD: this.input.keyboard.addKeys('W,A,S,D')
    - Add status text at top-left of screen showing connection state
    - Connect to Colyseus:
      ```typescript
      try {
        this.room = await this.client.joinOrCreate("game_room");
        this.connected = true;
        statusText.setText(`Connected: ${this.room.sessionId}`);

        // Listen for players joining
        this.room.state.players.onAdd((player, sessionId) => {
          // Create a colored rectangle (24x24) as placeholder player sprite
          const isLocal = sessionId === this.room.sessionId;
          const color = isLocal ? 0x00ff88 : 0xff4444; // Green for local, red for others
          const rect = this.add.rectangle(player.x, player.y, 24, 24, color);
          rect.setDepth(10); // Above tilemap
          this.playerSprites.set(sessionId, rect);

          // Add player name text above sprite
          const nameText = this.add.text(player.x, player.y - 20, player.name || sessionId.slice(0, 6), {
            fontSize: '12px',
            color: '#ffffff',
          }).setOrigin(0.5).setDepth(11);
          this.playerLabels.set(sessionId, nameText);

          // Listen for state changes on this player
          player.onChange(() => {
            const sprite = this.playerSprites.get(sessionId);
            if (sprite) {
              sprite.x = player.x;
              sprite.y = player.y;
            }
            const label = this.playerLabels.get(sessionId);
            if (label) {
              label.x = player.x;
              label.y = player.y - 20;
            }
          });
        });

        // Listen for players leaving
        this.room.state.players.onRemove((player, sessionId) => {
          const sprite = this.playerSprites.get(sessionId);
          if (sprite) {
            sprite.destroy();
            this.playerSprites.delete(sessionId);
          }
          const label = this.playerLabels.get(sessionId);
          if (label) {
            label.destroy();
            this.playerLabels.delete(sessionId);
          }
        });

      } catch (e) {
        console.error("Connection failed:", e);
        statusText.setText("Connection failed - is server running?");
      }
      ```

    update(time, delta):
    - If not connected or no room, return early
    - Read current keyboard state:
      ```typescript
      const input = {
        left: this.cursors.left.isDown || this.wasd.A.isDown,
        right: this.cursors.right.isDown || this.wasd.D.isDown,
        up: this.cursors.up.isDown || this.wasd.W.isDown,
        down: this.cursors.down.isDown || this.wasd.S.isDown,
      };
      ```
    - Only send input if any key is pressed (don't spam empty inputs):
      ```typescript
      if (input.left || input.right || input.up || input.down) {
        this.room.send("input", input);
      }
      ```
    - IMPORTANT: Do NOT apply movement locally. This is pure server authority -- the sprite position updates ONLY from server state via onChange callback. Movement will feel slightly laggy on localhost (sub-ms) but this is correct for Phase 1. Client prediction is deferred to a later phase.

    **Update client/src/scenes/BootScene.ts:**
    - Change create() to transition to GameScene after a brief delay (or immediately):
      `this.scene.start('GameScene')`
    - BootScene becomes a loading/splash screen that transitions to GameScene

    **Update client/src/main.ts:**
    - Add GameScene to the Phaser scene list: scene: [BootScene, GameScene]
    - BootScene is first (loads assets), then transitions to GameScene

    IMPORTANT: Do NOT use interpolation or tweens for the LOCAL player. Only render what the server sends. For OTHER players, also just snap to server position for now (interpolation is a Phase 2 concern).

    IMPORTANT: Handle the case where room connection fails gracefully -- show error message, don't crash.
  </action>
  <verify>
    1. Start server: `cd server && npm run dev`
    2. Start client: `cd client && npm run dev`
    3. Open http://localhost:8080 -- should see tilemap, then connect and show green rectangle
    4. Press WASD or arrow keys -- green rectangle should move (with slight network delay)
    5. Open second tab at http://localhost:8080 -- should see two rectangles, both controllable independently
    6. Check Colyseus monitor at http://localhost:2567/colyseus -- should show room with players
  </verify>
  <done>Multiple browser tabs can connect to server, each sees all players as colored rectangles, WASD/arrow input moves the local player via server authority, player join/leave is handled.</done>
</task>

<task type="auto">
  <name>Task 2: Add server input validation and latency simulation</name>
  <files>
    server/src/rooms/GameRoom.ts
    server/src/index.ts
  </files>
  <action>
    Add input validation to reject invalid client messages and configure latency simulation for testing.

    **Update server/src/rooms/GameRoom.ts:**

    Add isValidInput method:
    ```typescript
    private isValidInput(input: any): boolean {
      // Must be an object
      if (typeof input !== 'object' || input === null || Array.isArray(input)) return false;

      const validKeys = ['left', 'right', 'up', 'down'];

      // Check for unknown keys
      for (const key of Object.keys(input)) {
        if (!validKeys.includes(key)) return false;
      }

      // All values must be booleans
      for (const key of validKeys) {
        if (key in input && typeof input[key] !== 'boolean') return false;
      }

      return true;
    }
    ```

    Update onMessage handler to validate BEFORE queuing:
    ```typescript
    this.onMessage("input", (client, message) => {
      const player = this.state.players.get(client.sessionId);
      if (!player) return;

      // Validate input structure and types
      if (!this.isValidInput(message)) {
        console.warn(`Invalid input from ${client.sessionId}:`, message);
        return; // Silently reject -- don't kick (could be a bug, not necessarily cheating)
      }

      // Rate limit: cap queue at 10 to prevent memory abuse
      if (player.inputQueue.length >= 10) {
        player.inputQueue.shift(); // Drop oldest
      }

      player.inputQueue.push(message);
    });
    ```

    Add input rate limiting: Track last input timestamp per player. If more than 120 inputs per second (2x tick rate -- generous to allow for client frame rate variance), log warning but don't reject (for now).

    **Update server/src/index.ts:**

    Add latency simulation middleware (development only):
    ```typescript
    // Latency simulation for testing (dev only)
    const simulateLatency = parseInt(process.env.SIMULATE_LATENCY || '0', 10);
    if (simulateLatency > 0) {
      console.log(`Latency simulation enabled: ${simulateLatency}ms`);
      // Use express-simulate-latency middleware
      const simulateLatencyMiddleware = require('express-simulate-latency');
      app.use(simulateLatencyMiddleware(simulateLatency));
    }
    ```

    Note: express-simulate-latency only affects HTTP requests, not WebSocket messages. For WebSocket latency simulation, add a custom approach in the GameRoom that delays input processing when SIMULATE_LATENCY env var is set:
    ```typescript
    // In GameRoom onMessage handler, if SIMULATE_LATENCY is set:
    const wsLatency = parseInt(process.env.SIMULATE_LATENCY || '0', 10);
    if (wsLatency > 0) {
      // Delay input queuing to simulate round-trip latency
      setTimeout(() => {
        player.inputQueue.push(message);
      }, wsLatency);
      return;
    }
    ```

    PRACTICAL APPROACH for latency simulation: Use SIMULATE_LATENCY env var to add delay to both HTTP middleware and WebSocket input processing. Also document that Chrome DevTools Network throttling (custom profile: add 100ms latency) is an additional testing method.

    Also add to server/src/index.ts:
    - A simple health check endpoint: `app.get('/health', (req, res) => res.json({ status: 'ok', uptime: process.uptime() }))`
    - CORS headers via cors middleware or manual headers to allow client on port 8080 to access monitor on port 2567
  </action>
  <verify>
    1. Start server: `cd server && npm run dev`
    2. Test invalid input: From browser console, manually send `room.send("input", { speed: 9999 })` -- server should log warning and not crash
    3. Test valid input: Normal WASD play works as before
    4. Test health endpoint: `curl http://localhost:2567/health` returns `{"status":"ok",...}`
    5. Test latency sim: `SIMULATE_LATENCY=100 npm run dev` -- movement should feel noticeably delayed
    6. Test with Chrome DevTools: Network tab -> Custom throttle profile -> Add 100ms latency -> game should feel sluggish but still work
  </verify>
  <done>Server validates all client input (rejects non-object, unknown keys, non-boolean values), latency simulation is configurable via SIMULATE_LATENCY env var affecting both HTTP and WebSocket, health check endpoint works, CORS configured for dev.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify end-to-end multiplayer connection</name>
  <files>
    none
  </files>
  <action>
    Human verification of the complete Phase 1 foundation. All code is already implemented in Tasks 1-2.
    The user needs to verify the following end-to-end behaviors in the browser.
  </action>
  <verify>
    1. Start server: `cd server && npm run dev` (should print "Banger server listening on ws://localhost:2567")
    2. Start client: `cd client && npm run dev` (should start on port 8080)
    3. Open http://localhost:8080 in browser:
       - Should see tilemap with ground and walls
       - A green rectangle (your player) should appear
       - Status text should show "Connected: [session-id]"
    4. Press WASD or arrow keys -- your rectangle should move around the arena
    5. Open a second browser tab at http://localhost:8080:
       - Both tabs should show two rectangles (green = local, red = other player)
       - Moving in one tab should be visible in the other tab
    6. Visit http://localhost:2567/colyseus -- should show the room monitor with active room and connected clients
    7. Close one tab -- the other tab should remove the disconnected player's rectangle
    8. Open browser DevTools Network tab and enable throttling (add 100ms latency) -- game should still work, just feel slightly delayed
  </verify>
  <done>All 8 verification steps pass. Phase 1 success criteria confirmed: browser connects to server, 60Hz tick runs, delta sync works, input validation rejects bad data, latency testing tools work.</done>
</task>

</tasks>

<verification>
1. Server starts on port 2567, client starts on port 8080
2. Browser connects to Colyseus room automatically
3. Player sprite appears at server-assigned position
4. WASD/arrow input moves player via server authority (no client-side prediction)
5. Multiple tabs show all players, movements sync in real-time
6. Invalid input is rejected without crashing server
7. Colyseus monitor shows room state at /colyseus
8. Health check returns OK at /health
9. Chrome DevTools throttling at 100ms+ doesn't break gameplay
10. Player disconnect removes sprite from other clients
</verification>

<success_criteria>
- Two browser tabs can connect to same room and see each other
- Input flows: keyboard -> client send -> server validate -> server fixedTick -> state update -> client render
- Invalid inputs are rejected server-side (tested manually)
- Latency simulation tools are documented and partially configured
- Full Phase 1 success criteria met:
  1. Player can open game in browser and connect to server
  2. Server runs at fixed 60Hz tick rate
  3. Delta state sync works (only changed properties transmitted)
  4. Server validates client input and rejects impossible values
  5. Latency simulation tools configured for testing at 100ms+
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-server-architecture/01-03-SUMMARY.md`
</output>
