# Phase 09.1: Tilemap Collision Masks for Precise Wall/Obstacle Collisions - Research

**Researched:** 2026-02-16
**Domain:** AABB sub-tile collision resolution, tileset pixel analysis, shared collision system
**Confidence:** HIGH

<user_constraints>
## User Constraints (from CONTEXT.md)

### Locked Decisions
- Sub-tile rectangles: each tile type defines a single inner bounding rectangle within the 32x32 tile
- Collision rects auto-derived from tileset PNG art (tightest bounding box around non-transparent pixels)
- Manual override mechanism for specific tile types where auto-derivation produces poor results
- Collision shape data stored in map JSON metadata (not shared/ constants) -- loaded at runtime by both server and client
- Uniform code path: even tiles whose auto-derived rect equals full tile use the sub-rect system (no fast-path optimization)
- Paran wall penalty unchanged: lose ALL velocity on any wall hit, but trigger is now tighter (only actual art contact)
- Projectiles also use precise collision shapes -- shots can pass through visual gaps, consistent with player collision
- Player collision radii remain unchanged -- only wall/obstacle boundaries tighten
- No arena layout adjustments -- visual gaps from precise collision are the intended play space
- All solid tiles get collision masks: walls, destructible obstacles (all tiers), and arena border tiles
- Only currently-solid tiles -- ground and decoration tiles remain fully passable
- No new semi-solid tile types introduced
- Collision rect = exact opaque pixel bounding box (no padding in or out)
- Separate script for collision shape generation (not integrated into generate-arenas.py)
- Toggle-able debug visualization (e.g., F3 key) overlays collision rectangles on tiles during development

### Claude's Discretion
- Internal data format for collision shape metadata in map JSON
- How to handle the sub-rect AABB resolution algorithm changes in shared/collisionGrid.ts
- Debug visualization rendering approach (Phaser graphics overlay)
- Specific tile types that need manual overrides (determined after auto-derivation)

### Deferred Ideas (OUT OF SCOPE)
None -- discussion stayed within phase scope
</user_constraints>

## Summary

This phase replaces full-tile AABB collision with sub-tile rectangle collision in `shared/collisionGrid.ts`. Currently, every solid tile occupies a full 32x32 collision box, meaning players and projectiles collide with invisible boundaries around the visual art. The goal is to derive a tighter bounding rectangle per tile type from the actual opaque pixels in each tileset PNG, then use those sub-rectangles during collision resolution.

The change is contained to a small set of files but touches a critical hot path (60Hz server tick + client prediction). The core algorithm change is in `resolveCollisions()` -- instead of checking if an entity's AABB overlaps a full tile, it must check overlap against a sub-rectangle within that tile. The push-out logic changes from "push to tile edge" to "push to sub-rect edge within tile."

**Primary recommendation:** Build a Python script that reads the 3 composite tileset PNGs, computes the opaque pixel bounding box for each of the 112 tile slots, stores the collision rect data (x, y, w, h offsets within the 32x32 tile) in a JSON sidecar per tileset, then embed those rects into the map JSON during arena generation. Modify `CollisionGrid` to accept and use per-tile collision rects for all resolution math.

## Standard Stack

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| PIL/Pillow | Already in project | Tileset pixel scanning for bounding box derivation | Already used by generate-assets.py and generate-arenas.py |
| shared/collisionGrid.ts | Existing | AABB-vs-tile collision resolution (modification target) | Project's shared collision system |
| Phaser 3.90 Graphics | Existing | Debug overlay rendering for collision rect visualization | Built-in Phaser drawing API |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| json (Python stdlib) | N/A | Write collision shape data to JSON files | Pipeline script output |
| fs (Node.js) | N/A | Server reads collision data from map JSON at room creation | Server-side map loading |

### Alternatives Considered
None -- all tools are already in the project. No new dependencies needed.

## Architecture Patterns

### Recommended Project Structure
```
scripts/
├── generate-arenas.py          # EXISTING: generates maps + tilesets
├── generate-assets.py          # EXISTING: generates sprites
└── generate-collision-masks.py # NEW: scans tilesets, outputs collision rect JSON

shared/
└── collisionGrid.ts            # MODIFIED: accepts + uses per-tile sub-rects

client/public/maps/
├── hedge_garden.json           # MODIFIED: includes collisionShapes in tileset metadata
├── brick_fortress.json         # MODIFIED: includes collisionShapes in tileset metadata
└── timber_yard.json            # MODIFIED: includes collisionShapes in tileset metadata

client/src/scenes/
└── GameScene.ts                # MODIFIED: debug overlay toggle, passes collision data
```

### Pattern 1: Collision Shape Data Format in Map JSON

**What:** Embed per-tile collision rectangles inside the existing map JSON's tileset entry, keyed by tile ID. Each rect is {x, y, w, h} as pixel offsets within the 32x32 tile.

**When to use:** Always -- both server and client load map JSON, so collision data travels with it.

**Recommended format:**
```json
{
  "tilesets": [{
    "firstgid": 1,
    "columns": 8,
    "image": "../tilesets/arena_hedge.png",
    "name": "arena_hedge",
    "tilewidth": 32,
    "tileheight": 32,
    "properties": {
      "collisionShapes": {
        "1": { "x": 4, "y": 2, "w": 24, "h": 28 },
        "2": { "x": 0, "y": 2, "w": 30, "h": 28 },
        "101": { "x": 0, "y": 0, "w": 32, "h": 32 },
        "_default": { "x": 0, "y": 0, "w": 32, "h": 32 }
      }
    }
  }]
}
```

**Rationale:** Using the Tiled JSON's `properties` field is a clean extension point. Keys are string tile IDs (matching firstgid-based IDs used in layer data). The `_default` key provides a fallback for any tile ID not explicitly listed (should be full-tile). This format is compact, human-readable, and easy to iterate over during grid construction.

**Alternative considered:** Separate JSON sidecar file per tileset. Rejected because it adds file management complexity and load-order concerns. Embedding in map JSON keeps everything in one load.

### Pattern 2: Sub-Rect Collision Resolution Algorithm

**What:** Modify `resolveCollisions()` to check entity AABB against a sub-rectangle within each tile, not the full tile.

**Current algorithm:**
1. Compute which tiles the entity's AABB overlaps (using full tile boundaries)
2. For each solid tile, push entity to the tile edge

**New algorithm:**
1. Compute which tiles the entity's AABB overlaps (same as before -- this is the broad phase)
2. For each solid tile, compute the sub-rect's world-space bounds: `tileX * tileSize + subRect.x` to `tileX * tileSize + subRect.x + subRect.w`
3. Check if the entity's AABB actually overlaps the sub-rect (narrow phase)
4. If overlapping, push entity to the sub-rect edge (not the tile edge)

**Key insight:** The broad phase (which tiles to check) remains unchanged. Only the narrow phase overlap test and push-out positions change. This minimizes risk.

**Push-out positions change from:**
```typescript
// Old: push to full tile edge
entity.x = tx * tileSize - radius - COLLISION_EPSILON;        // right edge of entity at left edge of tile
entity.x = (tx + 1) * tileSize + radius;                      // left edge of entity at right edge of tile
```

**To:**
```typescript
// New: push to sub-rect edge within tile
const rectLeft = tx * tileSize + subRect.x;
const rectRight = tx * tileSize + subRect.x + subRect.w;
entity.x = rectLeft - radius - COLLISION_EPSILON;              // right edge of entity at left edge of sub-rect
entity.x = rectRight + radius;                                 // left edge of entity at right edge of sub-rect
```

### Pattern 3: CollisionGrid Enhancement

**What:** Extend `CollisionGrid` to store per-tile collision rects alongside the existing `TileInfo`.

**Current `TileInfo`:**
```typescript
interface TileInfo {
  solid: boolean;
  destructible: boolean;
  tileId: number;
}
```

**Enhanced `TileInfo`:**
```typescript
interface CollisionRect {
  x: number;  // Offset within tile (0-31)
  y: number;  // Offset within tile (0-31)
  w: number;  // Width of collision rect (1-32)
  h: number;  // Height of collision rect (1-32)
}

interface TileInfo {
  solid: boolean;
  destructible: boolean;
  tileId: number;
  collisionRect: CollisionRect;  // Sub-tile collision shape
}
```

**Constructor changes:** Accept a `collisionShapes` map (tile ID -> CollisionRect) in addition to current parameters. Look up each tile's collision rect during grid construction. Default to full-tile if no shape is defined.

### Pattern 4: Bounding Box Auto-Derivation Script

**What:** Python script that scans tileset PNGs and computes the tightest opaque bounding box per tile.

**Algorithm per tile:**
1. Extract the 32x32 tile region from the composite tileset PNG
2. Scan all pixels; collect coordinates where alpha > 0
3. Compute min/max x and y of opaque pixels
4. Output as {x: minX, y: minY, w: maxX - minX + 1, h: maxY - minY + 1}
5. If no opaque pixels (fully transparent tile), output null (tile is not solid)

**Critical edge cases:**
- Tiles with single stray opaque pixels far from the main body would create overly large bounding boxes. This is where manual overrides come in.
- Obstacle tiles (IDs 101-103) may have reduced opacity but are still fully solid. The script must detect alpha > 0, not alpha > 128.
- The obstacle canopy tiles use the isolated_single sprite with varying opacity (1.0, 0.8, 0.6), so they will have the same bounding box as the isolated_single wall canopy.

**Script outputs:** JSON file per tileset with collision rects keyed by tile ID. The `generate-arenas.py` script then reads these JSON files and embeds them in the map JSON.

### Pattern 5: Debug Visualization

**What:** F3 key toggle overlays semi-transparent rectangles on every solid tile showing its collision bounds.

**Approach:** Use `Phaser.GameObjects.Graphics` to draw rectangles. Create a graphics object on demand when F3 is pressed; destroy it when F3 is pressed again.

**Implementation:**
```typescript
// In GameScene
private debugCollisionOverlay: Phaser.GameObjects.Graphics | null = null;

// In create() or update(), on F3 keydown:
if (Phaser.Input.Keyboard.JustDown(this.f3Key)) {
  if (this.debugCollisionOverlay) {
    this.debugCollisionOverlay.destroy();
    this.debugCollisionOverlay = null;
  } else {
    this.debugCollisionOverlay = this.add.graphics();
    this.debugCollisionOverlay.setDepth(999);
    // Draw all collision rects from collisionGrid
    this.drawDebugCollisionRects();
  }
}
```

**Color coding suggestion:**
- Indestructible walls: red outline (0xff0000, alpha 0.3)
- Heavy obstacles: orange outline (0xff8800, alpha 0.3)
- Medium obstacles: yellow outline (0xffff00, alpha 0.3)
- Light obstacles: green outline (0x00ff00, alpha 0.3)

### Anti-Patterns to Avoid

- **Per-frame collision rect lookup from a separate data structure:** The collision rect must be stored directly in `TileInfo` on the grid, not looked up from a separate map during the hot loop. The current grid access pattern (`grid[tileY][tileX]`) must include the rect data inline.

- **Different collision behavior between server and client:** Both server (`GameRoom.loadMap`) and client (`GameScene.createTilemap`) build `CollisionGrid` from the same map JSON. The collision shape data must be identical in both code paths.

- **Modifying broad-phase tile scanning:** The current approach of computing which tiles the entity AABB overlaps by dividing by tileSize is correct and must stay unchanged. Only the per-tile narrow-phase check should change.

- **Using non-axis-aligned shapes:** The decision locks sub-tile rects as the only collision shape. Do not attempt circles, polygons, or multiple rects per tile.

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Pixel bounding box detection | Manual pixel iteration in TypeScript | PIL/Pillow `getbbox()` on alpha channel | PIL's `getbbox()` returns the tightest RGBA bounding box in one call; handles edge cases like all-transparent tiles |
| JSON merging collision data into maps | Custom file merging logic | Python dict.update in generate-arenas.py | Already have the map generation pipeline; just add collision data to the output dict |
| Debug rect drawing | Custom Canvas2D rendering | Phaser.GameObjects.Graphics | Built into the engine, handles camera transforms automatically |

**Key insight:** PIL's `Image.getbbox()` returns `(left, upper, right, lower)` of the non-zero bounding box, or `None` if the image is fully transparent. This is exactly the primitive needed for auto-derivation, and it handles the alpha channel correctly. However, note that `getbbox()` operates on non-zero values across ALL channels, so for accurate alpha-only detection, first isolate the alpha channel with `.split()[3]` then call `.getbbox()` on it.

## Common Pitfalls

### Pitfall 1: Projectile Point-vs-SubRect Collision
**What goes wrong:** Projectiles currently use a point check (`worldToTile` + `isSolid`) which checks the tile the projectile center is in. With sub-tile rects, a projectile could be inside the tile grid cell but outside the sub-rect collision area.
**Why it happens:** The projectile collision in GameRoom line 627-641 does `worldToTile(proj.x, proj.y)` then `isSolid(tile)`. This implicitly treats the entire tile as solid.
**How to avoid:** Add a `isPointInCollisionRect(worldX, worldY)` method to CollisionGrid that checks whether a world coordinate falls within the sub-rect of its containing tile. Use this instead of `isSolid` for projectile collision.
**Warning signs:** Projectiles passing through visual walls or stopping in empty space next to walls.

### Pitfall 2: CollisionGrid Constructor Signature Change Breaking Both Consumers
**What goes wrong:** Changing the `CollisionGrid` constructor in shared code breaks both server and client simultaneously if not updated in sync.
**Why it happens:** The constructor is called in `GameRoom.loadMap()` (server) and `GameScene.createTilemap()` (client) with identical parameters. Adding a new parameter must happen in both places.
**How to avoid:** Make the new `collisionShapes` parameter optional with a default of empty map `{}`. This way existing code works unchanged, and shapes can be added incrementally.
**Warning signs:** TypeScript compilation errors in either server or client after modifying shared code.

### Pitfall 3: Entity AABB vs Sub-Rect Overlap False Negatives
**What goes wrong:** Entity slides through walls because the sub-rect check has an edge case where the entity AABB overlaps the tile grid cell but the narrow-phase sub-rect check fails when it shouldn't.
**Why it happens:** Off-by-one errors in the overlap check, or using wrong coordinate spaces (tile-local vs world-space).
**How to avoid:** Compute sub-rect world bounds once: `worldLeft = tileX * tileSize + rect.x`, etc. Then use standard AABB overlap: `entityRight > worldLeft && entityLeft < worldRight && entityBottom > worldTop && entityTop < worldBottom`.
**Warning signs:** Players clipping through walls they should collide with, especially at corners where sub-rects are smaller.

### Pitfall 4: Push-Out Direction Inversion
**What goes wrong:** Entity gets pushed INTO the sub-rect instead of OUT of it, causing stuck-in-wall jitter.
**Why it happens:** The push-out direction depends on comparing entity position to previous position (`prevX`, `prevY`). If the sub-rect edge coordinates are calculated incorrectly, the push-out goes the wrong way.
**How to avoid:** Test push-out with a simple case first: single solid tile with a known sub-rect, entity moving right into it. Verify the entity stops at `rectLeft - radius - EPSILON` (not at `tileX * tileSize - radius - EPSILON`).
**Warning signs:** Entity teleports into walls, or oscillates rapidly at wall boundaries.

### Pitfall 5: Determinism Mismatch Between Server and Client
**What goes wrong:** Client prediction desyncs from server because the collision shapes loaded on each side differ.
**Why it happens:** Server reads map JSON from disk via `fs.readFileSync`. Client reads it from Phaser's tilemap cache which was loaded via Vite. If the JSON is served differently, or if the collision shape parsing has any platform-dependent behavior, they diverge.
**How to avoid:** Use identical collision shape extraction in both paths. The `CollisionGrid` constructor already receives the map data from the same JSON source. Add collision shapes to the constructor and verify both paths pass the same data.
**Warning signs:** Client prediction snaps/jitters that didn't exist before, especially near walls with small sub-rects.

### Pitfall 6: Obstacle Tile Opacity Thresholding
**What goes wrong:** Obstacle tiles (IDs 101-103) use reduced opacity (0.8, 0.6) via `apply_opacity()` in `generate-arenas.py`. If the bounding box script uses too high an alpha threshold, these tiles get incorrect (too small) bounding boxes.
**Why it happens:** `apply_opacity(img, 0.6)` scales alpha to 60% of original. Pixels that were alpha=255 become alpha=153. If the script checks `alpha > 200` they'd be missed.
**How to avoid:** Use `alpha > 0` as the threshold for inclusion in the bounding box, matching the `getbbox()` behavior on the isolated alpha channel.
**Warning signs:** Light obstacles having smaller collision boxes than heavy obstacles despite using the same base sprite shape.

### Pitfall 7: Out-of-Bounds Tile Collision Rects
**What goes wrong:** `isSolid()` returns `true` for out-of-bounds coordinates (treating map edges as walls). These virtual tiles have no `TileInfo` and thus no collision rect.
**How to avoid:** For out-of-bounds tiles, use a full-tile collision rect (0, 0, 32, 32). This is handled naturally by the existing `isSolid()` return-true-for-OOB path, but the new sub-rect resolution code must also handle OOB tiles correctly. The simplest approach: when `getTileInfo()` returns `null` (OOB), treat it as a full-tile collision rect.

### Pitfall 8: Tileset Differences Across Themes
**What goes wrong:** The 3 tilesets (hedge, brick, wood) have different pixel art, so the same tile ID maps to different visual shapes across tilesets, requiring different collision rects per tileset.
**Why it happens:** Each map references a different tileset image. Tile ID 1 in hedge_garden is visually different from tile ID 1 in brick_fortress.
**How to avoid:** The collision shapes are embedded per-map in the map JSON, not shared globally. Each map already references its own tileset. The derivation script runs per-tileset and produces per-tileset collision data, which goes into the per-map JSON.

## Code Examples

### Bounding Box Auto-Derivation (Python)
```python
from PIL import Image

def compute_collision_rects(tileset_path, tile_size=32, columns=8, rows=14):
    """Compute collision rects for all tiles in a composite tileset."""
    img = Image.open(tileset_path).convert("RGBA")
    rects = {}

    for row in range(rows):
        for col in range(columns):
            tile_id = row * columns + col + 1  # firstgid=1
            x0 = col * tile_size
            y0 = row * tile_size
            tile_img = img.crop((x0, y0, x0 + tile_size, y0 + tile_size))

            # Get alpha channel bounding box
            alpha = tile_img.split()[3]  # RGBA -> A channel
            bbox = alpha.getbbox()  # (left, upper, right, lower) or None

            if bbox is None:
                # Fully transparent tile -- not solid, skip
                continue

            left, upper, right, lower = bbox
            rects[str(tile_id)] = {
                "x": left,
                "y": upper,
                "w": right - left,  # getbbox right is exclusive
                "h": lower - upper  # getbbox lower is exclusive
            }

    return rects
```

### Modified CollisionGrid Constructor
```typescript
export interface CollisionRect {
  x: number;  // Offset within tile (pixels)
  y: number;  // Offset within tile (pixels)
  w: number;  // Width of collision rect (pixels)
  h: number;  // Height of collision rect (pixels)
}

// In TileInfo:
export interface TileInfo {
  solid: boolean;
  destructible: boolean;
  tileId: number;
  collisionRect: CollisionRect;
}

// Constructor addition:
constructor(
  wallLayerData: number[],
  mapWidth: number,
  mapHeight: number,
  tileSize: number,
  destructibleTileIds: Set<number>,
  indestructibleTileIds: Set<number>,
  collisionShapes?: Record<string, CollisionRect>,  // NEW optional param
) {
  // ... existing code ...
  const shapes = collisionShapes || {};
  const fullTile: CollisionRect = { x: 0, y: 0, w: tileSize, h: tileSize };

  // In the grid construction loop:
  this.grid[row][col] = {
    solid: isDestructible || isIndestructible,
    destructible: isDestructible,
    tileId,
    collisionRect: shapes[String(tileId)] || fullTile,
  };
}
```

### Modified resolveCollisions (X-axis excerpt)
```typescript
// Current: entity AABB vs full tile
// New: entity AABB vs sub-rect within tile

for (let ty = tileTop; ty <= tileBottom; ty++) {
  for (let tx = tileLeft; tx <= tileRight; tx++) {
    if (grid.isSolid(tx, ty)) {
      const info = grid.getTileInfo(tx, ty);
      const rect = info?.collisionRect || { x: 0, y: 0, w: tileSize, h: tileSize };

      // Sub-rect world bounds
      const rectWorldLeft = tx * tileSize + rect.x;
      const rectWorldRight = tx * tileSize + rect.x + rect.w;
      const rectWorldTop = ty * tileSize + rect.y;
      const rectWorldBottom = ty * tileSize + rect.y + rect.h;

      // Narrow phase: entity AABB vs sub-rect AABB
      const entityLeft = entity.x - radius;
      const entityRight = entity.x + radius;
      const entityTop = prevY - radius;   // X-pass uses prevY
      const entityBottom = prevY + radius;

      if (entityRight > rectWorldLeft && entityLeft < rectWorldRight &&
          entityBottom > rectWorldTop && entityTop < rectWorldBottom) {
        hitX = true;
        hitTiles.push({ tileX: tx, tileY: ty });

        if (entity.x > prevX) {
          entity.x = rectWorldLeft - radius - COLLISION_EPSILON;
        } else if (entity.x < prevX) {
          entity.x = rectWorldRight + radius;
        }
      }
    }
  }
}
```

### Projectile Point-in-SubRect Check
```typescript
// New method on CollisionGrid:
isPointInSolidRect(worldX: number, worldY: number): boolean {
  const tileX = Math.floor(worldX / this.tileSize);
  const tileY = Math.floor(worldY / this.tileSize);

  if (tileX < 0 || tileX >= this.width || tileY < 0 || tileY >= this.height) {
    return true;  // OOB = solid
  }

  const info = this.grid[tileY][tileX];
  if (!info.solid) return false;

  const rect = info.collisionRect;
  const localX = worldX - tileX * this.tileSize;
  const localY = worldY - tileY * this.tileSize;

  return localX >= rect.x && localX < rect.x + rect.w &&
         localY >= rect.y && localY < rect.y + rect.h;
}
```

### Debug Visualization
```typescript
private drawDebugCollisionRects(): void {
  if (!this.debugCollisionOverlay || !this.collisionGrid) return;

  const g = this.debugCollisionOverlay;
  const grid = this.collisionGrid;
  const ts = grid.tileSize;

  for (let ty = 0; ty < grid.height; ty++) {
    for (let tx = 0; tx < grid.width; tx++) {
      const info = grid.getTileInfo(tx, ty);
      if (!info || !info.solid) continue;

      const rect = info.collisionRect;
      const worldX = tx * ts + rect.x;
      const worldY = ty * ts + rect.y;

      // Color by type
      let color = 0xff0000;  // indestructible walls
      if (info.destructible) {
        if (info.tileId === 101) color = 0xff8800;  // heavy
        else if (info.tileId === 102) color = 0xffff00;  // medium
        else color = 0x00ff00;  // light
      }

      g.lineStyle(1, color, 0.6);
      g.fillStyle(color, 0.15);
      g.fillRect(worldX, worldY, rect.w, rect.h);
      g.strokeRect(worldX, worldY, rect.w, rect.h);
    }
  }
}
```

## Codebase-Specific Integration Points

### Server-Side: GameRoom.loadMap()
**File:** `server/src/rooms/GameRoom.ts` (lines 85-122)
**Current:** Reads map JSON, extracts wall layer data, builds CollisionGrid with tile IDs and destructible/indestructible sets.
**Change:** Also extract `collisionShapes` from `mapJson.tilesets[0].properties.collisionShapes` and pass to CollisionGrid constructor.
```typescript
const collisionShapes = mapJson.tilesets[0]?.properties?.collisionShapes || {};
this.collisionGrid = new CollisionGrid(
  wallLayer.data, mapJson.width, mapJson.height, mapJson.tilewidth,
  OBSTACLE_TILE_IDS.destructible, OBSTACLE_TILE_IDS.indestructible,
  collisionShapes,  // NEW
);
```

### Client-Side: GameScene.createTilemap()
**File:** `client/src/scenes/GameScene.ts` (lines 1810-1902)
**Current:** Reads cached map data, extracts wall layer, builds CollisionGrid.
**Change:** Also extract collisionShapes and pass to CollisionGrid constructor.
```typescript
const collisionShapes = mapData.data.tilesets[0]?.properties?.collisionShapes || {};
this.collisionGrid = new CollisionGrid(
  wallLayerData.data, mapData.data.width, mapData.data.height,
  mapData.data.tilewidth,
  OBSTACLE_TILE_IDS.destructible, OBSTACLE_TILE_IDS.indestructible,
  collisionShapes,  // NEW
);
```

### Shared: resolveCollisions()
**File:** `shared/collisionGrid.ts` (lines 123-198)
**Current:** Full-tile AABB collision. Checks `grid.isSolid(tx, ty)` and pushes to tile edges.
**Change:** After `isSolid` check, fetch tile info to get sub-rect. Perform narrow-phase overlap test against sub-rect world bounds. Push to sub-rect edges instead of tile edges.

### Projectile Collision: GameRoom.fixedTick()
**File:** `server/src/rooms/GameRoom.ts` (lines 627-641)
**Current:** `const projTile = this.collisionGrid.worldToTile(proj.x, proj.y); if (this.collisionGrid.isSolid(projTile.tileX, projTile.tileY))`
**Change:** Replace with `if (this.collisionGrid.isPointInSolidRect(proj.x, proj.y))`

### Spawn Validation: GameRoom.setSpawnPosition()
**File:** `server/src/rooms/GameRoom.ts` (lines 269-345)
**Current:** Checks `isSolid()` for tiles in player AABB area.
**Change:** Should also use sub-rect checks, but since spawn points are in open areas with 1+ tile buffer, the impact is minimal. Can be deferred to a follow-up if needed, or updated alongside the main collision changes for consistency.

### Pipeline: generate-arenas.py
**File:** `scripts/generate-arenas.py` (lines 632-731)
**Current:** Generates map JSON with 3 layers and tileset metadata.
**Change:** After generating the map JSON, read per-tileset collision rect JSON and embed it into `tilesets[0].properties.collisionShapes`. This keeps the generation pipeline as the single source of truth for map data.

## Analysis of Existing Tileset Art

After examining the 3 composite tilesets (hedge, brick, wood), here are observations relevant to collision rect derivation:

### Wall Canopy Tiles (IDs 1-48)
These auto-tiled sprites have varying transparency at edges. Key observations:
- **Corner tiles** (e.g., top-left, bottom-right): Significant transparent areas on 2 sides. The collision rect will be notably smaller than 32x32 on those sides.
- **Edge tiles** (e.g., top edge, left edge): Transparent on 1 side. The collision rect will be smaller on that side.
- **Interior tiles** (e.g., fully surrounded): Nearly fill the entire 32x32 area. Collision rect will be close to full-tile.
- **End caps** (north/south/east/west terminations): Transparent on 3 sides. Small collision rect.
- **Straight segments** (horizontal/vertical): Transparent on 2 parallel sides.

The hedge tileset has the most organic (irregular) shapes, while brick has more rectangular fills, and wood is in between. This means:
- **Hedge**: Most benefit from sub-tile collision (biggest visual gaps from current full-tile collision)
- **Brick**: Moderate benefit (relatively rectangular art)
- **Wood**: Moderate benefit

### Obstacle Canopy Tiles (IDs 101-103)
These use the isolated_single sprite (index 0) canopy with varying opacity. Since they're derived from the same base sprite shape, all 3 tiers will have identical collision rects. They are likely to be close to full-tile since the isolated sprite fills most of the 32x32 area.

### Tiles Likely Needing Manual Overrides
Based on visual inspection:
- **Tiles with single-pixel stray artifacts:** Some auto-tiled wall sprites may have single opaque pixels at tile edges from the upscaling process. These would expand the bounding box unnecessarily. Manual override to trim 1-2px may be needed.
- **End cap tiles (IDs corresponding to sprites 0, 1, 7, 23, 31):** These have the smallest visual footprint but the auto-derived rect may include trailing decorative elements that shouldn't block collision.

The exact tiles needing overrides will be determined after running the auto-derivation script and reviewing the results with the debug visualization. The override mechanism allows selective correction without re-running the full pipeline.

## Open Questions

1. **How many tiles actually have significantly different sub-rects vs full-tile?**
   - What we know: Corner tiles and end caps clearly have transparency. Interior tiles likely fill 90%+ of the tile.
   - What's unclear: The exact percentages and how many tiles have "interesting" (non-trivial) sub-rects.
   - Recommendation: Run the derivation script first, output a summary report showing which tiles have rects significantly different from full-tile. This informs whether the change is worth the complexity.

2. **Should the `clearTile()` method also clear the collision rect?**
   - What we know: `clearTile()` is called when a destructible obstacle is destroyed, setting solid=false.
   - What's unclear: Whether the collision rect needs to be explicitly cleared, or if the solid=false check is sufficient (resolveCollisions only checks sub-rects for solid tiles).
   - Recommendation: Keep the current pattern -- `clearTile()` sets solid=false, and collision resolution already checks `isSolid()` before accessing the rect. No change needed.

3. **Performance impact of the additional narrow-phase check?**
   - What we know: The resolveCollisions function runs 60 times per second per player (3 players = 180 calls/sec on server, plus client prediction). The extra sub-rect overlap check is 4 comparisons per solid tile encountered.
   - What's unclear: Whether the extra comparisons are measurable.
   - Recommendation: The overhead is negligible (4 comparisons vs the existing loop overhead). No optimization needed. The locked decision to use a uniform code path (no fast-path for full-tile rects) simplifies the implementation without meaningful performance cost.

## Sources

### Primary (HIGH confidence)
- Codebase analysis: `shared/collisionGrid.ts` -- existing AABB collision system, directly inspected
- Codebase analysis: `server/src/rooms/GameRoom.ts` -- server-side collision integration, directly inspected
- Codebase analysis: `client/src/scenes/GameScene.ts` -- client-side collision grid construction, directly inspected
- Codebase analysis: `client/src/systems/Prediction.ts` -- client prediction collision usage, directly inspected
- Codebase analysis: `shared/obstacles.ts` -- tile ID definitions, directly inspected
- Codebase analysis: `shared/characters.ts` -- playerRadius (12px), projectileRadius (4px), directly inspected
- Codebase analysis: `scripts/generate-arenas.py` -- map JSON generation pipeline, directly inspected
- Codebase analysis: `assets/tilesets/walls/tileset_reference.json` -- auto-tile sprite layout, directly inspected
- Visual inspection: `client/public/tilesets/arena_hedge.png`, `arena_brick.png`, `arena_wood.png` -- tileset art

### Secondary (MEDIUM confidence)
- PIL/Pillow `getbbox()` documentation -- returns bounding box of non-zero pixels. Behavior verified by being standard PIL API used throughout the project's existing Python scripts.

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH -- all tools and libraries already in the project, no new dependencies
- Architecture: HIGH -- the collision system is well-understood from direct code analysis; the sub-rect extension is a natural evolution of the existing pattern
- Pitfalls: HIGH -- identified from direct analysis of the code paths and their interactions; all critical code has been read

**Research date:** 2026-02-16
**Valid until:** Indefinite (this is project-specific architecture, not dependent on external library versions)
