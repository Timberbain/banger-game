---
phase: 09.1-tilemap-collision-masks
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - shared/collisionGrid.ts
autonomous: true
requirements:
  - COLL-MASK-03
  - COLL-MASK-04

must_haves:
  truths:
    - "CollisionGrid stores a per-tile CollisionRect for every solid tile"
    - "resolveCollisions pushes entities to sub-rect edges (not full tile edges)"
    - "Projectile point-in-tile checks use isPointInSolidRect for sub-rect precision"
    - "Out-of-bounds tiles use full-tile collision rect as fallback"
    - "The new collisionShapes parameter is optional so existing code compiles without changes"
  artifacts:
    - path: "shared/collisionGrid.ts"
      provides: "Sub-rect AABB collision resolution and point-in-subrect check"
      exports: ["CollisionRect", "CollisionGrid", "resolveCollisions"]
      min_lines: 180
  key_links:
    - from: "shared/collisionGrid.ts"
      to: "server/src/rooms/GameRoom.ts"
      via: "CollisionGrid constructor with optional collisionShapes parameter"
      pattern: "new CollisionGrid"
    - from: "shared/collisionGrid.ts"
      to: "client/src/scenes/GameScene.ts"
      via: "CollisionGrid constructor with optional collisionShapes parameter"
      pattern: "new CollisionGrid"
---

<objective>
Modify the shared CollisionGrid to support per-tile sub-rectangle collision shapes. Add a CollisionRect interface, extend TileInfo to include it, modify the constructor to accept collision shape data, update resolveCollisions to use sub-rect narrow-phase checks and push to sub-rect edges, and add isPointInSolidRect for projectile collision.

Purpose: This is the core algorithm change that makes collision boundaries match visual tile art. The data pipeline (Plan 01) produces the collision shapes, and this plan makes the collision system consume them.

Output: Modified `shared/collisionGrid.ts` with backward-compatible sub-rect collision support.
</objective>

<execution_context>
@/Users/jonasbrandvik/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jonasbrandvik/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09.1-tilemap-collision-masks-for-precise-wall-obstacle-collisions/09.1-RESEARCH.md
@shared/collisionGrid.ts
@shared/obstacles.ts
@shared/characters.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend CollisionGrid with CollisionRect and sub-rect resolution</name>
  <files>shared/collisionGrid.ts</files>
  <action>
Modify `shared/collisionGrid.ts` with all sub-rect collision changes in a single pass. The file is 198 lines, so all changes fit in one task.

**1. Add CollisionRect interface (after COLLISION_EPSILON):**
```typescript
/** Sub-tile collision rectangle: defines the collision-active region within a 32x32 tile */
export interface CollisionRect {
  x: number;  // Horizontal offset within tile (pixels, 0-31)
  y: number;  // Vertical offset within tile (pixels, 0-31)
  w: number;  // Width of collision rect (pixels, 1-32)
  h: number;  // Height of collision rect (pixels, 1-32)
}
```

**2. Extend TileInfo interface:**
Add `collisionRect: CollisionRect` to TileInfo. This field stores the per-tile sub-rectangle.

**3. Modify CollisionGrid constructor:**
- Add optional parameter: `collisionShapes?: Record<string, { x: number; y: number; w: number; h: number }>`
- Define a full-tile default: `const fullTile: CollisionRect = { x: 0, y: 0, w: tileSize, h: tileSize };`
- In the grid construction loop, set `collisionRect` on each TileInfo:
  - If the tile is solid AND has a shapes entry: use `shapes[String(tileId)]`
  - If the tile is solid but no shapes entry: use `fullTile`
  - If the tile is not solid: use `fullTile` (value doesn't matter since solid=false skips collision)

**4. Update clearTile:**
The existing clearTile sets `solid: false, destructible: false, tileId: 0`. Add `collisionRect: { x: 0, y: 0, w: tileSize, h: tileSize }` to the reset object. Use `this.tileSize` for the width/height values.

**5. Add isPointInSolidRect method:**
```typescript
/** Returns true if a world-space point falls inside a solid tile's collision sub-rect */
isPointInSolidRect(worldX: number, worldY: number): boolean {
  const tileX = Math.floor(worldX / this.tileSize);
  const tileY = Math.floor(worldY / this.tileSize);

  // Out of bounds = solid (full tile, point is always "inside")
  if (tileX < 0 || tileX >= this.width || tileY < 0 || tileY >= this.height) {
    return true;
  }

  const info = this.grid[tileY][tileX];
  if (!info.solid) return false;

  const rect = info.collisionRect;
  const localX = worldX - tileX * this.tileSize;
  const localY = worldY - tileY * this.tileSize;

  return localX >= rect.x && localX < rect.x + rect.w &&
         localY >= rect.y && localY < rect.y + rect.h;
}
```

**6. Modify resolveCollisions -- X axis:**
Replace the inner collision check block. After `if (grid.isSolid(tx, ty))`, add narrow-phase sub-rect check:

```typescript
if (grid.isSolid(tx, ty)) {
  // Get sub-rect collision bounds (OOB tiles get full-tile rect)
  const info = grid.getTileInfo(tx, ty);
  const rect = info?.collisionRect || { x: 0, y: 0, w: tileSize, h: tileSize };

  // Sub-rect world bounds
  const rectLeft = tx * tileSize + rect.x;
  const rectRight = tx * tileSize + rect.x + rect.w;
  const rectTop = ty * tileSize + rect.y;
  const rectBottom = ty * tileSize + rect.y + rect.h;

  // Narrow phase: entity AABB vs sub-rect AABB
  // For X pass, use prevY for vertical extent (axis separation)
  const eLeft = entity.x - radius;
  const eRight = entity.x + radius;
  const eTop = prevY - radius;
  const eBottom = prevY + radius;

  if (eRight > rectLeft && eLeft < rectRight &&
      eBottom > rectTop && eTop < rectBottom) {
    hitX = true;
    hitTiles.push({ tileX: tx, tileY: ty });

    if (entity.x > prevX) {
      entity.x = rectLeft - radius - COLLISION_EPSILON;
    } else if (entity.x < prevX) {
      entity.x = rectRight + radius;
    }
  }
}
```

**7. Modify resolveCollisions -- Y axis:**
Same pattern as X axis but for Y:

```typescript
if (grid.isSolid(tx, ty)) {
  const info = grid.getTileInfo(tx, ty);
  const rect = info?.collisionRect || { x: 0, y: 0, w: tileSize, h: tileSize };

  const rectLeft = tx * tileSize + rect.x;
  const rectRight = tx * tileSize + rect.x + rect.w;
  const rectTop = ty * tileSize + rect.y;
  const rectBottom = ty * tileSize + rect.y + rect.h;

  // For Y pass, use resolved entity.x for horizontal extent
  const eLeft = entity.x - radius;
  const eRight = entity.x + radius;
  const eTop = entity.y - radius;
  const eBottom = entity.y + radius;

  if (eRight > rectLeft && eLeft < rectRight &&
      eBottom > rectTop && eTop < rectBottom) {
    hitY = true;
    hitTiles.push({ tileX: tx, tileY: ty });

    if (entity.y > prevY) {
      entity.y = rectTop - radius - COLLISION_EPSILON;
    } else if (entity.y < prevY) {
      entity.y = rectBottom + radius;
    }
  }
}
```

**CRITICAL: Broad phase remains unchanged.** The tile scanning range (tileLeft/tileRight/tileTop/tileBottom computed from entity AABB) stays the same. Only the per-tile overlap test and push-out positions change.

**CRITICAL: Backward compatibility.** The `collisionShapes` constructor parameter is optional with no default required in the type signature (use `?`). Existing call sites pass 6 args; they will work unchanged, and all tiles will get full-tile collision rects (identical to current behavior) until collision shape data is passed.
  </action>
  <verify>
1. Verify TypeScript compiles for both server and client:
   - `cd /Users/jonasbrandvik/Projects/banger-game/server && npx tsc --noEmit`
   - `cd /Users/jonasbrandvik/Projects/banger-game/client && npx tsc --noEmit`

2. Verify the file exports CollisionRect interface: `grep "export interface CollisionRect" shared/collisionGrid.ts`

3. Verify isPointInSolidRect method exists: `grep "isPointInSolidRect" shared/collisionGrid.ts`

4. Verify the constructor accepts optional collisionShapes: `grep "collisionShapes" shared/collisionGrid.ts`

5. Verify TileInfo includes collisionRect: `grep "collisionRect" shared/collisionGrid.ts`
  </verify>
  <done>
`shared/collisionGrid.ts` has CollisionRect interface, extended TileInfo, optional collisionShapes constructor parameter, sub-rect narrow-phase in resolveCollisions (both axes), and isPointInSolidRect method. Both server and client compile without changes to their call sites (backward compatible with full-tile fallback).
  </done>
</task>

</tasks>

<verification>
1. `collisionGrid.ts` exports CollisionRect, has isPointInSolidRect, resolveCollisions uses sub-rect bounds
2. Server compiles: `cd server && npx tsc --noEmit` (zero errors)
3. Client compiles: `cd client && npx tsc --noEmit` (zero errors)
4. No changes needed to server/client call sites (optional parameter default provides full-tile behavior)
</verification>

<success_criteria>
- CollisionGrid constructor accepts optional collision shapes and stores per-tile CollisionRect
- resolveCollisions pushes entities to sub-rect edges for all solid tiles
- isPointInSolidRect returns true only when world point falls within a solid tile's sub-rect
- Both server and client compile without modification to their existing CollisionGrid usage
</success_criteria>

<output>
After completion, create `.planning/phases/09.1-tilemap-collision-masks-for-precise-wall-obstacle-collisions/09.1-02-SUMMARY.md`
</output>
