---
phase: 09.1-tilemap-collision-masks
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - scripts/generate-collision-masks.py
  - scripts/generate-arenas.py
  - client/public/maps/hedge_garden.json
  - client/public/maps/brick_fortress.json
  - client/public/maps/timber_yard.json
autonomous: true
requirements:
  - COLL-MASK-01
  - COLL-MASK-02

must_haves:
  truths:
    - "Each map JSON contains per-tile collision rectangles derived from the actual tileset pixel art"
    - "Collision rects represent the tightest opaque pixel bounding box within each 32x32 tile"
    - "All 3 tilesets (hedge, brick, wood) have independently derived collision shapes"
  artifacts:
    - path: "scripts/generate-collision-masks.py"
      provides: "Auto-derivation of collision rects from tileset PNGs"
      min_lines: 60
    - path: "client/public/maps/hedge_garden.json"
      provides: "Map with embedded collisionShapes"
      contains: "collisionShapes"
    - path: "client/public/maps/brick_fortress.json"
      provides: "Map with embedded collisionShapes"
      contains: "collisionShapes"
    - path: "client/public/maps/timber_yard.json"
      provides: "Map with embedded collisionShapes"
      contains: "collisionShapes"
  key_links:
    - from: "scripts/generate-collision-masks.py"
      to: "assets/tilesets/walls/*.png"
      via: "PIL alpha channel bounding box scan"
      pattern: "getbbox"
    - from: "scripts/generate-arenas.py"
      to: "client/public/maps/*.json"
      via: "Embeds collision shapes from JSON sidecar into map JSON tileset properties"
      pattern: "collisionShapes"
---

<objective>
Create the collision shape derivation pipeline: a Python script that scans each 32x32 tile in the 3 composite tilesets (256x448, 8 cols x 14 rows) to compute the tightest opaque pixel bounding box per tile, outputs per-tileset JSON sidecar files, and modifies generate-arenas.py to embed that data into map JSON metadata.

Purpose: Provide the collision shape data that the CollisionGrid (Plan 02) and server/client integration (Plan 03) will consume. Without this data, the sub-rect collision system has nothing to work with.

Output: `scripts/generate-collision-masks.py` (new), modified `scripts/generate-arenas.py`, regenerated map JSONs with collision data.
</objective>

<execution_context>
@/Users/jonasbrandvik/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jonasbrandvik/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09.1-tilemap-collision-masks-for-precise-wall-obstacle-collisions/09.1-RESEARCH.md
@scripts/generate-arenas.py
@shared/obstacles.ts
@assets/tilesets/walls/tileset_reference.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create generate-collision-masks.py script</name>
  <files>scripts/generate-collision-masks.py</files>
  <action>
Create `scripts/generate-collision-masks.py` that scans the 3 composite tileset PNGs and outputs collision rect JSON sidecar files.

**Tileset structure:** Each composite tileset is 256x448 pixels = 8 columns x 14 rows of 32x32 tiles. Tile IDs 1-112 (firstgid=1).

**Algorithm per tile:**
1. Extract the 32x32 tile region from the composite PNG
2. Isolate the alpha channel via `img.split()[3]` (critical: do NOT use `getbbox()` on full RGBA -- it would include color channel nonzero values)
3. Call `alpha.getbbox()` which returns `(left, upper, right, lower)` or `None` if fully transparent
4. If bbox exists, output `{x: left, y: upper, w: right - left, h: lower - upper}` keyed by string tile ID
5. If bbox is None (fully transparent), skip the tile (not solid, no collision shape needed)

**Input paths:**
- `client/public/tilesets/arena_hedge.png`
- `client/public/tilesets/arena_brick.png`
- `client/public/tilesets/arena_wood.png`

**Output paths:** JSON sidecar files alongside each tileset:
- `client/public/tilesets/arena_hedge_collision.json`
- `client/public/tilesets/arena_brick_collision.json`
- `client/public/tilesets/arena_wood_collision.json`

**JSON format:**
```json
{
  "1": {"x": 4, "y": 2, "w": 24, "h": 28},
  "2": {"x": 0, "y": 2, "w": 30, "h": 28},
  "_default": {"x": 0, "y": 0, "w": 32, "h": 32}
}
```

Always include a `_default` entry of full-tile `{x:0, y:0, w:32, h:32}` as fallback.

**Manual override mechanism:** After computing auto-derived rects, check for a `MANUAL_OVERRIDES` dict at the top of the script. If a tile ID is present in overrides, use the override rect instead. Start with an empty overrides dict -- specific overrides will be determined after visual inspection.

**Summary report:** Print to stdout a summary of how many tiles have sub-rects smaller than full-tile, and the average coverage percentage. This helps determine if the change is worthwhile.

**Important:** Only scan tiles with opaque pixels. The alpha threshold is > 0 (matching PIL getbbox behavior). Obstacle tiles (IDs 101-103) have reduced opacity via apply_opacity (0.8, 0.6) but should still be detected correctly since alpha > 0.
  </action>
  <verify>
Run: `cd /Users/jonasbrandvik/Projects/banger-game && python3 scripts/generate-collision-masks.py`

Verify:
- Script runs without errors
- 3 JSON sidecar files created in `client/public/tilesets/`
- Each JSON has string-keyed tile IDs with {x, y, w, h} objects
- Each JSON has a `_default` entry
- Summary output shows tile coverage stats
  </verify>
  <done>
Three collision rect JSON sidecar files exist with per-tile bounding boxes derived from actual tileset pixel art. A `_default` fallback entry is present in each. Manual override mechanism is in place (empty for now).
  </done>
</task>

<task type="auto">
  <name>Task 2: Embed collision shapes in map JSONs via generate-arenas.py</name>
  <files>scripts/generate-arenas.py, client/public/maps/hedge_garden.json, client/public/maps/brick_fortress.json, client/public/maps/timber_yard.json</files>
  <action>
Modify `scripts/generate-arenas.py` to load the collision rect JSON sidecar files (generated by Task 1) and embed them into each map's JSON `tilesets[0].properties.collisionShapes` field.

**Changes to `generate_map_json()`:**

1. Add a new parameter `collision_data_path` (optional, defaults to None).
2. After building `map_json`, if `collision_data_path` is provided and the file exists:
   - Load the collision JSON sidecar
   - Add a `"properties"` key to `tilesets[0]` containing `{"collisionShapes": <loaded data>}`
3. If the collision file doesn't exist, print a warning but continue (so the script doesn't break if collision masks haven't been generated yet).

**Changes to main block:**

1. After the existing steps, add collision data embedding for each map:
   - hedge_garden -> arena_hedge_collision.json
   - brick_fortress -> arena_brick_collision.json
   - timber_yard -> arena_wood_collision.json

2. The collision file paths are:
   - `os.path.join(TILESETS_DIR, "arena_hedge_collision.json")`
   - `os.path.join(TILESETS_DIR, "arena_brick_collision.json")`
   - `os.path.join(TILESETS_DIR, "arena_wood_collision.json")`

**Implementation approach:** Rather than modifying generate_map_json's signature (which is called in 3 places), add a separate step after map generation that reads each map JSON, injects collision data, and writes it back. This keeps the main generation logic clean.

Add after the spawn validation in the main block:
```python
print()
print("  --- Embedding collision shapes ---")
collision_map = {
    "hedge_garden": "arena_hedge_collision.json",
    "brick_fortress": "arena_brick_collision.json",
    "timber_yard": "arena_wood_collision.json",
}
for map_name, coll_file in collision_map.items():
    coll_path = os.path.join(TILESETS_DIR, coll_file)
    map_path = os.path.join(MAPS_DIR, f"{map_name}.json")
    if os.path.exists(coll_path):
        with open(coll_path) as f:
            coll_data = json.load(f)
        with open(map_path) as f:
            map_json = json.load(f)
        if "properties" not in map_json["tilesets"][0]:
            map_json["tilesets"][0]["properties"] = {}
        map_json["tilesets"][0]["properties"]["collisionShapes"] = coll_data
        with open(map_path, "w") as f:
            json.dump(map_json, f, indent=2)
        print(f"  {map_name}: embedded {len(coll_data)} collision shapes")
    else:
        print(f"  {map_name}: collision file not found ({coll_file}), skipping")
```

After modifying, run the full pipeline:
1. `python3 scripts/generate-collision-masks.py` (generates sidecar JSONs)
2. `python3 scripts/generate-arenas.py` (regenerates maps + embeds collision data)
  </action>
  <verify>
Run: `cd /Users/jonasbrandvik/Projects/banger-game && python3 scripts/generate-arenas.py`

Verify:
- Script runs successfully with "Embedding collision shapes" output
- Each map JSON (hedge_garden.json, brick_fortress.json, timber_yard.json) contains `tilesets[0].properties.collisionShapes`
- Collision shapes are keyed by string tile IDs with {x, y, w, h} values
- Map JSON remains valid (valid JSON, layers intact, spawn data intact)
- Run `python3 -c "import json; d=json.load(open('client/public/maps/hedge_garden.json')); print(len(d['tilesets'][0]['properties']['collisionShapes']), 'shapes')"` to verify shape count
  </verify>
  <done>
All 3 map JSONs contain embedded collisionShapes in tilesets[0].properties. The full pipeline (generate-collision-masks.py then generate-arenas.py) produces maps with per-tile collision rectangles ready for runtime consumption by server and client.
  </done>
</task>

</tasks>

<verification>
1. `python3 scripts/generate-collision-masks.py` runs clean, outputs 3 JSON files
2. `python3 scripts/generate-arenas.py` runs clean, embeds collision data in 3 map JSONs
3. Each map JSON has `tilesets[0].properties.collisionShapes` with tile ID keys and {x,y,w,h} values
4. No existing map functionality is broken (layers, spawn validation, connectivity check all pass)
</verification>

<success_criteria>
- 3 collision sidecar JSON files exist in client/public/tilesets/
- 3 map JSONs contain embedded collisionShapes metadata
- Pipeline is repeatable: running both scripts in sequence reproduces identical output
- Manual override mechanism exists for future tile-specific corrections
</success_criteria>

<output>
After completion, create `.planning/phases/09.1-tilemap-collision-masks-for-precise-wall-obstacle-collisions/09.1-01-SUMMARY.md`
</output>
