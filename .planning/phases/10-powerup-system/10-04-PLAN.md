---
phase: 10-powerup-system
plan: 04
type: execute
wave: 3
depends_on: ["10-02", "10-03"]
files_modified:
  - client/src/scenes/GameScene.ts
  - client/src/scenes/HUDScene.ts
autonomous: true

must_haves:
  truths:
    - "Powerup items on the ground render as potion bottle sprites with bobbing animation"
    - "Despawning powerups flash/blink for the last 4 seconds before disappearing"
    - "Collecting a powerup shows pickup feedback: SFX chime + floating text"
    - "Buffed players display distinct particle aura per powerup type visible to all players"
    - "Paran's Beam projectile renders as a large glowing beam visual (5x size, additive glow)"
    - "HUD shows active powerup indicators below health bar with shrinking duration bars"
    - "Kill feed announces powerup spawns and collections"
    - "All powerup visuals are cleaned up during stage transitions"
  artifacts:
    - path: "client/src/scenes/GameScene.ts"
      provides: "Powerup sprite management, aura emitter tracking, beam rendering, stage cleanup, broadcast listeners"
      contains: "powerupSprites"
    - path: "client/src/scenes/HUDScene.ts"
      provides: "Buff duration indicator bars, kill feed powerup messages, broadcast listeners"
      contains: "buffIndicators"
  key_links:
    - from: "client/src/scenes/GameScene.ts"
      to: "server/src/rooms/GameRoom.ts"
      via: "room.state.powerups.onAdd/onRemove + room.onMessage broadcasts"
      pattern: "powerups\\.onAdd"
    - from: "client/src/scenes/HUDScene.ts"
      to: "server/src/rooms/GameRoom.ts"
      via: "room.onMessage for powerupCollect/buffExpired"
      pattern: "onMessage.*powerupCollect"
    - from: "client/src/scenes/GameScene.ts"
      to: "client/src/systems/ParticleFactory.ts"
      via: "speedAura/invincibilityAura/projectileAura methods"
      pattern: "particleFactory\\.speedAura"
---

<objective>
Integrate all client-side powerup rendering: ground item sprites, player buff auras, beam projectile visuals, HUD buff indicators, kill feed messages, SFX feedback, and stage transition cleanup.

Purpose: Make the powerup system visible and satisfying to players. After this plan, players see powerups spawn (with bobbing animation), collect them (with chime and floating text), see buff auras on themselves and opponents, witness devastating beam projectiles, and track buff durations in the HUD. Everything cleans up properly between stages.

Output: Modified `GameScene.ts` with complete powerup visual integration and `HUDScene.ts` with buff indicators and kill feed messages.
</objective>

<execution_context>
@/Users/jonasbrandvik/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jonasbrandvik/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/10-powerup-system/10-RESEARCH.md
@.planning/phases/10-powerup-system/10-01-SUMMARY.md
@.planning/phases/10-powerup-system/10-02-SUMMARY.md
@.planning/phases/10-powerup-system/10-03-SUMMARY.md
@client/src/scenes/GameScene.ts
@client/src/scenes/HUDScene.ts
@client/src/ui/designTokens.ts
@shared/powerups.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: GameScene powerup sprite rendering, aura management, beam visuals, and stage cleanup</name>
  <files>
    client/src/scenes/GameScene.ts
  </files>
  <action>
**Add imports:**
- Import `PowerupType, POWERUP_CONFIG, POWERUP_NAMES` from `../../../shared/powerups`

**Add member variables** (reset in `create()`):
```typescript
// Powerup rendering
private powerupSprites: Map<string, Phaser.GameObjects.Sprite> = new Map();
private powerupTweens: Map<string, Phaser.Tweens.Tween> = new Map();
// Buff aura emitters: Map<sessionId, Map<buffType, ParticleEmitter>>
private buffAuras: Map<string, Map<number, Phaser.GameObjects.Particles.ParticleEmitter>> = new Map();
```

**Map powerup type to texture key:**
```typescript
const POWERUP_TEXTURE: Record<number, string> = {
  [PowerupType.SPEED]: 'potion_speed',
  [PowerupType.INVINCIBILITY]: 'potion_invincibility',
  [PowerupType.PROJECTILE]: 'potion_projectile',
};
```

**1. Register Schema listeners for powerups:**

In the method where room state listeners are set up (look for `this.room.state.obstacles.onAdd` as a pattern), add similar listeners for powerups:

```typescript
// Powerup state listeners
this.room.state.powerups.onAdd((powerup: any, key: string) => {
  const textureKey = POWERUP_TEXTURE[powerup.powerupType] || 'potion_speed';
  const sprite = this.add.sprite(powerup.x, powerup.y, textureKey);
  sprite.setDisplaySize(16, 16); // 16x16 pixel art
  sprite.setDepth(8); // Above ground, below players (10)
  this.powerupSprites.set(key, sprite);

  // Bobbing animation: oscillate y +/- 4px, 1000ms period
  const tween = this.tweens.add({
    targets: sprite,
    y: powerup.y - 4,
    duration: 500,
    yoyo: true,
    repeat: -1,
    ease: 'Sine.easeInOut',
  });
  this.powerupTweens.set(key, tween);

  // Play spawn SFX
  const audio = this.registry.get('audioManager');
  if (audio) audio.play('powerup_spawn');
});

this.room.state.powerups.onRemove((_powerup: any, key: string) => {
  const sprite = this.powerupSprites.get(key);
  if (sprite) {
    sprite.destroy();
    this.powerupSprites.delete(key);
  }
  const tween = this.powerupTweens.get(key);
  if (tween) {
    tween.destroy();
    this.powerupTweens.delete(key);
  }
});
```

**2. Despawn blink effect (client-side, based on spawnTime):**

In the `update()` loop, add a section to check powerup blink state:
```typescript
// Powerup despawn blink (client-side calculation)
if (this.room) {
  this.room.state.powerups.forEach((powerup: any, key: string) => {
    const sprite = this.powerupSprites.get(key);
    if (!sprite) return;
    const elapsed = this.room!.state.serverTime - powerup.spawnTime;
    const remaining = POWERUP_CONFIG.despawnTime - elapsed;
    if (remaining <= POWERUP_CONFIG.despawnWarningTime && remaining > 0) {
      // Blink: toggle visibility every 200ms
      const blinkPhase = Math.floor(elapsed / 200) % 2;
      sprite.setAlpha(blinkPhase === 0 ? 1 : 0.2);
    }
  });
}
```

**3. Broadcast listeners for collection feedback:**

Register in the room listener setup method:

```typescript
this.room.onMessage('powerupCollect', (data: any) => {
  // Play pickup SFX
  const audio = this.registry.get('audioManager');
  if (audio) audio.play('powerup_pickup');

  // Floating text at player position showing powerup name
  const playerSprite = this.playerSprites.get(data.playerId);
  if (playerSprite) {
    const floatText = this.add.text(
      playerSprite.x,
      playerSprite.y - 30,
      data.typeName,
      {
        fontSize: '12px',
        fontFamily: 'monospace',
        color: '#FFFFFF',
        stroke: '#000000',
        strokeThickness: 3,
        fontStyle: 'bold',
      }
    ).setOrigin(0.5).setDepth(25);

    this.tweens.add({
      targets: floatText,
      y: floatText.y - 30,
      alpha: 0,
      duration: 1200,
      ease: 'Cubic.easeOut',
      onComplete: () => floatText.destroy(),
    });
  }
});

this.room.onMessage('powerupDespawn', (_data: any) => {
  const audio = this.registry.get('audioManager');
  if (audio) audio.play('powerup_despawn');
});
```

**4. Buff aura management:**

Register listeners for buff applied/expired events:

```typescript
this.room.onMessage('powerupCollect', (data: any) => {
  // ... (pickup SFX and float text from above -- merge into same handler)

  // Start buff aura on the collecting player
  const sprite = this.playerSprites.get(data.playerId);
  if (sprite && this.particleFactory) {
    this.startBuffAura(data.playerId, data.type, sprite);
  }
});

this.room.onMessage('buffExpired', (data: any) => {
  this.stopBuffAura(data.playerId, data.type);
});
```

NOTE: Merge the `powerupCollect` handler into a single onMessage registration (not two separate ones). The SFX, float text, and aura start all go in the same handler.

**Add helper methods:**

```typescript
private startBuffAura(playerId: string, buffType: number, sprite: Phaser.GameObjects.Sprite): void {
  if (!this.particleFactory) return;

  // Get or create aura map for this player
  if (!this.buffAuras.has(playerId)) {
    this.buffAuras.set(playerId, new Map());
  }
  const playerAuras = this.buffAuras.get(playerId)!;

  // If aura already exists for this buff type, destroy old one first (timer refresh)
  const existing = playerAuras.get(buffType);
  if (existing) {
    this.particleFactory.destroyTrail(existing);
  }

  // Create new aura emitter
  let emitter: Phaser.GameObjects.Particles.ParticleEmitter;
  switch (buffType) {
    case PowerupType.SPEED:
      emitter = this.particleFactory.speedAura(sprite);
      break;
    case PowerupType.INVINCIBILITY:
      emitter = this.particleFactory.invincibilityAura(sprite);
      break;
    case PowerupType.PROJECTILE:
      emitter = this.particleFactory.projectileAura(sprite);
      break;
    default:
      return;
  }
  playerAuras.set(buffType, emitter);
}

private stopBuffAura(playerId: string, buffType: number): void {
  const playerAuras = this.buffAuras.get(playerId);
  if (!playerAuras) return;
  const emitter = playerAuras.get(buffType);
  if (emitter && this.particleFactory) {
    this.particleFactory.destroyTrail(emitter);
    playerAuras.delete(buffType);
  }
}

private clearAllBuffAuras(): void {
  this.buffAuras.forEach((playerAuras) => {
    playerAuras.forEach((emitter) => {
      if (this.particleFactory) {
        this.particleFactory.destroyTrail(emitter);
      } else {
        emitter.destroy();
      }
    });
    playerAuras.clear();
  });
  this.buffAuras.clear();
}
```

**5. Beam projectile rendering:**

In the existing projectile rendering section (where projectile sprites are created from Schema data), modify to handle beam projectiles:

When creating a projectile sprite, check if `proj.isBeam` is true:
```typescript
// Inside the projectile rendering/update code
if (proj.isBeam) {
  // Display at 5x size (40x40 from 16x16 base, or 5x the normal 8x8 display)
  projSprite.setDisplaySize(40, 40);
  // Add glow effect via alpha pulse tween
  if (!projSprite.getData('hasGlow')) {
    projSprite.setData('hasGlow', true);
    projSprite.setTint(0xFFDD00); // Gold-white beam color
    this.tweens.add({
      targets: projSprite,
      alpha: { from: 1.0, to: 0.6 },
      duration: 100,
      yoyo: true,
      repeat: -1,
    });
  }
} else if (proj.hitboxScale > 1) {
  // Guardian buffed projectile: display at 2x size
  const buffedSize = 8 * proj.hitboxScale;
  projSprite.setDisplaySize(buffedSize, buffedSize);
}
```

For beam projectile trails, use a larger, brighter trail:
```typescript
// When creating trail for beam projectile
if (proj.isBeam) {
  // Beam trail: larger, gold particles
  const beamTrail = this.scene.add.particles(0, 0, 'particle', {
    frequency: 20,
    lifespan: 300,
    speed: 0,
    scale: { start: 2.0, end: 0 },
    alpha: { start: 0.7, end: 0 },
    tint: 0xFFDD00,
    follow: projSprite,
    emitting: true,
  });
  beamTrail.setDepth(4);
  // Track in projectileTrails map for cleanup
}
```

**6. Stage transition cleanup:**

In `cleanupStageVisuals()`, add cleanup for powerup sprites, tweens, and auras:

```typescript
// In cleanupStageVisuals(), add:

// Destroy powerup sprites and tweens
this.powerupSprites.forEach((sprite) => sprite.destroy());
this.powerupSprites.clear();
this.powerupTweens.forEach((tween) => tween.destroy());
this.powerupTweens.clear();

// Destroy all buff auras
this.clearAllBuffAuras();
```

**7. Player death aura cleanup:**

In the existing player health change handler (where death is detected), clear that player's auras:
```typescript
// When player health reaches 0 (death detected)
this.clearPlayerAuras(playerId);
```

Add helper:
```typescript
private clearPlayerAuras(playerId: string): void {
  const playerAuras = this.buffAuras.get(playerId);
  if (!playerAuras) return;
  playerAuras.forEach((emitter) => {
    if (this.particleFactory) {
      this.particleFactory.destroyTrail(emitter);
    } else {
      emitter.destroy();
    }
  });
  playerAuras.delete(playerId);
  this.buffAuras.delete(playerId);
}
```

**8. Reset all powerup state in `create()`:**

Ensure all new Maps are reset (constructor skipped on scene.start reuse):
```typescript
this.powerupSprites = new Map();
this.powerupTweens = new Map();
this.buffAuras = new Map();
```

**9. Re-register powerup listeners on reconnection:**

In `attachRoomListeners()` (the reconnection listener re-registration method), include the powerup Schema listeners (onAdd/onRemove) and broadcast listeners (powerupCollect, powerupDespawn, buffExpired).
  </action>
  <verify>
Run `cd /Users/jonasbrandvik/Projects/banger-game/client && npx tsc --noEmit` to confirm compilation. Verify GameScene has: powerupSprites/powerupTweens/buffAuras maps, powerup onAdd/onRemove handlers, despawn blink in update loop, collection float text, aura start/stop helpers, beam rendering, cleanupStageVisuals additions, create() resets.
  </verify>
  <done>Powerup items render on the ground with bobbing animation and despawn blink. Collection shows SFX + floating text. Buff auras display on player sprites (blue/gold/red per type). Beam projectiles render as large glowing gold projectiles. All visuals clean up on stage transition and player death. Reconnection re-registers all listeners.</done>
</task>

<task type="auto">
  <name>Task 2: HUD buff indicators and kill feed powerup messages</name>
  <files>
    client/src/scenes/HUDScene.ts
  </files>
  <action>
**Add imports:**
- Import `PowerupType, POWERUP_CONFIG, POWERUP_NAMES, BUFF_DURATIONS` from `../../../shared/powerups`

**Add member variables** (reset in `create()`):
```typescript
// Buff indicators
private buffIndicators: Map<number, {
  bg: Phaser.GameObjects.Rectangle;
  fill: Phaser.GameObjects.Rectangle;
  icon: Phaser.GameObjects.Sprite;
  startTime: number;
  duration: number;
  flashTimer?: Phaser.Time.TimerEvent;
}> = new Map();
```

**1. Position buff indicators:**

Place buff indicators between the cooldown bar and health bars. Based on Layout tokens:
- Cooldown bar is at Y = 680 (Layout.hud.cooldown.y)
- Health bars are at Y = 695 (Layout.hud.healthBarY)
- Place buff indicators at Y = 660, centered horizontally at 640

Each indicator: 50px wide, 8px tall bar + 16x16 icon sprite above the bar.
Multiple indicators lay out side by side with 8px gap.

**2. Buff indicator creation (on powerupCollect broadcast):**

Register in the room message listener setup (same area as kill feed setup):

```typescript
this.room.onMessage('powerupCollect', (data: any) => {
  // Only show indicator for local player
  if (data.playerId === this.localSessionId) {
    this.addBuffIndicator(data.type, data.duration);
  }

  // Kill feed: announce collection
  this.addKillFeedEntry({
    killer: data.playerName,
    victim: `collected ${data.typeName}`,
    killerRole: data.playerRole,
    victimRole: '',
  });
});

this.room.onMessage('powerupSpawn', (data: any) => {
  // Kill feed: announce spawn
  this.addKillFeedEntry({
    killer: data.typeName,
    victim: 'appeared!',
    killerRole: '',
    victimRole: '',
  });
});

this.room.onMessage('buffExpired', (data: any) => {
  if (data.playerId === this.localSessionId) {
    this.removeBuffIndicator(data.type);
  }
});
```

**3. Implement `addBuffIndicator(type, duration)` method:**

```typescript
private addBuffIndicator(buffType: number, duration: number): void {
  // If indicator already exists for this type, refresh it (same type refresh = new timer)
  this.removeBuffIndicator(buffType);

  const indicatorWidth = 50;
  const indicatorHeight = 8;
  const iconSize = 16;
  const gap = 8;

  // Position: centered at screen middle, offset by active indicator count
  const activeCount = this.buffIndicators.size;
  const totalWidth = (activeCount + 1) * (indicatorWidth + gap) - gap;
  const startX = this.W / 2 - totalWidth / 2;

  // Reposition existing indicators and place new one
  const x = startX + activeCount * (indicatorWidth + gap);
  const y = 655; // Above cooldown bar

  // Background bar (dark)
  const bg = this.add.rectangle(x + indicatorWidth / 2, y, indicatorWidth, indicatorHeight, 0x222222, 0.8);
  bg.setOrigin(0.5, 0.5);
  bg.setDepth(100);

  // Fill bar (colored by type -- use buff-specific colors)
  const fillColor = buffType === PowerupType.SPEED ? 0x4488FF
    : buffType === PowerupType.INVINCIBILITY ? 0xFFCC00
    : 0xFF4422;
  const fill = this.add.rectangle(x + indicatorWidth / 2, y, indicatorWidth, indicatorHeight, fillColor, 0.9);
  fill.setOrigin(0.5, 0.5);
  fill.setDepth(101);

  // Icon sprite above bar
  const textureKey = buffType === PowerupType.SPEED ? 'potion_speed'
    : buffType === PowerupType.INVINCIBILITY ? 'potion_invincibility'
    : 'potion_projectile';
  const icon = this.add.sprite(x + indicatorWidth / 2, y - iconSize, textureKey);
  icon.setDisplaySize(iconSize, iconSize);
  icon.setDepth(101);

  this.buffIndicators.set(buffType, {
    bg, fill, icon,
    startTime: Date.now(),
    duration,
  });

  // Reposition all indicators centered
  this.repositionBuffIndicators();
}
```

**4. Implement `removeBuffIndicator(type)` method:**

```typescript
private removeBuffIndicator(buffType: number): void {
  const indicator = this.buffIndicators.get(buffType);
  if (!indicator) return;
  indicator.bg.destroy();
  indicator.fill.destroy();
  indicator.icon.destroy();
  if (indicator.flashTimer) indicator.flashTimer.destroy();
  this.buffIndicators.delete(buffType);
  this.repositionBuffIndicators();
}
```

**5. Implement `repositionBuffIndicators()` method:**

Recenter all active indicators when one is added/removed:
```typescript
private repositionBuffIndicators(): void {
  const indicatorWidth = 50;
  const gap = 8;
  const count = this.buffIndicators.size;
  if (count === 0) return;

  const totalWidth = count * (indicatorWidth + gap) - gap;
  const startX = this.W / 2 - totalWidth / 2;
  const y = 655;
  const iconSize = 16;

  let i = 0;
  this.buffIndicators.forEach((indicator) => {
    const x = startX + i * (indicatorWidth + gap);
    indicator.bg.setPosition(x + indicatorWidth / 2, y);
    indicator.fill.setPosition(x + indicatorWidth / 2, y);
    indicator.icon.setPosition(x + indicatorWidth / 2, y - iconSize);
    i++;
  });
}
```

**6. Update buff indicators in `update()` loop:**

In the HUDScene `update()` method, add:
```typescript
// Update buff indicator fill bars (shrinking over time)
this.buffIndicators.forEach((indicator, buffType) => {
  const elapsed = Date.now() - indicator.startTime;
  const remaining = indicator.duration - elapsed;
  const fraction = Math.max(0, remaining / indicator.duration);

  // Shrink fill bar width
  const indicatorWidth = 50;
  indicator.fill.setSize(indicatorWidth * fraction, 8);
  // Adjust position to keep left-aligned shrink
  const baseX = indicator.bg.x - indicatorWidth / 2;
  indicator.fill.setPosition(baseX + (indicatorWidth * fraction) / 2, indicator.fill.y);

  // Flash when about to expire (last 1.5 seconds)
  if (remaining < 1500 && remaining > 0 && !indicator.flashTimer) {
    indicator.flashTimer = this.time.addEvent({
      delay: 150,
      callback: () => {
        indicator.fill.setAlpha(indicator.fill.alpha === 1 ? 0.3 : 1);
        indicator.icon.setAlpha(indicator.icon.alpha === 1 ? 0.3 : 1);
      },
      loop: true,
    });
  }
});
```

**7. Stage transition cleanup:**

In the existing matchState listener (where stage_end/stage_transition is handled), add buff indicator cleanup:
```typescript
// When matchState changes to stage_transition or stage_end
this.buffIndicators.forEach((indicator) => {
  indicator.bg.destroy();
  indicator.fill.destroy();
  indicator.icon.destroy();
  if (indicator.flashTimer) indicator.flashTimer.destroy();
});
this.buffIndicators.clear();
```

Also add to `create()` reset:
```typescript
this.buffIndicators = new Map();
```

**8. Kill feed styling for powerup messages:**

The existing `addKillFeedEntry` method accepts `killerRole` and `victimRole` for coloring. For powerup spawns, pass empty roles so text renders in default white. For collections, use the player's role color for their name.

If the kill feed currently uses `charColor(role)` for coloring, powerup entries with empty role will get the default color (white), which is fine for spawn announcements.

**9. Reconnection:**

In `setupRoomListeners()` or equivalent (the method that registers all HUD room listeners), ensure powerup-related `onMessage` handlers are registered. If HUDScene has a separate method for reconnection listener re-registration, include these there too.
  </action>
  <verify>
Run `cd /Users/jonasbrandvik/Projects/banger-game/client && npx tsc --noEmit` to confirm compilation. Verify HUDScene has: buffIndicators map, addBuffIndicator/removeBuffIndicator/repositionBuffIndicators methods, update loop shrinks fill bars, flash timer for expiring buffs, stage cleanup destroys indicators, kill feed receives powerup events.
  </verify>
  <done>HUD displays active buff indicators with colored shrinking duration bars and potion icons. Indicators flash when about to expire. Kill feed announces powerup spawns and collections. All indicators clean up on stage transition. Multiple buffs display side by side.</done>
</task>

</tasks>

<verification>
1. `cd client && npx tsc --noEmit` passes
2. Powerup sprites appear with bobbing animation on Schema onAdd
3. Powerup sprites blink during last 4s before despawn
4. Collection produces SFX chime + floating text
5. Buff auras appear on collecting player's sprite (blue/gold/red)
6. Buff auras disappear on buff expiry, player death, and stage transition
7. Beam projectiles render at 5x size with gold glow
8. HUD shows shrinking duration bar per active buff
9. HUD indicators flash in last 1.5 seconds
10. Kill feed shows "Speed Boost appeared!" and "PlayerName collected Speed Boost"
11. cleanupStageVisuals destroys all powerup/aura/indicator state
12. All new maps reset in create()
</verification>

<success_criteria>
Client compiles and renders the complete powerup visual experience: ground items with bobbing/blinking, collection feedback, player auras, beam visuals, HUD indicators, and kill feed messages. All visuals properly clean up on stage transitions and reconnection. No ghost sprites or stale emitters.
</success_criteria>

<output>
After completion, create `.planning/phases/10-powerup-system/10-04-SUMMARY.md`
</output>
