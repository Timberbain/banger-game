---
phase: 10-powerup-system
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - shared/powerups.ts
  - server/src/schema/Powerup.ts
  - server/src/schema/Projectile.ts
  - server/src/schema/GameState.ts
  - server/src/rooms/GameRoom.ts
autonomous: true

must_haves:
  truths:
    - "Powerups spawn at random walkable tiles every 8-12s during PLAYING state, with first spawn delayed 10-15s"
    - "Maximum 2 powerups exist on the map simultaneously"
    - "Powerups despawn after 15s if uncollected"
    - "Walking over a powerup collects it (server-authoritative) and applies a time-limited buff"
    - "Same buff type refreshes timer; different buff types stack"
    - "Powerups are cleared between stages and spawn fresh each stage"
  artifacts:
    - path: "shared/powerups.ts"
      provides: "PowerupType enum, POWERUP_CONFIG constants, POWERUP_NAMES lookup"
      contains: "PowerupType"
    - path: "server/src/schema/Powerup.ts"
      provides: "PowerupState Colyseus Schema class"
      contains: "PowerupState"
    - path: "server/src/schema/Projectile.ts"
      provides: "isBeam and hitboxScale fields on Projectile"
      contains: "isBeam"
    - path: "server/src/schema/GameState.ts"
      provides: "powerups MapSchema on GameState, speedMultiplier on Player"
      contains: "powerups"
  key_links:
    - from: "server/src/rooms/GameRoom.ts"
      to: "shared/powerups.ts"
      via: "import PowerupType, POWERUP_CONFIG"
      pattern: "import.*powerups"
    - from: "server/src/rooms/GameRoom.ts"
      to: "server/src/schema/GameState.ts"
      via: "this.state.powerups MapSchema operations"
      pattern: "this\\.state\\.powerups"
---

<objective>
Create the shared powerup constants, all Schema definitions, and the core server-side powerup system: spawn logic, collection detection, buff tracking, and stage lifecycle integration.

Purpose: Establish the server-authoritative powerup foundation that all client rendering and HUD display depends on. After this plan, the server correctly spawns powerups, detects collection, tracks buffs, broadcasts events, and cleans up between stages.

Output: `shared/powerups.ts`, `server/src/schema/Powerup.ts`, modified `Projectile.ts`, `GameState.ts`, and `GameRoom.ts` with full spawn/collection/buff/stage-cleanup logic.
</objective>

<execution_context>
@/Users/jonasbrandvik/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jonasbrandvik/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-powerup-system/10-RESEARCH.md
@shared/characters.ts
@shared/physics.ts
@shared/obstacles.ts
@server/src/schema/GameState.ts
@server/src/schema/Obstacle.ts
@server/src/schema/Projectile.ts
@server/src/rooms/GameRoom.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create shared powerup constants and Schema definitions</name>
  <files>
    shared/powerups.ts
    server/src/schema/Powerup.ts
    server/src/schema/Projectile.ts
    server/src/schema/GameState.ts
  </files>
  <action>
**1. Create `shared/powerups.ts`** with:
- `PowerupType` enum: `SPEED = 0`, `INVINCIBILITY = 1`, `PROJECTILE = 2`
- `POWERUP_NAMES` record mapping PowerupType values to display strings: "Speed Boost", "Invincibility", "Power Shot"
- `POWERUP_CONFIG` object with all constants (use exact values from CONTEXT decisions):
  - `maxOnMap: 2`
  - `spawnIntervalMin: 8000` (ms)
  - `spawnIntervalMax: 12000` (ms)
  - `firstSpawnDelay: 12000` (ms, middle of 10-15s range)
  - `despawnTime: 15000` (ms)
  - `despawnWarningTime: 4000` (ms before despawn to blink)
  - `collectionRadius: 14` (slightly larger than playerRadius for generous pickup)
  - `minSpawnDistance: 160` (~5 tiles from alive players)
  - `speedDuration: 4500` (ms, middle of 4-5s)
  - `invincibilityDuration: 2500` (ms, middle of 2-3s)
  - `projectileDuration: 5500` (ms, middle of 5-6s)
  - `speedMultiplier: 1.5` (+50%)
  - `guardianHitboxScale: 2`
  - `guardianSpeedScale: 2`
  - `paranBeamHitboxScale: 5`
  - `paranBeamCooldownMultiplier: 2`
- Export `BUFF_DURATIONS` record mapping PowerupType to duration for cleaner lookup

**2. Create `server/src/schema/Powerup.ts`** following ObstacleState pattern:
```typescript
import { Schema, type } from '@colyseus/schema';

export class PowerupState extends Schema {
  @type('number') x: number = 0;
  @type('number') y: number = 0;
  @type('uint8') powerupType: number = 0;
  @type('number') spawnTime: number = 0;
}
```

**3. Modify `server/src/schema/Projectile.ts`:**
Add two new Schema-synced fields for beam/buff projectiles:
- `@type('boolean') isBeam: boolean = false;`
- `@type('uint8') hitboxScale: number = 1;`

**4. Modify `server/src/schema/GameState.ts`:**
- Import `PowerupState` from `./Powerup`
- Add to `Player` class: `@type('number') speedMultiplier: number = 1;` (synced for client prediction -- default 1.0, set to 1.5 during speed buff)
- Add to `GameState` class: `@type({ map: PowerupState }) powerups = new MapSchema<PowerupState>();`

Note: Player `activeBuffs` is server-only (no @type decorator), defined as `activeBuffs: Array<{ type: number; expiresAt: number; duration: number }> = [];` on the Player class alongside existing server-only fields like `inputQueue` and `lastFireTime`.
  </action>
  <verify>
Run `cd /Users/jonasbrandvik/Projects/banger-game/server && npx tsc --noEmit` to confirm no TypeScript errors. Verify `shared/powerups.ts` exports PowerupType, POWERUP_CONFIG, POWERUP_NAMES, BUFF_DURATIONS. Verify Projectile has isBeam and hitboxScale. Verify GameState has powerups MapSchema. Verify Player has speedMultiplier and activeBuffs.
  </verify>
  <done>All shared constants, Schema classes, and type definitions compile without errors. PowerupState follows ObstacleState pattern. Player has both synced speedMultiplier and server-only activeBuffs.</done>
</task>

<task type="auto">
  <name>Task 2: Implement server powerup spawn, collection, buff tracking, and stage cleanup</name>
  <files>
    server/src/rooms/GameRoom.ts
  </files>
  <action>
**Add imports** at top of GameRoom.ts:
- Import `PowerupState` from schema
- Import `PowerupType, POWERUP_CONFIG, POWERUP_NAMES, BUFF_DURATIONS` from shared/powerups

**Add server-only instance fields** on GameRoom class:
- `private nextSpawnTime: number = 0;` -- tracks when next powerup can spawn
- `private powerupIdCounter: number = 0;` -- unique ID generator for powerup keys
- `private originalObstacleTiles: Set<string> = new Set();` -- tracks original obstacle positions for spawn exclusion

**Modify `loadMap()`:**
After the obstacle initialization loop, populate `originalObstacleTiles`:
```typescript
this.originalObstacleTiles = new Set();
for (let y = 0; y < mapJson.height; y++) {
  for (let x = 0; x < mapJson.width; x++) {
    const tileId = wallLayer.data[y * mapJson.width + x];
    if (OBSTACLE_TILE_IDS.destructible.has(tileId)) {
      this.originalObstacleTiles.add(`${x},${y}`);
    }
  }
}
```

**Add `findSpawnTile()` private method:**
- Attempt up to 50 random tile positions within the map bounds (exclude border tiles: x >= 1, x < width-1, y >= 1, y < height-1)
- For each candidate: check `this.collisionGrid.isSolid(tileX, tileY)` -- skip if solid
- Check `this.originalObstacleTiles.has(tileX,tileY)` -- skip if was ever an obstacle
- Convert to world coords: `worldX = tileX * 32 + 16`, `worldY = tileY * 32 + 16`
- Check distance from all alive players (health > 0): skip if any player within `POWERUP_CONFIG.minSpawnDistance`
- Return `{ x: worldX, y: worldY }` on success, `null` after 50 failed attempts

**Add `checkPowerupSpawns()` private method:**
Called once per fixedTick during PLAYING state.
- Guard: `if (this.state.powerups.size >= POWERUP_CONFIG.maxOnMap) return;`
- Guard: `if (this.state.serverTime < this.nextSpawnTime) return;`
- Call `findSpawnTile()` -- if null, return (no valid tile)
- Create `PowerupState`: set x, y, powerupType = `Math.floor(Math.random() * 3)`, spawnTime = serverTime
- Set key: `pwr_${this.powerupIdCounter++}`
- Add to `this.state.powerups.set(key, powerup)`
- Broadcast `powerupSpawn` event: `{ type: powerup.powerupType, typeName: POWERUP_NAMES[powerup.powerupType] }`
- Schedule next spawn: `this.nextSpawnTime = this.state.serverTime + POWERUP_CONFIG.spawnIntervalMin + Math.random() * (POWERUP_CONFIG.spawnIntervalMax - POWERUP_CONFIG.spawnIntervalMin)`

**Add `checkPowerupCollections()` private method:**
Called once per fixedTick after player movement resolution.
- Iterate `this.state.powerups.forEach((powerup, id) => { ... })` -- collect IDs to remove after iteration (don't mutate during forEach)
- **Despawn check:** If `serverTime - powerup.spawnTime > POWERUP_CONFIG.despawnTime`, mark for removal, broadcast `powerupDespawn` event `{ id, type: powerup.powerupType }`
- **Collection check:** For each alive player (health > 0), compute distance. If `dist < COMBAT.playerRadius + POWERUP_CONFIG.collectionRadius`:
  - Call `collectPowerup(sessionId, player, powerup, id)`
  - Mark powerup ID for removal, break out of player loop (first server tick wins)
- After iteration, delete all marked IDs from `this.state.powerups`

**Add `collectPowerup()` private method:**
- Determine buff duration from `BUFF_DURATIONS[powerup.powerupType]`
- Check if player already has this buff type in `player.activeBuffs`:
  - If yes: refresh timer only (set `expiresAt = serverTime + duration`) -- do NOT stack same type
  - If no: push new buff `{ type: powerup.powerupType, expiresAt: serverTime + duration, duration }`
- If buff type is SPEED: set `player.speedMultiplier = POWERUP_CONFIG.speedMultiplier` (Schema-synced for prediction)
- Broadcast `powerupCollect` event: `{ playerId: sessionId, playerName: player.name, playerRole: player.role, type: powerup.powerupType, typeName: POWERUP_NAMES[powerup.powerupType], duration }`

**Add `updateBuffTimers()` private method:**
Called once per fixedTick.
- For each player, iterate `activeBuffs` array backwards:
  - If `serverTime >= buff.expiresAt`:
    - If buff type is SPEED: reset `player.speedMultiplier = 1`
    - Broadcast `buffExpired` event: `{ playerId: sessionId, type: buff.type }`
    - Splice buff from array
- Also track: if player has no speed buff remaining, ensure `speedMultiplier = 1`

**Modify `fixedTick()`:**
After the win condition check (line ~703), add three calls:
```typescript
this.checkPowerupSpawns();
this.checkPowerupCollections();
this.updateBuffTimers();
```

**Modify `resetStage()`:**
After clearing obstacles (step 2), add step 2.5 -- clear powerups:
```typescript
// 2.5 Clear powerups: collect keys first, then delete (NOT .clear())
const powerupKeys: string[] = [];
this.state.powerups.forEach((_, key) => powerupKeys.push(key));
for (const key of powerupKeys) {
  this.state.powerups.delete(key);
}
```
In the player reset loop (step 4), add:
```typescript
player.activeBuffs = [];
player.speedMultiplier = 1;
```

**Modify `startStage()`:**
After setting matchStartTime, initialize spawn timer with first-spawn delay:
```typescript
this.nextSpawnTime = this.state.serverTime + POWERUP_CONFIG.firstSpawnDelay;
this.powerupIdCounter = 0;
```

**Also modify `startMatch()` (for first stage):**
Add the same spawn timer initialization:
```typescript
this.nextSpawnTime = this.state.serverTime + POWERUP_CONFIG.firstSpawnDelay;
```

**On player death:** In both the contact kill section and the projectile hit section, when a player dies (health reaches 0), clear their buffs:
```typescript
if (wasAlive && isDead) {
  target.activeBuffs = [];
  target.speedMultiplier = 1;
  // ... existing kill stats + broadcast
}
```
For contact kill deaths, add the same cleanup after `target.health = 0;`.
  </action>
  <verify>
Run `cd /Users/jonasbrandvik/Projects/banger-game/server && npx tsc --noEmit` to confirm no TypeScript errors. Start the server with `cd /Users/jonasbrandvik/Projects/banger-game/server && timeout 5 npx ts-node-dev src/index.ts 2>&1 || true` and verify no runtime errors in first 5 seconds. Check that console logs show successful map loading.
  </verify>
  <done>Server correctly spawns powerups at random walkable tiles (avoiding solid tiles, original obstacles, and nearby players), detects collection via circle overlap, applies time-limited buffs, tracks buff expiry, broadcasts all events (powerupSpawn, powerupCollect, powerupDespawn, buffExpired), clears everything on stage reset, and initializes spawn timers on stage/match start.</done>
</task>

</tasks>

<verification>
1. `cd server && npx tsc --noEmit` passes with no errors
2. `shared/powerups.ts` exports PowerupType enum, POWERUP_CONFIG, POWERUP_NAMES, BUFF_DURATIONS
3. `PowerupState` Schema has x, y, powerupType, spawnTime fields
4. `Projectile` Schema has isBeam and hitboxScale fields
5. `Player` Schema has speedMultiplier (synced) and activeBuffs (server-only)
6. `GameState` has `powerups` MapSchema
7. `GameRoom.fixedTick` calls spawn, collection, and buff timer methods
8. `GameRoom.resetStage` clears powerups and player buffs
9. `GameRoom.startStage/startMatch` initializes spawn timer with firstSpawnDelay
10. Player death clears their buffs and resets speedMultiplier
</verification>

<success_criteria>
Server compiles and runs. Powerup spawn/collection/buff logic is complete and server-authoritative. Stage lifecycle properly resets powerup state. All broadcast events are fired for client consumption. No Colyseus 0.15 anti-patterns (.clear(), etc).
</success_criteria>

<output>
After completion, create `.planning/phases/10-powerup-system/10-01-SUMMARY.md`
</output>
