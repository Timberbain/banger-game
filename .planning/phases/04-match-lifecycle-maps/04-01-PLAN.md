---
phase: 04-match-lifecycle-maps
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - server/src/schema/GameState.ts
  - server/src/schema/Projectile.ts
  - server/src/rooms/GameRoom.ts
autonomous: true

must_haves:
  truths:
    - "Match transitions from WAITING to PLAYING when 3 players join"
    - "Game logic only runs during PLAYING state"
    - "Match ends when all guardians dead OR Paran dead"
    - "Per-player stats (kills, deaths, damageDealt, shotsFired, shotsHit) tracked during match"
    - "Final stats broadcast to all clients on match end"
    - "Input from dead players is ignored by server"
  artifacts:
    - path: "server/src/schema/GameState.ts"
      provides: "MatchState enum, PlayerStats schema, matchState/matchStartTime/matchEndTime fields on GameState"
      contains: "MatchState"
    - path: "server/src/rooms/GameRoom.ts"
      provides: "Match state machine, win condition detection, stats tracking, matchEnd broadcast"
      contains: "checkWinConditions"
  key_links:
    - from: "server/src/rooms/GameRoom.ts"
      to: "server/src/schema/GameState.ts"
      via: "matchState field guards fixedTick processing"
      pattern: "matchState.*PLAYING"
    - from: "server/src/rooms/GameRoom.ts"
      to: "broadcast matchEnd"
      via: "endMatch method sends stats to all clients"
      pattern: "broadcast.*matchEnd"
---

<objective>
Add server-side match lifecycle state machine with win conditions and per-player statistics tracking.

Purpose: Transform the combat sandbox into a structured match with clear start/end states. The server must detect when all guardians or Paran are eliminated, broadcast results with stats, and prevent game logic from running outside the PLAYING state.

Output: Server schema with MatchState enum and PlayerStats, GameRoom with match state transitions, win condition checking, stat tracking during combat, and matchEnd broadcast.
</objective>

<execution_context>
@/Users/jonasbrandvik/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jonasbrandvik/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-match-lifecycle-maps/04-RESEARCH.md
@server/src/schema/GameState.ts
@server/src/schema/Projectile.ts
@server/src/rooms/GameRoom.ts
@shared/characters.ts
@shared/physics.ts
@server/src/config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add MatchState enum, PlayerStats schema, and match lifecycle fields to GameState</name>
  <files>server/src/schema/GameState.ts</files>
  <action>
Extend the existing GameState schema with match lifecycle support:

1. **Add MatchState enum** at top of file (string enum for Colyseus schema compatibility):
   ```typescript
   export enum MatchState {
     WAITING = "waiting",
     PLAYING = "playing",
     ENDED = "ended"
   }
   ```

2. **Add PlayerStats schema class** (new class in same file):
   ```typescript
   export class PlayerStats extends Schema {
     @type("number") kills: number = 0;
     @type("number") deaths: number = 0;
     @type("number") damageDealt: number = 0;
     @type("number") shotsFired: number = 0;
     @type("number") shotsHit: number = 0;
   }
   ```

3. **Add match fields to GameState**:
   - `@type("string") matchState: string = MatchState.WAITING;`
   - `@type("number") matchStartTime: number = 0;`
   - `@type("number") matchEndTime: number = 0;`
   - `@type({ map: PlayerStats }) matchStats = new MapSchema<PlayerStats>();`
   - `@type("string") winner: string = "";` (empty string = no winner yet; "paran" or "guardians")

Keep all existing Player, GameState fields intact. PlayerStats is synced to clients so they can read stats live (not just at match end).
  </action>
  <verify>Run `cd /Users/jonasbrandvik/Projects/banger-game/server && npx tsc --noEmit` to verify TypeScript compiles without errors.</verify>
  <done>GameState.ts has MatchState enum, PlayerStats class with 5 stat fields, and GameState has matchState, matchStartTime, matchEndTime, matchStats, and winner fields.</done>
</task>

<task type="auto">
  <name>Task 2: Implement match state machine, win conditions, and stats tracking in GameRoom</name>
  <files>server/src/rooms/GameRoom.ts</files>
  <action>
Modify GameRoom to add complete match lifecycle management. Import MatchState and PlayerStats from GameState.

**1. Match State Initialization (onCreate):**
- Set `this.state.matchState = MatchState.WAITING` (already default, but explicit)
- No other changes to onCreate needed

**2. Player Join (onJoin):**
- After creating Player, create `new PlayerStats()` and add to `this.state.matchStats.set(client.sessionId, stats)` BEFORE adding player to state
- After adding player, check if `this.state.players.size === this.maxClients` (3 players) — if so, call `this.startMatch()`

**3. Add startMatch method:**
```typescript
private startMatch() {
  this.state.matchState = MatchState.PLAYING;
  this.state.matchStartTime = this.state.serverTime;
  this.lock(); // Prevent additional joins
  this.broadcast("matchStart", { startTime: this.state.matchStartTime });
}
```

**4. Guard fixedTick with matchState check:**
At the very start of fixedTick, add:
```typescript
if (this.state.matchState !== MatchState.PLAYING) {
  // Still increment serverTime during WAITING (needed for matchStartTime comparison)
  this.state.serverTime += deltaTime;
  return;
}
```
This prevents all movement, projectile processing, and combat during WAITING and ENDED states.

**5. Track stats during combat — modify the existing projectile fire code:**
When a projectile is spawned (fire input), increment:
```typescript
const shooterStats = this.state.matchStats.get(sessionId);
if (shooterStats) shooterStats.shotsFired++;
```

**6. Track stats during projectile collision — modify the existing hit detection:**
When a projectile hits a player:
```typescript
const shooterStats = this.state.matchStats.get(proj.ownerId);
if (shooterStats) {
  shooterStats.shotsHit++;
  shooterStats.damageDealt += proj.damage;
  if (target.health === 0) {
    shooterStats.kills++;
    const targetStats = this.state.matchStats.get(targetId);
    if (targetStats) targetStats.deaths++;
  }
}
```

**7. Ignore dead player input:**
At the start of the player.forEach loop in fixedTick, add:
```typescript
if (player.health <= 0) {
  player.inputQueue = []; // Drain dead player input
  return; // Skip processing
}
```

**8. Add win condition check — call after projectile processing in fixedTick:**
```typescript
private checkWinConditions() {
  const players = Array.from(this.state.players.values());
  const aliveParan = players.find(p => p.role === "paran" && p.health > 0);
  const aliveGuardians = players.filter(p => p.role !== "paran" && p.health > 0);

  if (!aliveParan) {
    this.endMatch("guardians");
  } else if (aliveGuardians.length === 0) {
    this.endMatch("paran");
  }
}
```

**9. Add endMatch method:**
```typescript
private endMatch(winner: string) {
  // Drain all input queues
  this.state.players.forEach(p => { p.inputQueue = []; });

  // Set winner
  this.state.winner = winner;

  // Serialize stats for broadcast (client can also read from matchStats, but broadcast provides clean object)
  const stats: Record<string, any> = {};
  this.state.matchStats.forEach((playerStats, sessionId) => {
    const player = this.state.players.get(sessionId);
    stats[sessionId] = {
      name: player?.name || "Unknown",
      role: player?.role || "unknown",
      kills: playerStats.kills,
      deaths: playerStats.deaths,
      damageDealt: playerStats.damageDealt,
      shotsFired: playerStats.shotsFired,
      shotsHit: playerStats.shotsHit,
      accuracy: playerStats.shotsFired > 0
        ? Math.round(playerStats.shotsHit / playerStats.shotsFired * 1000) / 10
        : 0
    };
  });

  // Broadcast final stats
  this.broadcast("matchEnd", {
    winner,
    stats,
    duration: this.state.serverTime - this.state.matchStartTime
  });

  // Set match state to ENDED (triggers client scene transitions)
  this.state.matchState = MatchState.ENDED;
  this.state.matchEndTime = this.state.serverTime;

  // Auto-disconnect after 15 seconds (gives time to view stats)
  this.clock.setTimeout(() => {
    this.disconnect();
  }, 15000);
}
```

**10. Handle player leave during match:**
In onLeave, if matchState is PLAYING, check win conditions after removing the player (a guardian leaving counts as guardian eliminated for win condition purposes):
```typescript
onLeave(client: Client, consented: boolean) {
  this.state.players.delete(client.sessionId);
  // Clean up stats (keep them for display, don't delete)
  console.log(`Player left: ${client.sessionId} (consented: ${consented})`);

  // Check if leaving triggers win condition
  if (this.state.matchState === MatchState.PLAYING) {
    this.checkWinConditions();
  }
}
```

**PITFALL AVOIDANCE:**
- Check matchState at START of fixedTick (prevents combat during transitions)
- Drain input queues when transitioning to ENDED (prevents post-match actions)
- Check `player.health <= 0` before processing input (prevents ghost shooting)
- Initialize stats BEFORE adding player to state (prevents race condition)
  </action>
  <verify>
1. Run `cd /Users/jonasbrandvik/Projects/banger-game/server && npx tsc --noEmit` — compiles without errors
2. Start server: `cd /Users/jonasbrandvik/Projects/banger-game/server && npx ts-node-dev src/index.ts` — starts without crash
3. Open 3 browser tabs to http://localhost:8080 — match should transition from WAITING to PLAYING when third player joins
  </verify>
  <done>GameRoom has full match lifecycle: WAITING on create, PLAYING when 3 join (room locked), win condition checked after combat each tick, ENDED with stats broadcast when one side eliminated, auto-disconnect after 15s. Dead player input ignored. Stats tracked for kills/deaths/damage/shots.</done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `cd server && npx tsc --noEmit` passes
2. Server starts without errors
3. Match remains in WAITING until 3 players connect
4. Match transitions to PLAYING when third player joins
5. Room locked during PLAYING (no new joins)
6. Dead player input is ignored (no ghost shooting)
7. When all guardians die, matchEnd broadcast says winner="paran"
8. When Paran dies, matchEnd broadcast says winner="guardians"
9. Stats include kills, deaths, damageDealt, shotsFired, shotsHit, accuracy
10. Match state becomes ENDED after win condition met
11. Room auto-disconnects 15 seconds after match ends
</verification>

<success_criteria>
- Server compiles and starts without errors
- Match state machine works: WAITING -> PLAYING -> ENDED
- Win conditions detected: all guardians dead = Paran wins, Paran dead = guardians win
- Per-player stats tracked (kills, deaths, damage, shots fired, shots hit)
- matchEnd message broadcast to all clients with winner and stats
- Dead player input ignored by server
</success_criteria>

<output>
After completion, create `.planning/phases/04-match-lifecycle-maps/04-01-SUMMARY.md`
</output>
