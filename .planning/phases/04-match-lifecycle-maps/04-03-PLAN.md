---
phase: 04-match-lifecycle-maps
plan: 03
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - shared/maps.ts
  - client/public/maps/corridor_chaos.json
  - client/public/maps/cross_fire.json
  - client/public/maps/pillars.json
  - server/src/rooms/GameRoom.ts
  - client/src/scenes/GameScene.ts
  - client/src/scenes/BootScene.ts
autonomous: true

must_haves:
  truths:
    - "3 new hand-crafted arena maps exist with distinct obstacle layouts (corridor_chaos, cross_fire, pillars)"
    - "Server selects map from pool and stores in state.mapName"
    - "Client loads tilemap dynamically based on state.mapName"
    - "Each map has unique spawn points for Paran and guardians"
    - "Maps rotate sequentially between room creations"
    - "Existing test_arena map still works as part of the rotation"
  artifacts:
    - path: "shared/maps.ts"
      provides: "Map metadata array with names, file paths, spawn points, arena bounds per map"
      contains: "MAPS"
    - path: "client/public/maps/corridor_chaos.json"
      provides: "Tiled JSON map with narrow corridors and tight spaces"
    - path: "client/public/maps/cross_fire.json"
      provides: "Tiled JSON map with central cross pattern and open corners"
    - path: "client/public/maps/pillars.json"
      provides: "Tiled JSON map with scattered pillar obstacles"
  key_links:
    - from: "server/src/rooms/GameRoom.ts"
      to: "shared/maps.ts"
      via: "import MAPS, select map, use spawn points"
      pattern: "MAPS\\["
    - from: "client/src/scenes/GameScene.ts"
      to: "shared/maps.ts"
      via: "import MAPS, find map by mapName, load tilemap"
      pattern: "MAPS\\.find"
    - from: "server/src/rooms/GameRoom.ts"
      to: "server/src/schema/GameState.ts"
      via: "sets state.mapName to selected map name"
      pattern: "state\\.mapName"
---

<objective>
Create 3 new hand-crafted arena maps with distinct obstacle layouts and implement map rotation between matches.

Purpose: Add gameplay variety through different arena designs that create unique tactical situations. Corridor maps force close combat, open maps reward projectile accuracy, and pillar maps enable cover-based play. Map rotation ensures variety between matches.

Output: 3 new Tiled JSON maps, shared/maps.ts metadata module, server map selection with spawn points, client dynamic map loading, sequential rotation.
</objective>

<execution_context>
@/Users/jonasbrandvik/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jonasbrandvik/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-match-lifecycle-maps/04-RESEARCH.md
@.planning/phases/04-match-lifecycle-maps/04-01-PLAN.md
@shared/physics.ts
@client/public/maps/test_arena.json
@server/src/rooms/GameRoom.ts
@client/src/scenes/GameScene.ts
@client/src/scenes/BootScene.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create shared/maps.ts and 3 new Tiled JSON arena maps</name>
  <files>
    shared/maps.ts
    client/public/maps/corridor_chaos.json
    client/public/maps/cross_fire.json
    client/public/maps/pillars.json
  </files>
  <action>
**1. Create shared/maps.ts — map metadata registry:**

```typescript
export interface MapMetadata {
  name: string;
  displayName: string;
  file: string;         // Path relative to client public dir
  tileset: string;      // Tileset key name
  width: number;        // Arena width in pixels
  height: number;       // Arena height in pixels
  spawnPoints: {
    paran: { x: number; y: number };
    guardians: [{ x: number; y: number }, { x: number; y: number }];
  };
}

export const MAPS: MapMetadata[] = [
  {
    name: "test_arena",
    displayName: "Test Arena",
    file: "maps/test_arena.json",
    tileset: "tiles",
    width: 800,
    height: 608,
    spawnPoints: {
      paran: { x: 400, y: 304 },
      guardians: [{ x: 150, y: 150 }, { x: 650, y: 460 }]
    }
  },
  {
    name: "corridor_chaos",
    displayName: "Corridor Chaos",
    file: "maps/corridor_chaos.json",
    tileset: "tiles",
    width: 800,
    height: 608,
    spawnPoints: {
      paran: { x: 400, y: 304 },
      guardians: [{ x: 100, y: 100 }, { x: 700, y: 500 }]
    }
  },
  {
    name: "cross_fire",
    displayName: "Cross Fire",
    file: "maps/cross_fire.json",
    tileset: "tiles",
    width: 800,
    height: 608,
    spawnPoints: {
      paran: { x: 400, y: 304 },
      guardians: [{ x: 100, y: 500 }, { x: 700, y: 100 }]
    }
  },
  {
    name: "pillars",
    displayName: "Pillars",
    file: "maps/pillars.json",
    tileset: "tiles",
    width: 800,
    height: 608,
    spawnPoints: {
      paran: { x: 400, y: 304 },
      guardians: [{ x: 130, y: 304 }, { x: 670, y: 304 }]
    }
  }
];
```

NOTE: All maps use same dimensions as test_arena (25 tiles x 19 tiles, 32px each = 800x608). The ARENA constants in shared/physics.ts define 800x600 — the map is slightly taller but arena bounds handle clamping. Keep ARENA unchanged; maps all use 800x608 pixel dimensions.

**2. Create corridor_chaos.json — narrow corridors with tight spaces:**
Tiled JSON format, same structure as test_arena.json. 25x19 tiles, 32px each.

Layout concept: Horizontal and vertical corridors creating a maze-like feel. Walls form H-shape internal structure with passages. Forces close-range combat.

Design the Walls layer data array (25x19 = 475 values):
- Row 0: all 3s (top border)
- Row 1-17: 3 on edges, internal walls forming corridors
- Row 18: all 3s (bottom border)
- 0 = empty (passable), 3 = wall

Internal wall layout for corridor_chaos (corridors force tactical movement):
```
WWWWWWWWWWWWWWWWWWWWWWWWW
W.......................W
W..WWW...........WWW...W
W..W.............W.....W
W..W..WWWWWWWW...W.....W
W..W.............W.....W
W..WWW...........WWW...W
W.......................W
W.......................W
W...WWWW.....WWWW......W
W.......................W
W.......................W
W..WWW...........WWW...W
W..W.............W.....W
W..W..WWWWWWWW...W.....W
W..W.............W.....W
W..WWW...........WWW...W
W.......................W
WWWWWWWWWWWWWWWWWWWWWWWWW
```

Translate this to data array: W=3, .=0

**3. Create cross_fire.json — central cross with open corners:**
Layout concept: Large cross/plus shape in the center creating 4 open corner arenas connected by narrow passages.

```
WWWWWWWWWWWWWWWWWWWWWWWWW
W.......................W
W.......................W
W.......................W
W........WWWWW..........W
W........W...W..........W
W........W...W..........W
W........W...W..........W
WWWW.....W...W.....WWWWW
W........W...W..........W
WWWW.....W...W.....WWWWW
W........W...W..........W
W........W...W..........W
W........W...W..........W
W........WWWWW..........W
W.......................W
W.......................W
W.......................W
WWWWWWWWWWWWWWWWWWWWWWWWW
```

Translate to data array.

**4. Create pillars.json — scattered pillar obstacles:**
Layout concept: Individual 2x2 or 1x1 pillar blocks scattered across the arena providing cover but no full corridors. Open-field combat with cover options.

```
WWWWWWWWWWWWWWWWWWWWWWWWW
W.......................W
W.......................W
W....WW........WW......W
W....WW........WW......W
W.......................W
W.......................W
W..........WW...........W
W..........WW...........W
W.......................W
W.......................W
W..WW...........WW.....W
W..WW...........WW.....W
W.......................W
W.......................W
W....WW........WW......W
W....WW........WW......W
W.......................W
WWWWWWWWWWWWWWWWWWWWWWWWW
```

Translate to data array.

**IMPORTANT IMPLEMENTATION DETAIL for creating JSON maps:**
- Use the EXACT same structure as test_arena.json (same tilesets entry, same layer structure)
- Ground layer: all tile 2 (same grass fill)
- Walls layer: 3 for walls, 0 for empty
- Same metadata (tileheight: 32, tilewidth: 32, width: 25, height: 19)
- Same tileset reference (placeholder, 4 columns, 8 tiles)

Each map must be valid Tiled JSON that Phaser can load with `load.tilemapTiledJSON()`.
  </action>
  <verify>
1. Verify JSON is valid: `node -e "JSON.parse(require('fs').readFileSync('client/public/maps/corridor_chaos.json', 'utf8')); console.log('valid');"` (repeat for cross_fire.json and pillars.json)
2. Verify each map has correct dimensions: 25 wide, 19 tall, 475 tiles per layer
3. Verify shared/maps.ts compiles: `cd server && npx tsc --noEmit`
  </verify>
  <done>shared/maps.ts created with MapMetadata interface and 4-map MAPS array (test_arena + 3 new). Three new Tiled JSON maps created with distinct layouts: corridor_chaos (tight corridors), cross_fire (central cross with open corners), pillars (scattered cover).</done>
</task>

<task type="auto">
  <name>Task 2: Integrate map rotation in server and dynamic map loading in client</name>
  <files>
    server/src/rooms/GameRoom.ts
    client/src/scenes/GameScene.ts
    client/src/scenes/BootScene.ts
  </files>
  <action>
**1. Server: Add map selection to GameRoom (server/src/rooms/GameRoom.ts):**

Import MAPS from shared/maps.ts:
```typescript
import { MAPS, MapMetadata } from "../../../shared/maps";
```

Add static map rotation index (class-level, shared across room instances):
```typescript
private static currentMapIndex: number = 0;
private mapMetadata!: MapMetadata;
```

In onCreate, select map and store in state:
```typescript
// Select map (sequential rotation across room instances)
this.mapMetadata = MAPS[GameRoom.currentMapIndex % MAPS.length];
this.state.mapName = this.mapMetadata.name;

// Advance rotation for next room
GameRoom.currentMapIndex++;
```

Modify onJoin to use map-specific spawn points instead of random offset:
```typescript
// Replace the existing random spawn position logic with:
if (playerCount === 0) {
  role = "paran";
  player.x = this.mapMetadata.spawnPoints.paran.x;
  player.y = this.mapMetadata.spawnPoints.paran.y;
} else if (playerCount === 1) {
  role = "faran";
  player.x = this.mapMetadata.spawnPoints.guardians[0].x;
  player.y = this.mapMetadata.spawnPoints.guardians[0].y;
} else {
  role = "baran";
  player.x = this.mapMetadata.spawnPoints.guardians[1].x;
  player.y = this.mapMetadata.spawnPoints.guardians[1].y;
}
```

Update arena bounds clamping to use map dimensions (the mapMetadata has width/height):
```typescript
// Replace ARENA.width/height references with map dimensions for position clamping
player.x = Math.max(0, Math.min(this.mapMetadata.width, player.x));
player.y = Math.max(0, Math.min(this.mapMetadata.height, player.y));
```

Also update projectile bounds checking to use map dimensions:
```typescript
if (proj.x < 0 || proj.x > this.mapMetadata.width || proj.y < 0 || proj.y > this.mapMetadata.height) {
```

**2. Client: Dynamic map loading in GameScene (client/src/scenes/GameScene.ts):**

Import MAPS:
```typescript
import { MAPS } from '../../../shared/maps';
```

Replace the hardcoded preload() with an empty one (maps loaded dynamically after state received):
```typescript
preload() {
  // Tileset image is always the same — load it here
  this.load.image('tiles', 'tilesets/placeholder.png');
  // Tilemap JSON loaded dynamically in create() after receiving mapName from server
}
```

In create(), after connecting to room, load map dynamically:
- Move the tilemap creation code to happen AFTER receiving the initial state
- Use `this.room.onStateChange.once()` to get mapName, then load the appropriate map JSON

```typescript
// After room connection succeeds:
this.room.onStateChange.once((state: any) => {
  const mapName = state.mapName || "test_arena";
  const mapData = MAPS.find(m => m.name === mapName);

  if (!mapData) {
    console.error(`Unknown map: ${mapName}, falling back to test_arena`);
  }

  const mapFile = mapData?.file || "maps/test_arena.json";
  const mapKey = mapData?.name || "test_arena";

  // Load the tilemap JSON dynamically
  this.load.tilemapTiledJSON(mapKey, mapFile);
  this.load.once('complete', () => {
    this.createTilemap(mapKey);
  });
  this.load.start();
});
```

Extract tilemap creation into a helper method:
```typescript
private createTilemap(mapKey: string) {
  const map = this.make.tilemap({ key: mapKey });
  const tileset = map.addTilesetImage('placeholder', 'tiles');
  if (!tileset) {
    console.error('Failed to load tileset');
    return;
  }
  const groundLayer = map.createLayer('Ground', tileset, 0, 0);
  const wallsLayer = map.createLayer('Walls', tileset, 0, 0);
  if (wallsLayer) {
    wallsLayer.setCollisionByExclusion([-1, 0]);
  }
}
```

Remove the hardcoded tilemap loading from preload() and the tilemap creation at the top of create() — both are now handled dynamically.

**3. Client: Update BootScene to not load/render test_arena specifically:**

BootScene currently loads and renders test_arena. Since GameScene now handles map loading dynamically, simplify BootScene to just show a loading screen and transition:

```typescript
preload() {
  // Only load tileset image (maps loaded dynamically in GameScene)
  this.load.image('tiles', 'tilesets/placeholder.png');
}

create() {
  // Simple loading/title screen
  this.add.rectangle(400, 300, 800, 600, 0x1a1a2e);

  this.add.text(
    this.cameras.main.centerX,
    this.cameras.main.centerY - 40,
    'BANGER',
    { fontSize: '48px', color: '#ffffff', fontFamily: 'Arial', fontStyle: 'bold' }
  ).setOrigin(0.5);

  this.add.text(
    this.cameras.main.centerX,
    this.cameras.main.centerY + 20,
    'Connecting...',
    { fontSize: '16px', color: '#aaaaaa', fontFamily: 'Arial' }
  ).setOrigin(0.5);

  // Transition to GameScene after brief delay
  this.time.delayedCall(500, () => {
    this.scene.start('GameScene');
  });
}
```

**PITFALL AVOIDANCE:**
- Load tileset image in preload() (always same), load tilemap JSON in create() after state received
- Use onStateChange.once() to read mapName before rendering
- Queue player sprite creation during map load (onAdd may fire before map loads)
- Fall back to test_arena if mapName unknown
  </action>
  <verify>
1. Run `cd /Users/jonasbrandvik/Projects/banger-game/server && npx tsc --noEmit` — server compiles
2. Run `cd /Users/jonasbrandvik/Projects/banger-game/client && npx tsc --noEmit` — client compiles
3. Start server and client — first room should get map from MAPS rotation
4. Verify console logs show selected map name
  </verify>
  <done>Server selects map from MAPS array with sequential rotation, uses map-specific spawn points. Client loads tilemap dynamically from state.mapName. BootScene simplified to title screen. 4 maps in rotation (test_arena + 3 new).</done>
</task>

</tasks>

<verification>
1. All 3 new map JSON files are valid Tiled JSON (parseable, correct dimensions)
2. shared/maps.ts exports MAPS array with 4 entries
3. Server and client both compile without TypeScript errors
4. Server selects maps sequentially from rotation
5. Client loads correct tilemap based on server's mapName
6. Players spawn at map-specific spawn points (not random center offset)
7. Arena bounds use map dimensions for position clamping
8. Projectile bounds use map dimensions
9. BootScene shows title and transitions to GameScene
10. After returning from VictoryScene, BootScene starts new GameScene correctly
</verification>

<success_criteria>
- 4 arena maps total (test_arena + 3 new with distinct layouts)
- Server sequentially rotates maps between room creations
- Client loads correct map dynamically from server state
- Spawn points are map-specific (Paran center, guardians at opposite corners)
- Arena bounds match map dimensions
- Both client and server compile without errors
</success_criteria>

<output>
After completion, create `.planning/phases/04-match-lifecycle-maps/04-03-SUMMARY.md`
</output>
