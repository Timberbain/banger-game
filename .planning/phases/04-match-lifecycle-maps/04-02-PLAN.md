---
phase: 04-match-lifecycle-maps
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - client/src/scenes/GameScene.ts
  - client/src/scenes/VictoryScene.ts
  - client/src/main.ts
autonomous: true

must_haves:
  truths:
    - "Victory/defeat screen appears when match ends showing winner and stats"
    - "Stats table shows each player's kills, deaths, damage, and accuracy"
    - "Local player highlighted in stats table"
    - "Eliminated player stops sending input and can cycle camera between alive players with Tab"
    - "Return to Lobby button disconnects from room and returns to BootScene"
  artifacts:
    - path: "client/src/scenes/VictoryScene.ts"
      provides: "Victory/defeat overlay scene with stats table and Return to Lobby button"
      contains: "VictoryScene"
    - path: "client/src/scenes/GameScene.ts"
      provides: "matchEnd handler, spectator camera cycling, matchState listener"
      contains: "spectatorTarget"
    - path: "client/src/main.ts"
      provides: "VictoryScene registered in Phaser config"
      contains: "VictoryScene"
  key_links:
    - from: "client/src/scenes/GameScene.ts"
      to: "client/src/scenes/VictoryScene.ts"
      via: "scene.launch('VictoryScene', data) on matchEnd message"
      pattern: "scene\\.launch.*VictoryScene"
    - from: "client/src/scenes/VictoryScene.ts"
      to: "client/src/scenes/BootScene.ts"
      via: "Return to Lobby button triggers scene.start('BootScene')"
      pattern: "scene\\.start.*BootScene"
---

<objective>
Add client-side victory/defeat screen with stats display, spectator mode for eliminated players, and match end handling.

Purpose: Give players clear visual feedback when a match ends (who won, how they performed), let eliminated players spectate the remaining action, and provide a path back to the game entry point after viewing results.

Output: VictoryScene overlay with stats table, GameScene spectator mode with Tab-cycling camera, matchEnd message handling, and return-to-lobby flow.
</objective>

<execution_context>
@/Users/jonasbrandvik/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jonasbrandvik/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-match-lifecycle-maps/04-RESEARCH.md
@.planning/phases/04-match-lifecycle-maps/04-01-PLAN.md
@client/src/scenes/GameScene.ts
@client/src/scenes/BootScene.ts
@client/src/main.ts
@server/src/schema/GameState.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add spectator mode and match end handling to GameScene</name>
  <files>client/src/scenes/GameScene.ts</files>
  <action>
Modify GameScene to handle eliminated player spectating and match end transitions.

**1. Add spectator properties to class:**
```typescript
private spectatorTarget: string | null = null;
private tabKey!: Phaser.Input.Keyboard.Key;
private isSpectating: boolean = false;
private matchEnded: boolean = false;
private finalStats: any = null;
private matchWinner: string = "";
```

**2. In create(), add Tab key binding:**
```typescript
this.tabKey = this.input.keyboard!.addKey(Phaser.Input.Keyboard.KeyCodes.TAB);
```

**3. In create(), after successful room connection, add matchEnd message listener:**
```typescript
// Listen for match end broadcast (includes final stats)
this.room.onMessage("matchEnd", (data: any) => {
  this.finalStats = data.stats;
  this.matchWinner = data.winner;
  this.matchEnded = true;

  // Launch victory scene as overlay
  this.scene.launch("VictoryScene", {
    winner: data.winner,
    stats: data.stats,
    duration: data.duration,
    localSessionId: this.room!.sessionId,
    room: this.room
  });

  // Pause game scene input (scene stays visible underneath)
  this.scene.pause();
});
```
NOTE: Do NOT use matchState.listen for the transition — use the explicit matchEnd message to ensure stats arrive before scene launch (pitfall 5 from research).

**4. Modify the update() method to add spectator logic:**
After the existing `isDead` check, add spectator mode:
```typescript
if (isDead && !this.isSpectating && !this.matchEnded) {
  this.isSpectating = true;
  // Set initial spectator target to first alive player
  this.spectatorTarget = this.getNextAlivePlayer(null);
}

if (this.isSpectating && !this.matchEnded) {
  // Cycle through alive players with Tab key
  if (Phaser.Input.Keyboard.JustDown(this.tabKey)) {
    this.spectatorTarget = this.getNextAlivePlayer(this.spectatorTarget);
  }

  // Follow spectator target with camera
  if (this.spectatorTarget) {
    const targetSprite = this.playerSprites.get(this.spectatorTarget);
    if (targetSprite) {
      this.cameras.main.centerOn(targetSprite.x, targetSprite.y);
    } else {
      // Target sprite gone, find next alive player
      this.spectatorTarget = this.getNextAlivePlayer(this.spectatorTarget);
    }
  }

  return; // Skip input processing when spectating
}
```

The existing `isDead` check already prevents input sending — keep that logic. The spectator code goes AFTER the dead check but BEFORE the input reading code.

**5. Add getNextAlivePlayer helper method:**
```typescript
private getNextAlivePlayer(currentTarget: string | null): string | null {
  if (!this.room) return null;

  const alivePlayers: string[] = [];
  this.room.state.players.forEach((player: any, sessionId: string) => {
    if (player.health > 0 && sessionId !== this.room!.sessionId) {
      alivePlayers.push(sessionId);
    }
  });

  if (alivePlayers.length === 0) return null;

  if (!currentTarget) return alivePlayers[0];

  const currentIndex = alivePlayers.indexOf(currentTarget);
  const nextIndex = (currentIndex + 1) % alivePlayers.length;
  return alivePlayers[nextIndex];
}
```

**6. Add spectator status text when entering spectator mode:**
When `isSpectating` becomes true, update the statusText:
```typescript
this.statusText.setText('SPECTATING - Press Tab to cycle players');
```

**7. Handle players.onRemove for spectator targets:**
In the existing onRemove handler, add:
```typescript
// If spectating this player, switch target
if (this.spectatorTarget === sessionId) {
  this.spectatorTarget = this.getNextAlivePlayer(sessionId);
}
```

**8. Add "Waiting for players..." status during WAITING state:**
In create(), after room connection, listen for matchStart:
```typescript
this.room.onMessage("matchStart", () => {
  this.statusText.setText(`Match started!`);
  // Clear the message after 2 seconds
  this.time.delayedCall(2000, () => {
    if (!this.matchEnded) {
      this.statusText.setText(`Connected: ${this.room!.sessionId}`);
    }
  });
});
```

Also update the initial status text after connection:
```typescript
this.statusText.setText(`Waiting for players... (${this.room.state.players.size}/3)`);
```

And update it when players join/leave:
```typescript
// Inside players.onAdd, if matchState is waiting:
if (!this.matchEnded) {
  const count = this.room!.state.players.size;
  if (count < 3) {
    this.statusText.setText(`Waiting for players... (${count}/3)`);
  }
}
```

**IMPORTANT:** Make sure the `isDead` guard at the top of update() only skips INPUT SENDING (not sprite updates). Spectator still needs to update remote player sprites and projectile interpolation. Restructure if needed so that:
1. Input sending is gated by isDead
2. Spectator camera update runs when isSpectating
3. Remote player interpolation + projectile interpolation ALWAYS runs (even when dead/spectating)
  </action>
  <verify>Run `cd /Users/jonasbrandvik/Projects/banger-game/client && npx tsc --noEmit` — compiles without errors.</verify>
  <done>GameScene handles match end (launches VictoryScene overlay on matchEnd message), spectator mode for dead players (Tab to cycle camera between alive players), player count status during WAITING, and match start notification.</done>
</task>

<task type="auto">
  <name>Task 2: Create VictoryScene overlay and register in Phaser config</name>
  <files>
    client/src/scenes/VictoryScene.ts
    client/src/main.ts
  </files>
  <action>
**1. Create VictoryScene (new file: client/src/scenes/VictoryScene.ts):**

A Phaser overlay scene that displays match results. It launches on top of the paused GameScene.

```typescript
import Phaser from 'phaser';

export class VictoryScene extends Phaser.Scene {
  constructor() {
    super({ key: 'VictoryScene' });
  }

  create(data: { winner: string; stats: Record<string, any>; duration: number; localSessionId: string; room: any }) {
    const { winner, stats, duration, localSessionId, room } = data;

    // Semi-transparent black overlay
    this.add.rectangle(400, 300, 800, 600, 0x000000, 0.85).setDepth(0);

    // Determine if local player won
    const localStats = stats[localSessionId];
    const localRole = localStats?.role || "unknown";
    const didWin = (winner === "paran" && localRole === "paran") ||
                   (winner === "guardians" && localRole !== "paran");

    // Victory/Defeat title
    const titleText = didWin ? "VICTORY!" : "DEFEAT";
    const titleColor = didWin ? "#00ff00" : "#ff0000";
    this.add.text(400, 60, titleText, {
      fontSize: '64px',
      color: titleColor,
      fontStyle: 'bold',
      stroke: '#000000',
      strokeThickness: 4
    }).setOrigin(0.5).setDepth(1);

    // Winner subtitle
    const winnerLabel = winner === "paran" ? "Paran Wins!" : "Guardians Win!";
    this.add.text(400, 130, winnerLabel, {
      fontSize: '24px',
      color: '#ffffff'
    }).setOrigin(0.5).setDepth(1);

    // Match duration
    const durationSec = Math.round(duration / 1000);
    const minutes = Math.floor(durationSec / 60);
    const seconds = durationSec % 60;
    this.add.text(400, 165, `Duration: ${minutes}:${seconds.toString().padStart(2, '0')}`, {
      fontSize: '16px',
      color: '#aaaaaa'
    }).setOrigin(0.5).setDepth(1);

    // Stats header
    this.add.text(400, 210, "MATCH STATISTICS", {
      fontSize: '22px',
      color: '#ffff00',
      fontStyle: 'bold'
    }).setOrigin(0.5).setDepth(1);

    // Table header row
    const headerY = 250;
    const cols = { name: 100, role: 250, kills: 340, deaths: 400, damage: 470, accuracy: 570 };
    this.add.text(cols.name, headerY, "Player", { fontSize: '14px', color: '#888888' }).setDepth(1);
    this.add.text(cols.role, headerY, "Role", { fontSize: '14px', color: '#888888' }).setDepth(1);
    this.add.text(cols.kills, headerY, "K", { fontSize: '14px', color: '#888888' }).setDepth(1);
    this.add.text(cols.deaths, headerY, "D", { fontSize: '14px', color: '#888888' }).setDepth(1);
    this.add.text(cols.damage, headerY, "Damage", { fontSize: '14px', color: '#888888' }).setDepth(1);
    this.add.text(cols.accuracy, headerY, "Accuracy", { fontSize: '14px', color: '#888888' }).setDepth(1);

    // Header underline
    const line = this.add.graphics();
    line.lineStyle(1, 0x555555);
    line.lineBetween(80, headerY + 22, 720, headerY + 22);
    line.setDepth(1);

    // Player stats rows
    let yOffset = headerY + 35;
    Object.entries(stats).forEach(([sessionId, playerStats]: [string, any]) => {
      const isLocal = sessionId === localSessionId;
      const color = isLocal ? '#ffff00' : '#ffffff';
      const style = { fontSize: '16px', color, fontStyle: isLocal ? 'bold' : 'normal' };

      // Highlight row for local player
      if (isLocal) {
        this.add.rectangle(400, yOffset + 8, 640, 28, 0x333333, 0.5).setDepth(1);
      }

      // Player name (truncate)
      const displayName = playerStats.name.length > 12
        ? playerStats.name.substring(0, 10) + ".."
        : playerStats.name;
      this.add.text(cols.name, yOffset, displayName, style).setDepth(2);

      // Role
      const roleLabel = playerStats.role === 'paran' ? 'Paran' :
                         playerStats.role === 'faran' ? 'Faran' : 'Baran';
      this.add.text(cols.role, yOffset, roleLabel, style).setDepth(2);

      // K/D/Damage/Accuracy
      this.add.text(cols.kills, yOffset, String(playerStats.kills), style).setDepth(2);
      this.add.text(cols.deaths, yOffset, String(playerStats.deaths), style).setDepth(2);
      this.add.text(cols.damage, yOffset, String(playerStats.damageDealt), style).setDepth(2);
      this.add.text(cols.accuracy, yOffset, `${playerStats.accuracy.toFixed(1)}%`, style).setDepth(2);

      yOffset += 35;
    });

    // Return to Lobby button
    const button = this.add.text(400, 500, "Return to Lobby", {
      fontSize: '24px',
      color: '#ffffff',
      backgroundColor: '#0066cc',
      padding: { x: 24, y: 12 }
    })
      .setOrigin(0.5)
      .setInteractive({ useHandCursor: true })
      .setDepth(2);

    button.on('pointerover', () => button.setBackgroundColor('#0088ff'));
    button.on('pointerout', () => button.setBackgroundColor('#0066cc'));
    button.on('pointerdown', () => this.returnToLobby(room));
  }

  private returnToLobby(room: any) {
    // Disconnect from room if still connected
    if (room) {
      try { room.leave(); } catch (e) { /* already disconnected */ }
    }

    // Stop victory overlay and game scene
    this.scene.stop('VictoryScene');
    this.scene.stop('GameScene');

    // Return to boot scene (will be replaced with proper lobby in Phase 5)
    this.scene.start('BootScene');
  }
}
```

**2. Register VictoryScene in Phaser config (client/src/main.ts):**

Add VictoryScene import and include in scene array:
```typescript
import { VictoryScene } from './scenes/VictoryScene';

// In config.scene array:
scene: [BootScene, GameScene, VictoryScene],
```

**DESIGN NOTES:**
- VictoryScene uses `scene.launch()` (overlay, not replace) so GameScene stays visible underneath with 0.85 opacity background
- Stats are received from matchEnd broadcast message (not read from Schema) to avoid pitfall 5 (stale stats)
- Room reference passed via scene data for clean disconnect
- Returns to BootScene for now; Phase 5 will add proper lobby
- Duration displayed as M:SS format
- Local player row highlighted yellow for quick identification
  </action>
  <verify>
1. Run `cd /Users/jonasbrandvik/Projects/banger-game/client && npx tsc --noEmit` — compiles without errors
2. Start both server and client, open 3 tabs, wait for match start, kill one player to verify no crashes
  </verify>
  <done>VictoryScene created with stats table (kills, deaths, damage, accuracy), winner announcement, match duration, local player highlighting, and Return to Lobby button. VictoryScene registered in Phaser config. GameScene spectator mode working with Tab-cycling camera.</done>
</task>

</tasks>

<verification>
1. TypeScript compiles for both client and server
2. VictoryScene appears as overlay when match ends (all guardians or Paran eliminated)
3. Victory/defeat title correct based on local player's team
4. Stats table shows kills, deaths, damage, accuracy for all 3 players
5. Local player row highlighted in yellow
6. Eliminated player enters spectator mode (Tab to cycle camera)
7. Status text shows "SPECTATING" when dead
8. Return to Lobby button disconnects and returns to BootScene
9. Match duration displayed correctly
</verification>

<success_criteria>
- VictoryScene displays on match end with winner and per-player stats
- Spectator mode works for eliminated players (Tab cycles camera targets)
- Return to Lobby button disconnects and returns to BootScene
- No crashes when players die, disconnect, or match ends
- Client TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/04-match-lifecycle-maps/04-02-SUMMARY.md`
</output>
