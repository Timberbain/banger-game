---
phase: 05-multiplayer-lobbies
plan: 10
type: execute
wave: 1
depends_on: []
files_modified:
  - client/src/scenes/GameScene.ts
  - server/src/rooms/GameRoom.ts
  - server/src/index.ts
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "All 3 players enter game with responsive controls after lobby transition (no stale PredictionSystem)"
    - "All players see consistent status text driven by single matchState listener"
    - "Browser refresh reconnection does NOT crash the server or disrupt other players"
  artifacts:
    - path: "client/src/scenes/GameScene.ts"
      provides: "Scene reuse safety via member variable reset in create() + unified status text"
      contains: "this.room = null"
    - path: "server/src/rooms/GameRoom.ts"
      provides: "Crash protection via onUncaughtException handler"
      contains: "onUncaughtException"
    - path: "server/src/index.ts"
      provides: "Process-level error safety net"
      contains: "uncaughtException"
  key_links:
    - from: "client/src/scenes/GameScene.ts"
      to: "PredictionSystem"
      via: "create() reset block ensures fresh prediction on each scene start"
      pattern: "this\\.prediction = null"
    - from: "server/src/rooms/GameRoom.ts"
      to: "Colyseus framework"
      via: "onUncaughtException enables framework try/catch wrapping"
      pattern: "onUncaughtException"
---

<objective>
Fix two major UAT v3 gaps: (1) intermittent Baran controls and inconsistent status text caused by Phaser scene reuse not resetting member variables, and (2) game reconnect disrupting OTHER players caused by missing error handling on GameRoom.

Purpose: These are the two highest-severity bugs remaining in Phase 5. Gap 1 makes the game unplayable for one player intermittently. Gap 3 causes cascading failures for all connected players.
Output: GameScene.ts with proper scene reuse reset, unified status text. GameRoom.ts with onUncaughtException. index.ts with process-level safety net.
</objective>

<execution_context>
@.claude/get-shit-done/workflows/execute-plan.md
@.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-multiplayer-lobbies/05-09-SUMMARY.md
@client/src/scenes/GameScene.ts
@server/src/rooms/GameRoom.ts
@server/src/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Reset GameScene member variables on create() and unify status text</name>
  <files>client/src/scenes/GameScene.ts</files>
  <action>
  Two bugs in GameScene.ts caused by Phaser scene reuse (scene.start() does NOT re-run the constructor):

  **Bug A: Stale member variables on scene re-entry**

  At the TOP of create(), before anything else (before keyboard setup), add a reset block that explicitly reinitializes ALL mutable member variables to their constructor defaults:

  ```
  // Reset all mutable state for scene reuse (Phaser scene.start() skips constructor)
  this.room = null;
  this.connected = false;
  this.prediction = null;
  this.interpolation = new InterpolationSystem();
  this.remotePlayers = new Set();
  this.playerSprites = new Map();
  this.playerLabels = new Map();
  this.projectileSprites = new Map();
  this.projectileVelocities = new Map();
  this.healthBars = new Map();
  this.eliminatedTexts = new Map();
  this.dcLabels = new Map();
  this.directionPressOrder = [];
  this.prevKeyState = { left: false, right: false, up: false, down: false };
  this.localRole = '';
  this.spectatorTarget = null;
  this.isSpectating = false;
  this.matchEnded = false;
  this.finalStats = null;
  this.matchWinner = "";
  ```

  This ensures Baran (or any player) gets a fresh PredictionSystem on the second match instead of a stale one from the previous match.

  **Bug B: Three competing statusText writers**

  Currently there are 3 places that write status text, creating race conditions:
  1. Lines ~102-109: Initial sync check after connect (checks matchState synchronously)
  2. Lines ~142-149: listen("matchState") with immediate=true (fires on initial sync AND changes)
  3. Lines ~203-207: onAdd player count update (guard prevents showing 3/3)

  Fix: Make listen("matchState") the SOLE source of truth for status text. Remove the initial sync check (lines ~102-109). For the onAdd handler, remove the statusText write entirely -- onAdd should NOT touch status text since matchState listener handles all states.

  Replace the initial sync check block (lines ~100-109) with just:
  ```
  this.connected = true;
  ```

  Update the matchState listener to handle ALL states:
  ```
  this.room.state.listen("matchState", (value: string) => {
    if (this.matchEnded) return;
    if (value === 'playing') {
      this.statusText.setText('Match started!');
      this.time.delayedCall(2000, () => {
        if (!this.matchEnded) this.statusText.setVisible(false);
      });
    } else if (value === 'waiting') {
      const count = this.room ? this.room.state.players.size : 0;
      this.statusText.setText(`Waiting for players... (${count}/3)`);
      this.statusText.setVisible(true);
    }
  });
  ```

  In the onAdd handler (lines ~197-208), REMOVE the statusText.setText lines entirely. Only keep the player visual creation and onChange registration. The player count is already reflected by the matchState listener -- when 3 players join, matchState changes to 'playing' which the listener handles.

  Apply the SAME unified pattern to attachRoomListeners() -- single matchState listener as source of truth, no redundant matchStart handler for status text. Keep the matchStart message handler ONLY for backward compatibility but do NOT have it write to statusText (it's already handled by the Schema listener).

  In attachRoomListeners(), simplify the matchStart handler to just log:
  ```
  this.room.onMessage("matchStart", () => {
    console.log('matchStart received (handled by Schema listener)');
  });
  ```
  </action>
  <verify>
  Run `cd /Users/jonasbrandvik/Projects/banger-game/client && npx tsc --noEmit` -- must pass with no errors.
  Grep for "this.room = null" in create() to confirm reset block exists.
  Grep to confirm NO statusText.setText calls remain in the onAdd handler.
  Count occurrences of statusText.setText -- should be in matchState listener only (2 places: create() and attachRoomListeners()), plus the reconnection-related ones (handleReconnection, returnToLobby, spectating).
  </verify>
  <done>
  GameScene.ts create() starts with full member variable reset block. Status text is driven solely by matchState Schema listener. No competing writers in onAdd or initial sync check. All 3 players entering game get fresh state and see consistent "Match started!" text.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add onUncaughtException to GameRoom and process-level error handlers</name>
  <files>server/src/rooms/GameRoom.ts, server/src/index.ts</files>
  <action>
  **Root cause:** In Colyseus 0.15, the framework only wraps setSimulationInterval, clock callbacks, and onMessage callbacks in try/catch when the room defines onUncaughtException. Without it, any unhandled error during reconnection propagates to Node.js event loop, crashing the ts-node-dev process and killing ALL WebSocket connections for ALL clients.

  **Fix A: GameRoom.ts -- Add onUncaughtException handler**

  Add this method to the GameRoom class (after onDispose):

  ```typescript
  onUncaughtException(err: Error, methodName: string) {
    console.error(`[GameRoom] Uncaught exception in ${methodName}:`, err.message);
    console.error(err.stack);
    // Do NOT rethrow -- let the room continue running for other players
    // Only dispose if the error is truly unrecoverable
  }
  ```

  **Fix B: GameRoom.ts -- Add defensive checks in onLeave reconnection path**

  In the onLeave method, after `await this.allowReconnection(client, ...)` succeeds (the "Successfully reconnected" path around line 238), add defensive validation:

  ```typescript
  // Successfully reconnected -- validate player still exists
  const reconnectedPlayer = this.state.players.get(client.sessionId);
  if (!reconnectedPlayer) {
    console.warn(`Player ${client.sessionId} reconnected but player object was removed`);
    return;
  }
  reconnectedPlayer.connected = true;
  reconnectedPlayer.inputQueue = [];
  ```

  Replace the current bare `player.connected = true` with this defensive version that re-fetches from state.

  **Fix C: server/src/index.ts -- Add process-level error handlers**

  BEFORE the `httpServer.listen()` call, add:

  ```typescript
  // Process-level error safety net -- prevent unhandled errors from crashing server
  process.on('uncaughtException', (err) => {
    console.error('[FATAL] Uncaught exception:', err.message);
    console.error(err.stack);
    // Log but don't exit -- Colyseus rooms should handle their own errors
  });

  process.on('unhandledRejection', (reason, promise) => {
    console.error('[FATAL] Unhandled rejection at:', promise, 'reason:', reason);
    // Log but don't exit
  });
  ```

  This ensures that even if something slips past onUncaughtException, the process stays alive.
  </action>
  <verify>
  Run `cd /Users/jonasbrandvik/Projects/banger-game/server && npx tsc --noEmit` -- must pass with no errors.
  Grep for "onUncaughtException" in GameRoom.ts -- must find the method definition.
  Grep for "uncaughtException" in index.ts -- must find process.on handler.
  Grep for "unhandledRejection" in index.ts -- must find process.on handler.
  Grep for "reconnectedPlayer" in GameRoom.ts -- must find defensive check.
  </verify>
  <done>
  GameRoom has onUncaughtException handler enabling Colyseus framework try/catch wrapping. Reconnection path has defensive player validation. Server entry point has process-level error handlers. A reconnecting player's error cannot crash the server or disrupt other connected players.
  </done>
</task>

</tasks>

<verification>
1. `cd /Users/jonasbrandvik/Projects/banger-game/client && npx tsc --noEmit` passes
2. `cd /Users/jonasbrandvik/Projects/banger-game/server && npx tsc --noEmit` passes
3. GameScene.ts create() has reset block as first operation
4. GameScene.ts has single matchState listener as status text source of truth
5. GameRoom.ts has onUncaughtException method
6. index.ts has process.on('uncaughtException') and process.on('unhandledRejection')
</verification>

<success_criteria>
- Scene reuse is safe: all member variables reset in create() before use
- Status text is consistent: single matchState Schema listener drives all status display
- Server is crash-resistant: onUncaughtException + process-level handlers prevent cascading failures
- Reconnection is safe: defensive player validation in onLeave success path
</success_criteria>

<output>
After completion, create `.planning/phases/05-multiplayer-lobbies/05-10-SUMMARY.md`
</output>
