---
phase: 05-multiplayer-lobbies
plan: 06
type: execute
wave: 1
depends_on: []
files_modified:
  - server/src/rooms/MatchmakingRoom.ts
  - server/src/index.ts
  - client/src/scenes/LobbyScene.ts
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Matchmaking shows animated searching message while waiting for other players"
    - "Players wait in a holding room until 3 matching players found"
    - "When match formed, all 3 players transition to a lobby together"
  artifacts:
    - path: "server/src/rooms/MatchmakingRoom.ts"
      provides: "Dedicated waiting room where players queue by role"
      contains: "class MatchmakingRoom"
    - path: "server/src/index.ts"
      provides: "MatchmakingRoom registration"
      contains: "matchmaking_room"
    - path: "client/src/scenes/LobbyScene.ts"
      provides: "Client matchmaking flow with waiting UI"
      contains: "matchmaking_room"
  key_links:
    - from: "client/src/scenes/LobbyScene.ts"
      to: "server/src/rooms/MatchmakingRoom.ts"
      via: "client.joinOrCreate('matchmaking_room') and matchFound message"
      pattern: "joinOrCreate.*matchmaking_room"
    - from: "server/src/rooms/MatchmakingRoom.ts"
      to: "server/src/rooms/LobbyRoom.ts"
      via: "matchMaker.createRoom creates lobby, broadcast tells clients to join"
      pattern: "createRoom.*lobby_room"
---

<objective>
Implement working matchmaking flow with a dedicated MatchmakingRoom where players wait until a full match (1 paran + 2 guardians) is formed.

Purpose: Currently, clicking "Find Match" calls joinOrCreate('lobby_room') which resolves immediately, creating/joining a lobby instead of queuing. The matchmaking pipeline needs a separate room where players wait with an animated "Searching..." UI until enough players queue.

Output: Players enter a MatchmakingRoom, see animated searching message, and are moved to a lobby together when 3 matching players are found.
</objective>

<execution_context>
@/Users/jonasbrandvik/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jonasbrandvik/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-multiplayer-lobbies/05-01-SUMMARY.md
@.planning/phases/05-multiplayer-lobbies/05-UAT.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create MatchmakingRoom server-side and register it</name>
  <files>server/src/rooms/MatchmakingRoom.ts, server/src/index.ts</files>
  <action>
**Create `server/src/rooms/MatchmakingRoom.ts`** -- a dedicated Colyseus Room where players wait for matchmaking.

Design: This is a single shared room (filterBy: "matchmaking" so all players join the same instance). Players join with `{ preferredRole }`. The room tracks players by role (paran queue vs guardian queue). Every second, it checks if 1 paran + 2 guardians are available. When a match forms, it creates a LobbyRoom and broadcasts the lobby roomId to the matched players.

```typescript
import { Room, Client, matchMaker } from "colyseus";
import { Schema, type, MapSchema } from "@colyseus/schema";
import { VALID_ROLES } from "../../../shared/lobby";

export class QueuePlayer extends Schema {
  @type("string") preferredRole: string = "";
  @type("string") name: string = "";
}

export class MatchmakingState extends Schema {
  @type({ map: QueuePlayer }) players = new MapSchema<QueuePlayer>();
  @type("number") paranCount: number = 0;
  @type("number") guardianCount: number = 0;
}

export class MatchmakingRoom extends Room<MatchmakingState> {
  maxClients = 50; // Allow many players to queue

  private matchCheckInterval?: any;

  onCreate(options: any) {
    this.setState(new MatchmakingState());

    // Check for matches every second
    this.matchCheckInterval = this.clock.setInterval(() => {
      this.tryFormMatch();
    }, 1000);

    console.log("MatchmakingRoom created");
  }

  onJoin(client: Client, options?: any) {
    const player = new QueuePlayer();
    player.preferredRole = options?.preferredRole || "faran";
    player.name = options?.name || client.sessionId.substring(0, 20);

    // Validate role
    if (!VALID_ROLES.includes(player.preferredRole as any)) {
      player.preferredRole = "faran";
    }

    this.state.players.set(client.sessionId, player);
    this.updateCounts();

    console.log(`Player joined matchmaking: ${client.sessionId} as ${player.preferredRole}`);
  }

  onLeave(client: Client) {
    this.state.players.delete(client.sessionId);
    this.updateCounts();
    console.log(`Player left matchmaking: ${client.sessionId}`);
  }

  private updateCounts() {
    let paranCount = 0;
    let guardianCount = 0;
    this.state.players.forEach((player) => {
      if (player.preferredRole === "paran") {
        paranCount++;
      } else {
        guardianCount++;
      }
    });
    this.state.paranCount = paranCount;
    this.state.guardianCount = guardianCount;
  }

  private async tryFormMatch() {
    // Collect players by role
    const paranPlayers: string[] = [];
    const guardianPlayers: string[] = [];

    this.state.players.forEach((player, sessionId) => {
      if (player.preferredRole === "paran") {
        paranPlayers.push(sessionId);
      } else {
        guardianPlayers.push(sessionId);
      }
    });

    // Need 1 paran + 2 guardians
    if (paranPlayers.length >= 1 && guardianPlayers.length >= 2) {
      const matchedParan = paranPlayers[0];
      const matchedGuardians = [guardianPlayers[0], guardianPlayers[1]];
      const matchedIds = [matchedParan, ...matchedGuardians];

      // Build role assignments
      const roleAssignments: Record<string, string> = {};
      const paranPlayer = this.state.players.get(matchedParan);
      roleAssignments[matchedParan] = "paran";

      // Assign guardian roles: first guardian = faran, second = baran
      const g1Player = this.state.players.get(matchedGuardians[0]);
      const g2Player = this.state.players.get(matchedGuardians[1]);
      roleAssignments[matchedGuardians[0]] = g1Player?.preferredRole === "baran" ? "baran" : "faran";
      roleAssignments[matchedGuardians[1]] = roleAssignments[matchedGuardians[0]] === "faran" ? "baran" : "faran";

      try {
        // Create a lobby room for the matched players
        const lobbyRoom = await matchMaker.createRoom("lobby_room", {
          fromMatchmaking: true
        });

        console.log(`Match formed! Lobby: ${lobbyRoom.roomId}, Players: ${matchedIds.join(", ")}`);

        // Notify matched players with the lobby roomId and their assigned roles
        matchedIds.forEach(sessionId => {
          const client = this.clients.find(c => c.sessionId === sessionId);
          if (client) {
            client.send("matchFound", {
              lobbyRoomId: lobbyRoom.roomId,
              assignedRole: roleAssignments[sessionId]
            });
          }
        });

        // Remove matched players from queue
        matchedIds.forEach(sessionId => {
          this.state.players.delete(sessionId);
        });
        this.updateCounts();

      } catch (error) {
        console.error("Failed to create lobby for match:", error);
      }
    }
  }

  onDispose() {
    if (this.matchCheckInterval) {
      this.matchCheckInterval.clear();
    }
    console.log("MatchmakingRoom disposed");
  }
}
```

**Register in `server/src/index.ts`:** Add the MatchmakingRoom import and registration:
```typescript
import { MatchmakingRoom } from "./rooms/MatchmakingRoom";
```

After the lobby_room definition, add:
```typescript
gameServer.define("matchmaking_room", MatchmakingRoom).filterBy(["matchmaking"]);
```

Wait -- actually, since we want ALL matchmaking players in the SAME room instance, do NOT use filterBy. Instead, ensure only one instance exists by having the client use `joinOrCreate` (which joins existing before creating). Alternatively, we can keep it simple: just register without filterBy, and since clients all call `joinOrCreate("matchmaking_room")`, they will all join the same room (Colyseus joins existing available rooms first).

Register as:
```typescript
gameServer.define("matchmaking_room", MatchmakingRoom);
```

Place it between the lobby_room and game_room definitions.

Run `cd /Users/jonasbrandvik/Projects/banger-game/server && npx tsc --noEmit` to verify.
  </action>
  <verify>
Run `cd /Users/jonasbrandvik/Projects/banger-game/server && npx tsc --noEmit` -- must pass.
Check that `server/src/rooms/MatchmakingRoom.ts` exists.
Check that `server/src/index.ts` contains `matchmaking_room` registration.
  </verify>
  <done>
MatchmakingRoom created and registered. Players join a shared room, wait in queue, and get notified with lobby roomId when match is formed (1 paran + 2 guardians).
  </done>
</task>

<task type="auto">
  <name>Task 2: Update client matchmaking flow to use MatchmakingRoom</name>
  <files>client/src/scenes/LobbyScene.ts</files>
  <action>
**Root cause:** The `joinMatchmaking()` method (line 363) calls `this.client.joinOrCreate('lobby_room', { matchmaking: true, ... })` which resolves immediately -- creating or joining a lobby room. The animated "Searching..." text gets replaced within milliseconds. There is no actual waiting/queueing.

**Fix:** Replace the `joinMatchmaking()` method to:
1. Join a `matchmaking_room` instead of `lobby_room`
2. Show animated "Searching..." UI while waiting
3. Listen for `matchFound` message from server
4. When matchFound received, leave matchmaking room and join the lobby

Replace the entire `joinMatchmaking()` method (lines 343-380):

```typescript
private async joinMatchmaking(preferredRole: string) {
  this.clearUI();

  // Background
  const bg = this.add.rectangle(400, 300, 800, 600, 0x1a1a2e);
  this.uiElements.push(bg);

  const statusText = this.add.text(400, 280, 'Searching for match...', {
    fontSize: '22px',
    color: '#ffff00'
  }).setOrigin(0.5);
  this.uiElements.push(statusText);

  // Add spinner animation
  let dots = 0;
  const spinnerInterval = this.time.addEvent({
    delay: 500,
    callback: () => {
      dots = (dots + 1) % 4;
      statusText.setText('Searching for match' + '.'.repeat(dots));
    },
    loop: true
  });

  // Queue size display
  const queueText = this.add.text(400, 330, '', {
    fontSize: '16px',
    color: '#aaaaaa'
  }).setOrigin(0.5);
  this.uiElements.push(queueText);

  // Cancel button
  const cancelButton = this.add.text(400, 420, 'Cancel', {
    fontSize: '20px',
    color: '#ffffff',
    backgroundColor: '#aa0000',
    padding: { x: 24, y: 10 }
  })
    .setOrigin(0.5)
    .setInteractive({ useHandCursor: true });

  cancelButton.on('pointerdown', () => {
    spinnerInterval.destroy();
    if (this.room) {
      this.room.leave();
      this.room = null;
    }
    this.showMainMenu();
  });
  this.uiElements.push(cancelButton);

  try {
    // Join the matchmaking room (shared instance for all queuing players)
    const matchmakingRoom = await this.client.joinOrCreate('matchmaking_room', {
      preferredRole,
      name: this.playerName
    });

    // Track queue sizes from state
    matchmakingRoom.state.listen('paranCount', (value: number) => {
      const guardianCount = matchmakingRoom.state.guardianCount || 0;
      queueText.setText(`In queue: ${value} Paran, ${guardianCount} Guardian`);
    });
    matchmakingRoom.state.listen('guardianCount', (value: number) => {
      const paranCount = matchmakingRoom.state.paranCount || 0;
      queueText.setText(`In queue: ${paranCount} Paran, ${value} Guardian`);
    });

    // Listen for match found
    matchmakingRoom.onMessage('matchFound', async (data: { lobbyRoomId: string; assignedRole: string }) => {
      console.log('Match found! Joining lobby:', data.lobbyRoomId);
      spinnerInterval.destroy();

      // Leave matchmaking room
      matchmakingRoom.leave();

      // Show transition message
      this.clearUI();
      const transitionBg = this.add.rectangle(400, 300, 800, 600, 0x1a1a2e);
      this.uiElements.push(transitionBg);
      const transitionText = this.add.text(400, 300, 'Match found! Joining lobby...', {
        fontSize: '22px',
        color: '#00ff00'
      }).setOrigin(0.5);
      this.uiElements.push(transitionText);

      try {
        // Join the lobby that matchmaking created
        this.room = await this.client.joinById(data.lobbyRoomId, {
          name: this.playerName,
          fromMatchmaking: true,
          preferredRole: data.assignedRole
        });

        // Pre-select the assigned role
        this.selectedRole = data.assignedRole;

        console.log('Joined matchmaking lobby:', this.room.id);
        this.showLobbyView();
      } catch (e) {
        console.error('Failed to join matchmaking lobby:', e);
        this.clearUI();
        const errBg = this.add.rectangle(400, 300, 800, 600, 0x1a1a2e);
        this.uiElements.push(errBg);
        const errText = this.add.text(400, 300, 'Failed to join lobby', {
          fontSize: '22px',
          color: '#ff0000'
        }).setOrigin(0.5);
        this.uiElements.push(errText);
        this.time.delayedCall(3000, () => this.showMainMenu());
      }
    });

    // Update cancel to also leave matchmaking room
    cancelButton.removeAllListeners('pointerdown');
    cancelButton.on('pointerdown', () => {
      spinnerInterval.destroy();
      matchmakingRoom.leave();
      this.showMainMenu();
    });

  } catch (e) {
    console.error('Failed to join matchmaking:', e);
    spinnerInterval.destroy();
    statusText.setText('Failed to join matchmaking');
    statusText.setColor('#ff0000');
    this.time.delayedCall(3000, () => this.showMainMenu());
  }
}
```

Key changes:
- Joins `matchmaking_room` instead of `lobby_room`
- Does NOT store matchmaking room as `this.room` (that is reserved for the lobby room)
- Shows queue sizes from MatchmakingState (paranCount, guardianCount)
- Listens for `matchFound` message with lobbyRoomId and assignedRole
- On match found: leaves matchmaking, joins the lobby, pre-selects assigned role
- Cancel button leaves matchmaking room and returns to menu

Also, after joining the lobby from matchmaking, the player should auto-select their assigned role. Add a small delay then send selectRole:

After `this.showLobbyView();` in the matchFound handler, add:
```typescript
// Auto-select assigned role after lobby view loads
this.time.delayedCall(500, () => {
  if (this.room && data.assignedRole) {
    this.room.send('selectRole', { role: data.assignedRole });
  }
});
```

Run `cd /Users/jonasbrandvik/Projects/banger-game/client && npx tsc --noEmit` to verify.
  </action>
  <verify>
Run `cd /Users/jonasbrandvik/Projects/banger-game/client && npx tsc --noEmit` -- must pass.
Grep for `matchmaking_room` in LobbyScene.ts -- must find it.
Grep for `matchFound` in LobbyScene.ts -- must find the message handler.
Grep for `joinOrCreate.*lobby_room.*matchmaking` in LobbyScene.ts -- must NOT find it (old pattern removed).
  </verify>
  <done>
Client matchmaking flow uses dedicated MatchmakingRoom. Players see animated "Searching..." with queue counts, and are transitioned to a lobby when match is formed.
  </done>
</task>

</tasks>

<verification>
1. MatchmakingRoom server file exists and compiles
2. matchmaking_room registered in server index
3. Client joins matchmaking_room (not lobby_room) for "Find Match"
4. Client shows animated searching UI with queue counts
5. matchFound message triggers lobby join with assigned role
6. Cancel button properly leaves matchmaking room
7. Both server and client compile without errors
</verification>

<success_criteria>
- "Find Match" button joins matchmaking_room and shows animated searching UI
- Queue size displayed to player while waiting
- When 1 paran + 2 guardians queue, match forms and players join lobby together
- Cancel button returns to menu
- Server and client TypeScript compile cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/05-multiplayer-lobbies/05-06-SUMMARY.md`
</output>
