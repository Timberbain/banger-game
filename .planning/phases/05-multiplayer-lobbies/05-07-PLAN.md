---
phase: 05-multiplayer-lobbies
plan: 07
type: execute
wave: 2
depends_on: ["05-04"]
files_modified:
  - server/src/rooms/GameRoom.ts
  - client/src/scenes/GameScene.ts
  - client/src/scenes/LobbyScene.ts
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Disconnected player shown ghosted (30% opacity) with DC label, frozen in place"
    - "Browser refresh during active match auto-reconnects to game at previous position"
    - "DC label and eliminated label tracked separately (no collision)"
  artifacts:
    - path: "server/src/rooms/GameRoom.ts"
      provides: "Consented leave deferred deletion for disconnect rendering"
      contains: "setTimeout.*delete"
    - path: "client/src/scenes/GameScene.ts"
      provides: "Full state listener re-registration on reconnect, separate DC label map"
      contains: "dcLabels"
    - path: "client/src/scenes/LobbyScene.ts"
      provides: "Reconnection retry logic with delay"
      contains: "reconnectAttempts"
  key_links:
    - from: "server/src/rooms/GameRoom.ts"
      to: "client/src/scenes/GameScene.ts"
      via: "player.connected=false synced via Schema, client renders ghost+DC"
      pattern: "connected.*false"
    - from: "client/src/scenes/LobbyScene.ts"
      to: "server/src/rooms/GameRoom.ts"
      via: "client.reconnect(token) with retry after server processes WebSocket close"
      pattern: "reconnect.*token"
    - from: "client/src/scenes/GameScene.ts"
      to: "server/src/rooms/GameRoom.ts"
      via: "attachRoomListeners re-registers all Schema callbacks after reconnect"
      pattern: "attachRoomListeners.*players\\.onAdd"
---

<objective>
Fix reconnection failures and disconnected player ghosting: two related issues around the disconnect/reconnect lifecycle.

Purpose: Disconnected players are instantly removed from screen instead of being ghosted. Browser refresh fails to reconnect because of race conditions and missing state listeners after reconnect. These issues make the reconnection feature non-functional.

Output: Disconnected players appear ghosted with DC label; browser refresh successfully reconnects within grace period; reconnected clients have full state synchronization.
</objective>

<execution_context>
@/Users/jonasbrandvik/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jonasbrandvik/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-multiplayer-lobbies/05-03-SUMMARY.md
@.planning/phases/05-multiplayer-lobbies/05-UAT.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix disconnect ghosting (server + client)</name>
  <files>server/src/rooms/GameRoom.ts, client/src/scenes/GameScene.ts</files>
  <action>
**Three issues to fix:**

**Issue 1: Consented leave deletes player immediately in same sync patch (GameRoom.ts lines 196-205)**

When a player intentionally leaves during a match, the server sets `player.connected = false` (line 193) then immediately calls `this.state.players.delete(client.sessionId)` (line 198) in the same code path. Both changes batch into the same Colyseus patch. The client receives onRemove, which destroys all sprites, before the connected=false change can be rendered as ghosting.

For consented leaves during PLAYING state, defer the deletion by 2 seconds so the disconnect visual (ghosted + DC) shows before removal:

Replace the consented leave handling (lines 196-206):
```typescript
if (consented) {
  console.log(`Player left (consented): ${client.sessionId}`);

  if (this.state.matchState === MatchState.PLAYING) {
    // During active match: show disconnect state briefly before removing
    // This gives clients time to render the ghosted state
    this.clock.setTimeout(() => {
      this.state.players.delete(client.sessionId);
      this.checkWinConditions();
    }, 2000);
  } else {
    // Not in active match: remove immediately
    this.state.players.delete(client.sessionId);
  }
  return;
}
```

This way, for consented leaves during match: connected=false syncs first, client renders ghost, then 2s later the player is deleted.

**Issue 2: DC label shares eliminatedTexts map (GameScene.ts line 257-272)**

The DC label and ELIMINATED label both use `this.eliminatedTexts` map. When a DC label exists and the player dies, the condition `!this.eliminatedTexts.has(sessionId)` is true for ELIMINATED but blocked because DC already stored there. Conversely, when removing DC labels on reconnect, it may remove an ELIMINATED label.

Create a separate `dcLabels` map. Add a new class property near line 39:
```typescript
private dcLabels: Map<string, Phaser.GameObjects.Text> = new Map();
```

In the `player.onChange()` callback (around lines 251-308), update the disconnect rendering:

Replace the `!player.connected` block (lines 251-273) to use dcLabels:
```typescript
// Handle disconnected state
if (!player.connected && player.health > 0) {
  const sprite = this.playerSprites.get(sessionId);
  if (sprite) {
    sprite.setAlpha(0.3);
  }
  // Show DC label if not already shown
  if (!this.dcLabels.has(sessionId)) {
    const dcText = this.add.text(
      player.x,
      player.y + 30,
      'DC',
      {
        fontSize: '12px',
        color: '#ffaa00',
        fontStyle: 'bold',
        backgroundColor: '#000000',
        padding: { x: 4, y: 2 }
      }
    );
    dcText.setOrigin(0.5);
    dcText.setDepth(12);
    this.dcLabels.set(sessionId, dcText);
  }
} else if (player.health <= 0) {
  // Dead state
  const sprite = this.playerSprites.get(sessionId);
  if (sprite) {
    sprite.setAlpha(0.3);
  }
  // Remove DC label if they died while disconnected
  const dcLabel = this.dcLabels.get(sessionId);
  if (dcLabel) {
    dcLabel.destroy();
    this.dcLabels.delete(sessionId);
  }
  // Show ELIMINATED text
  if (!this.eliminatedTexts.has(sessionId)) {
    const eliminatedText = this.add.text(
      player.x,
      player.y - 40,
      'ELIMINATED',
      {
        fontSize: '14px',
        color: '#ff0000',
        fontStyle: 'bold',
      }
    );
    eliminatedText.setOrigin(0.5);
    eliminatedText.setDepth(12);
    this.eliminatedTexts.set(sessionId, eliminatedText);
  }
} else {
  // Alive and connected - ensure sprite is opaque
  const sprite = this.playerSprites.get(sessionId);
  if (sprite) {
    sprite.setAlpha(1.0);
  }
  // Remove DC label if player reconnected
  const dcLabel = this.dcLabels.get(sessionId);
  if (dcLabel) {
    dcLabel.destroy();
    this.dcLabels.delete(sessionId);
  }
  // Remove eliminated text if it exists (shouldn't happen but defensive)
  const eliminatedText = this.eliminatedTexts.get(sessionId);
  if (eliminatedText) {
    eliminatedText.destroy();
    this.eliminatedTexts.delete(sessionId);
  }
}
```

Also update the `onRemove` callback (around lines 364-398) to clean up dcLabels:
```typescript
// Add after the existing eliminatedText cleanup:
const dcLabel = this.dcLabels.get(sessionId);
if (dcLabel) {
  dcLabel.destroy();
  this.dcLabels.delete(sessionId);
}
```

Also update the health bar / label position update loop in `update()` (around lines 571-584) to also update dcLabel positions:
```typescript
// After the eliminatedText position update:
const dcLabel = this.dcLabels.get(sessionId);
if (dcLabel) {
  dcLabel.x = sprite.x;
  dcLabel.y = sprite.y + 30;
}
```

**Issue 3: Verify onChange fires for connected=false on non-consented disconnect**

For non-consented disconnects, the server sets `player.connected = false` (line 193) before calling `allowReconnection`. This should sync to clients via Schema in the next patch. The client's `player.onChange()` should then fire and render the ghost. Verify this path is correct by ensuring the `connected` check runs before the `health <= 0` check in the onChange callback (which it now does with the rewritten block above).

Run `cd /Users/jonasbrandvik/Projects/banger-game/server && npx tsc --noEmit && cd /Users/jonasbrandvik/Projects/banger-game/client && npx tsc --noEmit` to verify both compile.
  </action>
  <verify>
Run server and client TypeScript compilation -- both must pass.
Grep for `dcLabels` in GameScene.ts -- must find class property and usage.
Grep for `setTimeout.*delete` in GameRoom.ts -- must find deferred deletion for consented leaves.
Grep for `this.eliminatedTexts` usage in the `!player.connected` block of GameScene.ts -- must NOT find it (DC uses dcLabels now).
  </verify>
  <done>
Disconnected players render at 30% opacity with yellow "DC" label using separate dcLabels map. Consented leaves during match defer deletion by 2s so ghost renders before removal. DC and ELIMINATED labels tracked independently.
  </done>
</task>

<task type="auto">
  <name>Task 2: Fix reconnection (retry logic + full state listener re-registration)</name>
  <files>client/src/scenes/LobbyScene.ts, client/src/scenes/GameScene.ts</files>
  <action>
**Two reconnection issues:**

**Issue 1: Race condition on F5 (LobbyScene.ts checkReconnection)**

When the user presses F5, the browser disconnects the WebSocket. The server processes this asynchronously. If the client reconnects before the server has processed the WebSocket close event and registered the reconnection token in the `_reconnections` map, the reconnect call fails.

Add retry logic to `checkReconnection()` in LobbyScene.ts. Replace the single reconnect attempt (line 68) with a retry loop:

Replace the reconnection attempt section in `checkReconnection()` (around lines 67-80):
```typescript
// Attempt reconnection with retries (server may not have processed disconnect yet)
const MAX_RETRIES = 3;
const RETRY_DELAY = 800; // ms

let reconnectedRoom: Room | null = null;

for (let attempt = 1; attempt <= MAX_RETRIES; attempt++) {
  try {
    reconnectedRoom = await this.client.reconnect(token);
    console.log(`Successfully reconnected on attempt ${attempt}`);
    break;
  } catch (e) {
    console.log(`Reconnection attempt ${attempt}/${MAX_RETRIES} failed:`, e);
    if (attempt < MAX_RETRIES) {
      // Wait before retrying -- gives server time to process disconnect
      await new Promise(resolve => setTimeout(resolve, RETRY_DELAY));
      text.setText(`Reconnecting to match... (attempt ${attempt + 1}/${MAX_RETRIES})`);
    }
  }
}

if (reconnectedRoom) {
  // Update stored token
  if (reconnectedRoom.reconnectionToken) {
    localStorage.setItem('bangerActiveRoom', JSON.stringify({
      token: reconnectedRoom.reconnectionToken,
      timestamp: Date.now()
    }));
  }

  // Go directly to game scene
  this.scene.start('GameScene', { room: reconnectedRoom });
} else {
  throw new Error('All reconnection attempts failed');
}
```

Remove the old single-attempt code (the existing try block inner content around lines 68-80) and replace with the above. The outer catch block (lines 82-101) stays the same for handling the final failure.

**Issue 2: attachRoomListeners() missing state listeners (GameScene.ts lines 697-736)**

After reconnection, `attachRoomListeners()` only re-registers `onMessage` handlers (matchStart, matchEnd, onLeave). It does NOT re-register the critical Schema state listeners: `players.onAdd`, `players.onRemove`, `projectiles.onAdd`, `projectiles.onRemove`. This means after reconnection, new players joining/leaving and projectiles are invisible.

Expand `attachRoomListeners()` to include ALL the listeners from `create()`. Replace the entire method (lines 697-736):

```typescript
private attachRoomListeners() {
  if (!this.room) return;

  // Re-attach message listeners
  this.room.onMessage("matchStart", () => {
    this.statusText.setText(`Match started!`);
    this.time.delayedCall(2000, () => {
      if (!this.matchEnded) {
        this.statusText.setText(`Connected: ${this.room!.sessionId}`);
      }
    });
  });

  this.room.onMessage("matchEnd", (data: any) => {
    this.finalStats = data.stats;
    this.matchWinner = data.winner;
    this.matchEnded = true;
    localStorage.removeItem('bangerActiveRoom');

    this.scene.launch("VictoryScene", {
      winner: data.winner,
      stats: data.stats,
      duration: data.duration,
      localSessionId: this.room!.sessionId,
      room: this.room
    });

    this.scene.pause();
  });

  this.room.onLeave((code: number) => {
    console.log('Left room with code:', code);
    if (this.matchEnded) {
      return;
    }
    this.handleReconnection();
  });

  // Re-attach state listeners for players
  this.room.state.players.onAdd((player: any, sessionId: string) => {
    console.log('Player joined (after reconnect):', sessionId);

    const isLocal = sessionId === this.room!.sessionId;

    // Skip if sprite already exists (player was already present before reconnect)
    if (this.playerSprites.has(sessionId)) {
      // Still need to re-register onChange
      player.onChange(() => {
        this.handlePlayerChange(player, sessionId, isLocal);
      });
      return;
    }

    // Create new player visual (same logic as create())
    const role = player.role || 'faran';
    const isParan = role === 'paran';
    const size = isParan ? 32 : 24;
    let color: number;
    if (isParan) {
      color = 0xff4444;
    } else {
      color = isLocal ? 0x00ff88 : 0x4488ff;
    }

    const rect = this.add.rectangle(player.x, player.y, size, size, color);
    rect.setDepth(10);
    this.playerSprites.set(sessionId, rect);

    const healthBar = this.add.graphics();
    healthBar.setDepth(11);
    this.healthBars.set(sessionId, healthBar);
    this.updateHealthBar(sessionId, player.health, role);

    const nameText = this.add.text(
      player.x, player.y - 20,
      player.name || sessionId.slice(0, 6),
      { fontSize: '12px', color: '#ffffff' }
    );
    nameText.setOrigin(0.5);
    nameText.setDepth(11);
    this.playerLabels.set(sessionId, nameText);

    player.onChange(() => {
      this.handlePlayerChange(player, sessionId, isLocal);
    });

    if (isLocal) {
      this.localRole = role;
      this.prediction = new PredictionSystem({
        x: player.x, y: player.y,
        vx: player.vx || 0, vy: player.vy || 0,
        angle: player.angle || 0,
      }, role);
    } else {
      this.remotePlayers.add(sessionId);
    }
  });

  this.room.state.players.onRemove((player: any, sessionId: string) => {
    console.log('Player left (after reconnect):', sessionId);

    if (this.spectatorTarget === sessionId) {
      this.spectatorTarget = this.getNextAlivePlayer(sessionId);
    }

    if (this.remotePlayers.has(sessionId)) {
      this.interpolation.removePlayer(sessionId);
      this.remotePlayers.delete(sessionId);
    }

    const sprite = this.playerSprites.get(sessionId);
    if (sprite) { sprite.destroy(); this.playerSprites.delete(sessionId); }
    const label = this.playerLabels.get(sessionId);
    if (label) { label.destroy(); this.playerLabels.delete(sessionId); }
    const healthBar = this.healthBars.get(sessionId);
    if (healthBar) { healthBar.destroy(); this.healthBars.delete(sessionId); }
    const eliminatedText = this.eliminatedTexts.get(sessionId);
    if (eliminatedText) { eliminatedText.destroy(); this.eliminatedTexts.delete(sessionId); }
    const dcLabel = this.dcLabels.get(sessionId);
    if (dcLabel) { dcLabel.destroy(); this.dcLabels.delete(sessionId); }
  });

  // Re-attach projectile listeners
  this.room.state.projectiles.onAdd((projectile: any, key: string) => {
    const index = parseInt(key, 10);
    const color = projectile.ownerId === this.room!.sessionId ? 0xffff00 : 0xff6600;
    const circle = this.add.circle(projectile.x, projectile.y, 4, color);
    circle.setDepth(5);
    this.projectileSprites.set(index, circle);

    this.projectileVelocities.set(index, {
      vx: projectile.vx,
      vy: projectile.vy,
    });

    projectile.onChange(() => {
      circle.x = projectile.x;
      circle.y = projectile.y;
      this.projectileVelocities.set(index, {
        vx: projectile.vx,
        vy: projectile.vy,
      });
    });
  });

  this.room.state.projectiles.onRemove((projectile: any, key: string) => {
    const index = parseInt(key, 10);
    const sprite = this.projectileSprites.get(index);
    if (sprite) { sprite.destroy(); this.projectileSprites.delete(index); }
    this.projectileVelocities.delete(index);
  });
}
```

**Extract handlePlayerChange helper:** To avoid duplicating the onChange logic between `create()` and `attachRoomListeners()`, extract the player onChange callback into a new method:

```typescript
private handlePlayerChange(player: any, sessionId: string, isLocal: boolean) {
  // Update visuals when role changes
  if (player.role) {
    const sprite = this.playerSprites.get(sessionId);
    if (sprite) {
      const isParan = player.role === 'paran';
      const size = isParan ? 32 : 24;
      let color: number;
      if (isParan) {
        color = 0xff4444;
      } else {
        color = isLocal ? 0x00ff88 : 0x4488ff;
      }
      sprite.setSize(size, size);
      sprite.setFillStyle(color);
    }
  }

  // Update health bar
  this.updateHealthBar(sessionId, player.health, player.role);

  // Handle disconnected state (using dcLabels map)
  if (!player.connected && player.health > 0) {
    const sprite = this.playerSprites.get(sessionId);
    if (sprite) sprite.setAlpha(0.3);
    if (!this.dcLabels.has(sessionId)) {
      const dcText = this.add.text(player.x, player.y + 30, 'DC', {
        fontSize: '12px', color: '#ffaa00', fontStyle: 'bold',
        backgroundColor: '#000000', padding: { x: 4, y: 2 }
      });
      dcText.setOrigin(0.5);
      dcText.setDepth(12);
      this.dcLabels.set(sessionId, dcText);
    }
  } else if (player.health <= 0) {
    const sprite = this.playerSprites.get(sessionId);
    if (sprite) sprite.setAlpha(0.3);
    const dcLabel = this.dcLabels.get(sessionId);
    if (dcLabel) { dcLabel.destroy(); this.dcLabels.delete(sessionId); }
    if (!this.eliminatedTexts.has(sessionId)) {
      const eliminatedText = this.add.text(player.x, player.y - 40, 'ELIMINATED', {
        fontSize: '14px', color: '#ff0000', fontStyle: 'bold',
      });
      eliminatedText.setOrigin(0.5);
      eliminatedText.setDepth(12);
      this.eliminatedTexts.set(sessionId, eliminatedText);
    }
  } else {
    const sprite = this.playerSprites.get(sessionId);
    if (sprite) sprite.setAlpha(1.0);
    const dcLabel = this.dcLabels.get(sessionId);
    if (dcLabel) { dcLabel.destroy(); this.dcLabels.delete(sessionId); }
    const eliminatedText = this.eliminatedTexts.get(sessionId);
    if (eliminatedText) { eliminatedText.destroy(); this.eliminatedTexts.delete(sessionId); }
  }

  // Role-specific handling
  if (isLocal) {
    if (this.prediction) {
      this.prediction.reconcile({
        x: player.x, y: player.y,
        vx: player.vx || 0, vy: player.vy || 0,
        angle: player.angle || 0,
        lastProcessedSeq: player.lastProcessedSeq || 0,
      });
      const state = this.prediction.getState();
      const sprite = this.playerSprites.get(sessionId);
      if (sprite) { sprite.x = state.x; sprite.y = state.y; }
      const label = this.playerLabels.get(sessionId);
      if (label) { label.x = state.x; label.y = state.y - 20; }
    }
  } else {
    this.interpolation.addSnapshot(sessionId, {
      timestamp: Date.now(),
      x: player.x, y: player.y,
      angle: player.angle || 0,
    });
  }
}
```

Then in the original `create()` method's `player.onChange()` callback (around line 229), replace the entire inline callback body with:
```typescript
player.onChange(() => {
  this.handlePlayerChange(player, sessionId, isLocal);
});
```

This deduplicates the onChange logic and ensures both initial connection and reconnection use the same handler.

Run both TypeScript compilations to verify:
```bash
cd /Users/jonasbrandvik/Projects/banger-game/server && npx tsc --noEmit
cd /Users/jonasbrandvik/Projects/banger-game/client && npx tsc --noEmit
```
  </action>
  <verify>
Run server and client TypeScript compilation -- both must pass.
Grep for `MAX_RETRIES` in LobbyScene.ts -- must find retry logic.
Grep for `handlePlayerChange` in GameScene.ts -- must find the extracted method.
Grep for `players.onAdd` in attachRoomListeners in GameScene.ts -- must find state listener registration.
Grep for `projectiles.onAdd` in attachRoomListeners in GameScene.ts -- must find projectile listener registration.
Grep for `dcLabels` in GameScene.ts -- must find separate DC label tracking.
  </verify>
  <done>
Reconnection uses retry logic (3 attempts, 800ms delay) for F5 race condition. attachRoomListeners() re-registers all Schema state listeners (players onAdd/onRemove/onChange, projectiles onAdd/onRemove). Player onChange logic extracted to handlePlayerChange() for code reuse between initial connection and reconnection.
  </done>
</task>

</tasks>

<verification>
1. Consented leaves during PLAYING defer deletion by 2s (ghost renders before removal)
2. DC labels use separate dcLabels map (no collision with eliminatedTexts)
3. Reconnection has 3 retries with 800ms delay
4. attachRoomListeners() registers players.onAdd, onRemove, projectiles.onAdd, onRemove
5. handlePlayerChange() shared between create() and attachRoomListeners()
6. Both server and client compile without errors
</verification>

<success_criteria>
- Disconnected player shows ghosted sprite (30% opacity) with yellow "DC" label
- DC label tracked separately from ELIMINATED label
- Browser F5 reconnects within 3 attempts (800ms between each)
- Reconnected clients see all players, projectiles, and state changes
- Server and client TypeScript compile cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/05-multiplayer-lobbies/05-07-SUMMARY.md`
</output>
