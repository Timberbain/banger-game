---
phase: 05-multiplayer-lobbies
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - server/src/schema/LobbyState.ts
  - server/src/rooms/LobbyRoom.ts
  - server/src/rooms/MatchmakingQueue.ts
  - server/src/utils/roomCode.ts
  - server/src/index.ts
  - shared/lobby.ts
autonomous: true

must_haves:
  truths:
    - "LobbyRoom accepts player connections with character selection and ready toggling"
    - "Private rooms generate 6-char alphanumeric codes and are hidden from matchmaking"
    - "Role validation enforces 1 Paran + 2 Guardians constraint"
    - "Matchmaking queue forms matches when 1 Paran + 2 Guardians available"
    - "All 3 players ready with valid roles triggers transition to GameRoom"
  artifacts:
    - path: "shared/lobby.ts"
      provides: "Lobby constants shared between client and server"
      contains: "LOBBY_CONFIG"
    - path: "server/src/schema/LobbyState.ts"
      provides: "Colyseus Schema for lobby state sync"
      contains: "LobbyPlayer"
    - path: "server/src/rooms/LobbyRoom.ts"
      provides: "Pre-match lobby room with role selection and ready system"
      contains: "LobbyRoom"
    - path: "server/src/rooms/MatchmakingQueue.ts"
      provides: "Queue manager for automatic matchmaking"
      contains: "MatchmakingQueue"
    - path: "server/src/utils/roomCode.ts"
      provides: "Room code generation utility"
      contains: "generateRoomCode"
  key_links:
    - from: "server/src/rooms/LobbyRoom.ts"
      to: "server/src/schema/LobbyState.ts"
      via: "Room state type parameter"
      pattern: "Room<LobbyState>"
    - from: "server/src/rooms/LobbyRoom.ts"
      to: "server/src/utils/roomCode.ts"
      via: "Room code generation on create"
      pattern: "generateRoomCode"
    - from: "server/src/rooms/LobbyRoom.ts"
      to: "matchMaker"
      via: "Creates GameRoom when all ready"
      pattern: "matchMaker\\.create"
    - from: "server/src/index.ts"
      to: "server/src/rooms/LobbyRoom.ts"
      via: "Room registration"
      pattern: "gameServer\\.define.*lobby"
---

<objective>
Build the server-side lobby infrastructure: LobbyRoom with character selection, ready system, private room codes, matchmaking queue, and GameRoom transition.

Purpose: Provides all server-side room management so clients can create/join lobbies, select characters, ready up, and transition to matches.
Output: Working LobbyRoom and MatchmakingQueue registered on the game server.
</objective>

<execution_context>
@/Users/jonasbrandvik/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jonasbrandvik/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-multiplayer-lobbies/05-RESEARCH.md

@server/src/index.ts
@server/src/rooms/GameRoom.ts
@server/src/schema/GameState.ts
@server/src/config.ts
@shared/characters.ts
@shared/maps.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create shared lobby constants, LobbyState schema, room code utility, and LobbyRoom</name>
  <files>
    shared/lobby.ts
    server/src/schema/LobbyState.ts
    server/src/utils/roomCode.ts
    server/src/rooms/LobbyRoom.ts
  </files>
  <action>
    **shared/lobby.ts** - Create shared constants:
    - `LOBBY_CONFIG` object with: `MAX_PLAYERS: 3`, `ROOM_CODE_LENGTH: 6`, `LOBBY_RECONNECT_GRACE: 30` (seconds), `MATCH_RECONNECT_GRACE: 60` (seconds), `QUEUE_TIMEOUT: 120000` (ms), `COUNTDOWN_SECONDS: 3`
    - Export `VALID_ROLES` array: `["paran", "faran", "baran"]`
    - Export `ROLE_LIMITS` object: `{ paran: 1, faran: 1, baran: 1 }` (exactly one of each role)

    **server/src/utils/roomCode.ts** - Room code generator:
    - `generateRoomCode(length: number = 6): string` using chars "ABCDEFGHJKLMNPQRSTUVWXYZ23456789" (excludes ambiguous 0/O, 1/I/L)
    - Uses `Math.random()` for each character position (sufficient for short-lived game rooms)

    **server/src/schema/LobbyState.ts** - Colyseus Schema classes:
    - `LobbyPlayer extends Schema` with `@type` fields: `name: string`, `role: string` (empty = not selected), `ready: boolean`, `connected: boolean`
    - `LobbyState extends Schema` with `@type` fields: `players: MapSchema<LobbyPlayer>`, `roomCode: string`, `isPrivate: boolean`, `countdown: number` (seconds remaining, 0 = not counting)
    - Import from `@colyseus/schema` (Schema, type, MapSchema)

    **server/src/rooms/LobbyRoom.ts** - Full lobby room implementation:
    - `extends Room<LobbyState>`, `maxClients = 3`
    - **onCreate(options):**
      - Set state to new LobbyState()
      - If `options.private`: generate room code via `generateRoomCode()`, set `state.roomCode`, `state.isPrivate = true`, call `this.setPrivate(true)`, call `this.setMetadata({ roomCode: state.roomCode })`
      - Register message handlers:
        - `"selectRole"`: validate role is in VALID_ROLES, check role not already taken by another player (iterate players MapSchema), if available set `player.role = role` and reset `player.ready = false` (changing role un-readies). Send `"roleError"` message on conflict.
        - `"toggleReady"`: only if player has role selected. Toggle `player.ready`. Call `checkReadyToStart()`.
    - **onJoin(client, options):**
      - Create LobbyPlayer, set `name` from options (truncate to 20 chars, fallback to sessionId prefix), `connected = true`
      - Add to `state.players` MapSchema keyed by `client.sessionId`
    - **onLeave(client, consented):**
      - Mark `player.connected = false`
      - If consented: delete player immediately
      - If not consented: `await this.allowReconnection(client, LOBBY_CONFIG.LOBBY_RECONNECT_GRACE)` in try/catch. On success: re-mark connected. On catch: delete player.
    - **checkReadyToStart():**
      - Get all player values from MapSchema
      - Check: exactly 3 players, all connected, all have role, all ready
      - Check role distribution: exactly 1 paran, 1 faran, 1 baran
      - If all conditions met: call `startCountdown()`
    - **startCountdown():**
      - Set `state.countdown = LOBBY_CONFIG.COUNTDOWN_SECONDS`
      - Use `this.clock.setInterval()` at 1s intervals to decrement countdown
      - When countdown reaches 0: clear interval, call `startMatch()`
      - If any player un-readies during countdown: clear interval, reset `state.countdown = 0`
    - **startMatch():**
      - Import `matchMaker` from `colyseus`
      - Build `roleAssignments` object mapping sessionId to role for each player
      - Call `const reservation = await matchMaker.create("game_room", { fromLobby: true, roleAssignments })`
      - Broadcast `"gameReady"` message to all clients with `{ gameRoomId: reservation.room.roomId }`
      - Set `this.clock.setTimeout(() => this.disconnect(), 5000)` to dispose lobby after clients transition
    - **onDispose():** Log disposal
  </action>
  <verify>
    `cd /Users/jonasbrandvik/Projects/banger-game/server && npx tsc --noEmit` compiles without errors. Verify LobbyState.ts exports LobbyPlayer and LobbyState. Verify LobbyRoom.ts imports and uses all dependencies correctly.
  </verify>
  <done>
    LobbyRoom handles player join/leave with reconnection, character selection with role validation (1 paran + 1 faran + 1 baran), ready toggling, countdown, and GameRoom transition via matchMaker.create().
  </done>
</task>

<task type="auto">
  <name>Task 2: Create MatchmakingQueue and register rooms in server index</name>
  <files>
    server/src/rooms/MatchmakingQueue.ts
    server/src/rooms/LobbyRoom.ts
    server/src/rooms/GameRoom.ts
    server/src/index.ts
  </files>
  <action>
    **server/src/rooms/MatchmakingQueue.ts** - Matchmaking queue manager:
    - Export `MatchmakingQueue` class (singleton, not a Room):
      - Private queues: `paranQueue: string[]` and `guardianQueue: string[]` (store sessionIds or client references)
      - Private `queueTimestamps: Map<string, number>` for timeout tracking
      - `addToQueue(sessionId: string, preferredRole: string): void` - add to appropriate queue based on preferred role ("paran" goes to paranQueue, "faran" or "baran" goes to guardianQueue)
      - `removeFromQueue(sessionId: string): void` - remove from both queues and timestamps
      - `tryFormMatch(): { paran: string; guardians: string[] } | null` - check if paranQueue >= 1 and guardianQueue >= 2, if so pop 1 paran + 2 guardians and return their sessionIds
      - `getQueueSize(): { paran: number; guardian: number }` - for status reporting
      - `checkTimeouts(timeoutMs: number): string[]` - return sessionIds that exceeded timeout, remove them from queues

    **server/src/rooms/LobbyRoom.ts** - Add matchmaking support:
    - Add message handler `"joinQueue"` in onCreate: receives `{ preferredRole }`, adds client to singleton matchmaking queue
    - Add message handler `"leaveQueue"`: removes client from queue
    - On `onLeave`: also remove from matchmaking queue if applicable
    - Periodically check matchmaking queue (clock.setInterval at 1s): call `tryFormMatch()`, if match found, create lobby room for the 3 matched players and send them `"matchFound"` with lobby roomId

    **server/src/rooms/GameRoom.ts** - Accept lobby transition options:
    - In `onJoin(client, options)`: if `options.fromLobby === true` and `options.role` is provided, use `options.role` instead of join-order-based role assignment
    - This allows the lobby to pass the player's chosen role through to GameRoom
    - Keep existing join-order role assignment as fallback for direct joins (backward compatibility)
    - Adjust spawn point selection based on role (not join order): use `this.mapMetadata.spawnPoints.paran` for paran, `guardians[0]` for faran, `guardians[1]` for baran

    **server/src/index.ts** - Register lobby room:
    - Import `LobbyRoom` from `./rooms/LobbyRoom`
    - Add `gameServer.define("lobby_room", LobbyRoom)` before game_room definition
    - Keep existing `gameServer.define("game_room", GameRoom)` as-is
  </action>
  <verify>
    `cd /Users/jonasbrandvik/Projects/banger-game/server && npx tsc --noEmit` compiles without errors. Verify index.ts defines both "lobby_room" and "game_room". Verify GameRoom accepts role from options.
  </verify>
  <done>
    MatchmakingQueue tracks waiting players by role and forms matches. LobbyRoom integrates matchmaking. GameRoom accepts role assignments from lobby transition. Both rooms registered on server.
  </done>
</task>

</tasks>

<verification>
1. `cd /Users/jonasbrandvik/Projects/banger-game/server && npx tsc --noEmit` passes
2. LobbyState schema has LobbyPlayer with name, role, ready, connected fields
3. LobbyRoom handles: selectRole, toggleReady, allowReconnection, startMatch via matchMaker.create
4. MatchmakingQueue tracks paran/guardian queues and forms 1+2 matches
5. GameRoom accepts `fromLobby` + `role` options for lobby-assigned roles
6. Room codes are 6-char alphanumeric without ambiguous characters
7. Both room types registered in server index
</verification>

<success_criteria>
- Server compiles without errors
- LobbyRoom class exists with character selection, ready system, room codes, and GameRoom transition
- MatchmakingQueue class exists with role-based queuing
- GameRoom modified to accept lobby-assigned roles
- Shared lobby constants accessible from both server and client
</success_criteria>

<output>
After completion, create `.planning/phases/05-multiplayer-lobbies/05-01-SUMMARY.md`
</output>
