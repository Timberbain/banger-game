---
phase: 05.1-arena-collisions-contact-kill
plan: 03
type: execute
wave: 2
depends_on: ["05.1-01"]
files_modified:
  - client/src/systems/Prediction.ts
  - client/src/scenes/GameScene.ts
autonomous: true

must_haves:
  truths:
    - "Client prediction applies collision resolution after every physics step (no jitter from server reconciliation)"
    - "Client prediction reconciliation (replay) also applies collision after each replayed input"
    - "Local player cannot visually pass through walls or obstacles even before server correction"
    - "Destroyed obstacles are visually removed from the tilemap when server syncs destruction"
    - "Client collision grid is updated when obstacles are destroyed (prediction stays in sync)"
    - "Projectile client-side interpolation does not visually move projectiles through walls"
  artifacts:
    - path: "client/src/systems/Prediction.ts"
      provides: "PredictionSystem with collision grid integration"
      contains: "resolveCollisions"
    - path: "client/src/scenes/GameScene.ts"
      provides: "GameScene with collision grid loading, obstacle destruction rendering, and schema listeners for obstacles"
      contains: "collisionGrid"
  key_links:
    - from: "client/src/systems/Prediction.ts"
      to: "shared/collisionGrid.ts"
      via: "resolveCollisions called after each physics step in sendInput and reconcile"
      pattern: "resolveCollisions"
    - from: "client/src/scenes/GameScene.ts"
      to: "shared/collisionGrid.ts"
      via: "CollisionGrid constructed from map data, passed to PredictionSystem"
      pattern: "new CollisionGrid.*setCollisionGrid"
    - from: "client/src/scenes/GameScene.ts"
      to: "shared/obstacles.ts"
      via: "OBSTACLE_TILE_IDS used during collision grid construction"
      pattern: "OBSTACLE_TILE_IDS"
---

<objective>
Integrate collision detection into client prediction and add obstacle destruction rendering.

Purpose: Without client-side collision in prediction, the player visually passes through walls, then snaps back when the server correction arrives -- causing constant jitter. The PredictionSystem must apply the same collision resolution as the server after every predicted physics step. Additionally, the GameScene must render obstacle destruction in real-time by listening to the server's obstacle Schema changes and updating both the collision grid (for prediction) and the Phaser tilemap (for visuals).

Output: Updated PredictionSystem with collision support, updated GameScene with obstacle rendering.
</objective>

<execution_context>
@/Users/jonasbrandvik/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jonasbrandvik/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05.1-arenas-should-have-obstacles-and-walls-that-players-collides-with-also-paran-should-be-able-to-instantly-kill-faran-or-baran-when-he-collides-with-them/05.1-01-SUMMARY.md
@shared/collisionGrid.ts
@shared/obstacles.ts
@shared/physics.ts
@shared/characters.ts
@client/src/systems/Prediction.ts
@client/src/scenes/GameScene.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add collision grid to PredictionSystem</name>
  <files>client/src/systems/Prediction.ts</files>
  <action>
Modify PredictionSystem to apply tile collision after every physics step:

1. Import `CollisionGrid` and `resolveCollisions` from `../../../shared/collisionGrid`
2. Import `COMBAT` from `../../../shared/characters`
3. Add private member: `private collisionGrid: CollisionGrid | null = null;`
4. Add public method: `setCollisionGrid(grid: CollisionGrid): void { this.collisionGrid = grid; }`

**In sendInput():**
After `applyMovementPhysics(this.localState, input, 1/60, {...})` and `updateFacingDirection(this.localState)`:
```
// Apply tile collision (must match server)
if (this.collisionGrid) {
  const prevX = /* need to capture BEFORE applyMovementPhysics */;
  const prevY = /* need to capture BEFORE applyMovementPhysics */;
  const result = resolveCollisions(
    this.localState, COMBAT.playerRadius, this.collisionGrid, prevX, prevY
  );
  if (result.hitX || result.hitY) {
    if (this.role === 'paran') {
      // Paran wall penalty: lose ALL velocity on any collision
      this.localState.vx = 0;
      this.localState.vy = 0;
    } else {
      // Guardian: only zero the axis that hit
      if (result.hitX) this.localState.vx = 0;
      if (result.hitY) this.localState.vy = 0;
    }
  }
}
```
IMPORTANT: Capture prevX/prevY BEFORE calling applyMovementPhysics (which modifies position in place). Move the prevX/prevY capture before the physics call.

Also apply edge clamping as safety net (same as server -- no velocity zeroing from edge clamp now):
```
this.localState.x = Math.max(0, Math.min(ARENA.width, this.localState.x));
this.localState.y = Math.max(0, Math.min(ARENA.height, this.localState.y));
```
Import ARENA from shared/physics if not already imported.

**In reconcile():**
After resetting local state to server state and before replaying pending inputs, the replay loop must also apply collision:
```
for (const pending of this.pendingInputs) {
  const prevX = this.localState.x;
  const prevY = this.localState.y;
  applyMovementPhysics(this.localState, pending.input, 1/60, {...});
  updateFacingDirection(this.localState);
  // Apply tile collision during replay
  if (this.collisionGrid) {
    const result = resolveCollisions(
      this.localState, COMBAT.playerRadius, this.collisionGrid, prevX, prevY
    );
    if (result.hitX || result.hitY) {
      if (this.role === 'paran') {
        this.localState.vx = 0;
        this.localState.vy = 0;
      } else {
        if (result.hitX) this.localState.vx = 0;
        if (result.hitY) this.localState.vy = 0;
      }
    }
  }
  // Safety net edge clamp
  this.localState.x = Math.max(0, Math.min(ARENA.width, this.localState.x));
  this.localState.y = Math.max(0, Math.min(ARENA.height, this.localState.y));
}
```

**clearTile method for obstacle destruction:**
Add: `clearCollisionTile(tileX: number, tileY: number): void { if (this.collisionGrid) this.collisionGrid.clearTile(tileX, tileY); }`
This is called by GameScene when receiving obstacle destruction from server.
  </action>
  <verify>
Run `npx tsc --noEmit` from client/ directory to confirm compilation. Verify PredictionSystem has setCollisionGrid and clearCollisionTile methods.
  </verify>
  <done>
PredictionSystem applies collision resolution after every physics step in both sendInput and reconcile. Collision grid can be set and updated dynamically for obstacle destruction. Edge clamping as safety net. Paran wall penalty (full velocity loss) applied client-side.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate collision grid and obstacle rendering in GameScene</name>
  <files>client/src/scenes/GameScene.ts</files>
  <action>
Modify GameScene to load collision grid and handle obstacle destruction rendering:

**Add imports:**
- `import { CollisionGrid } from '../../../shared/collisionGrid';`
- `import { OBSTACLE_TILE_IDS } from '../../../shared/obstacles';`

**Add class members:**
- `private collisionGrid: CollisionGrid | null = null;`
- `private wallsLayer: Phaser.Tilemaps.TilemapLayer | null = null;` (store reference for tile updates)

**In create() state reset block:** Add:
- `this.collisionGrid = null;`
- `this.wallsLayer = null;`

**In createTilemap():**
After creating the Walls layer, build the collision grid for client prediction:
```
// Store walls layer reference for obstacle destruction rendering
this.wallsLayer = wallsLayer;

// Build collision grid from map data for client prediction
const mapData = this.cache.tilemap.get(mapKey);
if (mapData) {
  const wallLayerData = mapData.data.layers.find((l: any) => l.name === 'Walls');
  if (wallLayerData) {
    this.collisionGrid = new CollisionGrid(
      wallLayerData.data,
      mapData.data.width,
      mapData.data.height,
      mapData.data.tilewidth,
      OBSTACLE_TILE_IDS.destructible,
      OBSTACLE_TILE_IDS.indestructible
    );

    // Pass collision grid to prediction system
    if (this.prediction) {
      this.prediction.setCollisionGrid(this.collisionGrid);
    }
  }
}
```

Note: There's a race condition -- prediction system might be created before createTilemap is called (since map loads asynchronously). Also handle the case where prediction is created after tilemap:
- In the `onAdd` handler for the local player (where PredictionSystem is created), after creating the prediction system, check if collisionGrid exists and set it:
  ```
  if (this.collisionGrid) {
    this.prediction.setCollisionGrid(this.collisionGrid);
  }
  ```

**Obstacle state listener (in the room connection setup, after projectile listeners):**
Add listeners for obstacle state changes:
```
// Listen for obstacle state changes (destruction)
this.room.state.obstacles.onAdd((obstacle: any, key: string) => {
  // Initial state -- obstacles start intact, nothing to render differently
  obstacle.onChange(() => {
    if (obstacle.destroyed) {
      // Update collision grid for prediction
      if (this.collisionGrid) {
        this.collisionGrid.clearTile(obstacle.tileX, obstacle.tileY);
      }
      if (this.prediction) {
        this.prediction.clearCollisionTile(obstacle.tileX, obstacle.tileY);
      }

      // Update tilemap visual: replace obstacle tile with floor (tile 2) or remove (tile 0/null)
      if (this.wallsLayer) {
        this.wallsLayer.putTileAt(0, obstacle.tileX, obstacle.tileY); // 0 = empty/no tile
      }
    }
  });
});
```

**IMPORTANT:** The clearCollisionTile call on prediction is technically redundant since both the prediction system and GameScene share the SAME CollisionGrid instance (passed by reference). Calling `this.collisionGrid.clearTile()` will update the grid that prediction also uses. So the `this.prediction.clearCollisionTile()` line can be removed, OR keep it as a defensive measure in case the grid is ever replaced. Decide based on simplicity -- removing it is cleaner since they share the reference.

**Also in attachRoomListeners() (for reconnection):**
Add the same obstacle listeners so reconnecting clients get obstacle state:
```
this.room.state.obstacles.onAdd((obstacle: any, key: string) => {
  // Handle already-destroyed obstacles (reconnection catches up)
  if (obstacle.destroyed) {
    if (this.collisionGrid) {
      this.collisionGrid.clearTile(obstacle.tileX, obstacle.tileY);
    }
    if (this.wallsLayer) {
      this.wallsLayer.putTileAt(0, obstacle.tileX, obstacle.tileY);
    }
  }
  obstacle.onChange(() => {
    if (obstacle.destroyed) {
      if (this.collisionGrid) {
        this.collisionGrid.clearTile(obstacle.tileX, obstacle.tileY);
      }
      if (this.wallsLayer) {
        this.wallsLayer.putTileAt(0, obstacle.tileX, obstacle.tileY);
      }
    }
  });
});
```

**Projectile visual clipping through walls:**
The client-side projectile interpolation (`sprite.x += velocity.vx * dt`) may briefly show projectiles moving through walls before the server removes them. This is acceptable -- the server destroys the projectile on contact and the client will remove it via `onRemove`. The visual discrepancy is at most 1 frame (16ms). No client-side projectile-wall collision needed.
  </action>
  <verify>
1. Run `npx tsc --noEmit` from client/ to confirm compilation
2. Start both server and client (`npm run dev` for server, `npm run dev` for client)
3. Join a game and verify: local player cannot walk through obstacles, destroyed obstacles disappear from tilemap
4. Verify no jitter when walking into walls (prediction matches server)
  </verify>
  <done>
Client loads collision grid from map data and passes it to PredictionSystem. Prediction applies collision after every physics step (no wall-clipping jitter). Obstacle destruction updates both collision grid and tilemap visuals. Reconnection listeners handle obstacle state catchup. Player cannot visually pass through walls or obstacles.
  </done>
</task>

</tasks>

<verification>
1. Client compiles without TypeScript errors
2. PredictionSystem receives and uses collision grid
3. Local player physically blocked by walls and obstacles (no visual pass-through)
4. No jitter or rubber-banding when walking into walls
5. Paran prediction applies full velocity loss on wall/obstacle hit
6. Guardian prediction stops at obstacle edge (per-axis velocity zeroing)
7. Destroyed obstacles visually disappear from tilemap
8. Collision grid updated on obstacle destruction (prediction stays accurate)
9. Reconnecting client correctly loads destroyed obstacle state
</verification>

<success_criteria>
- Zero visual wall-clipping: local player prediction matches server collision exactly
- Obstacle destruction renders in real-time as server syncs state
- Reconnection handles obstacle state catchup (destroyed tiles clear on rejoin)
- No regression in movement feel, input responsiveness, or prediction accuracy
</success_criteria>

<output>
After completion, create `.planning/phases/05.1-arenas-should-have-obstacles-and-walls-that-players-collides-with-also-paran-should-be-able-to-instantly-kill-faran-or-baran-when-he-collides-with-them/05.1-03-SUMMARY.md`
</output>
