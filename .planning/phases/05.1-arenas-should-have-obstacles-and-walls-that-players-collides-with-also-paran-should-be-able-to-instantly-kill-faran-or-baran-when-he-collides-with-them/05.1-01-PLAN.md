---
phase: 05.1-arena-collisions-contact-kill
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - shared/collisionGrid.ts
  - shared/obstacles.ts
  - client/public/tilesets/placeholder.png
  - client/public/maps/test_arena.json
  - client/public/maps/corridor_chaos.json
  - client/public/maps/cross_fire.json
  - client/public/maps/pillars.json
autonomous: true

must_haves:
  truths:
    - "CollisionGrid class can parse Tiled JSON wall layer data into a queryable 2D grid"
    - "resolveCollisions function performs AABB-vs-tile collision with axis-separated resolution"
    - "Obstacle tile constants define HP values for 3 destructible tiers (Light=2, Medium=3, Heavy=5)"
    - "All 4 map JSON files contain destructible obstacle tiles (IDs 4-6) in addition to existing walls (ID 3)"
    - "Tileset image has visually distinct tiles for each obstacle tier"
  artifacts:
    - path: "shared/collisionGrid.ts"
      provides: "CollisionGrid class, TileInfo interface, CollidableEntity interface, resolveCollisions function"
      exports: ["CollisionGrid", "TileInfo", "CollidableEntity", "resolveCollisions"]
    - path: "shared/obstacles.ts"
      provides: "Obstacle tile ID constants, tier HP mappings, tile ID sets"
      exports: ["OBSTACLE_TILES", "OBSTACLE_TIER_HP", "OBSTACLE_TILE_IDS"]
    - path: "client/public/tilesets/placeholder.png"
      provides: "Expanded tileset with tiles for Heavy (4), Medium (5), Light (6) destructible obstacles"
    - path: "client/public/maps/test_arena.json"
      provides: "Test arena map updated with destructible obstacles"
    - path: "client/public/maps/corridor_chaos.json"
      provides: "Corridor chaos map updated with destructible obstacles"
    - path: "client/public/maps/cross_fire.json"
      provides: "Cross fire map updated with destructible obstacles"
    - path: "client/public/maps/pillars.json"
      provides: "Pillars map updated with destructible obstacles"
  key_links:
    - from: "shared/collisionGrid.ts"
      to: "shared/obstacles.ts"
      via: "OBSTACLE_TILE_IDS used to classify tiles as destructible vs indestructible"
      pattern: "OBSTACLE_TILE_IDS"
    - from: "client/public/maps/*.json"
      to: "shared/obstacles.ts"
      via: "Map tile data uses tile IDs 4,5,6 matching OBSTACLE_TILES constants"
      pattern: "tile IDs 4-6 in Walls layer data"
---

<objective>
Create the shared collision detection infrastructure and update all map assets with obstacle tiles.

Purpose: This plan builds the foundation that both server and client need. The CollisionGrid class provides pure-TypeScript AABB-vs-tile collision queries (no Phaser dependency). The obstacle constants define tile ID mappings and HP values. The tileset and map JSON files are updated with new destructible obstacle tiles. All downstream work (server collision enforcement, client prediction, destructible sync) depends on these shared artifacts.

Output: shared/collisionGrid.ts, shared/obstacles.ts, expanded tileset PNG, 4 updated map JSON files.
</objective>

<execution_context>
@/Users/jonasbrandvik/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jonasbrandvik/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@shared/physics.ts
@shared/characters.ts
@shared/maps.ts
@client/public/maps/test_arena.json
@client/public/maps/corridor_chaos.json
@client/public/maps/cross_fire.json
@client/public/maps/pillars.json
@client/public/tilesets/placeholder.png
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create shared collision grid and obstacle constants</name>
  <files>shared/collisionGrid.ts, shared/obstacles.ts</files>
  <action>
Create two new shared modules:

**shared/obstacles.ts:**
- Define `OBSTACLE_TILES` const object with tile IDs:
  - WALL: 3 (existing indestructible wall)
  - HEAVY: 4 (heavy destructible, 5 HP)
  - MEDIUM: 5 (medium destructible, 3 HP)
  - LIGHT: 6 (light destructible, 2 HP)
- Define `OBSTACLE_TIER_HP: Record<number, number>` mapping tile IDs to HP values:
  - [OBSTACLE_TILES.HEAVY]: 5
  - [OBSTACLE_TILES.MEDIUM]: 3
  - [OBSTACLE_TILES.LIGHT]: 2
- Define `OBSTACLE_TILE_IDS` object with two Sets:
  - `indestructible: new Set([OBSTACLE_TILES.WALL])`
  - `destructible: new Set([OBSTACLE_TILES.HEAVY, OBSTACLE_TILES.MEDIUM, OBSTACLE_TILES.LIGHT])`

**shared/collisionGrid.ts:**
- Define `TileInfo` interface: `{ solid: boolean; destructible: boolean; tileId: number }`
- Define `CollidableEntity` interface: `{ x: number; y: number; vx: number; vy: number; role?: string }`
- Create `CollisionGrid` class:
  - Constructor takes `wallLayerData: number[], mapWidth: number, mapHeight: number, tileSize: number, destructibleTileIds: Set<number>, indestructibleTileIds: Set<number>`
  - Build `grid: TileInfo[][]` from wall layer data, classifying each tile
  - `isSolid(tileX, tileY): boolean` -- returns true for out-of-bounds or solid tiles
  - `getTileInfo(tileX, tileY): TileInfo | null` -- returns tile info or null for out-of-bounds
  - `clearTile(tileX, tileY): void` -- marks tile as non-solid, non-destructible (for destruction)
  - `worldToTile(worldX, worldY): { tileX: number; tileY: number }` -- converts pixel coords to tile coords using `Math.floor(worldPos / tileSize)`
  - Public readonly `width`, `height`, `tileSize` properties

- Create `resolveCollisions` function (exported, not a class method):
  - Signature: `resolveCollisions(entity: CollidableEntity, radius: number, grid: CollisionGrid, prevX: number, prevY: number): { hitX: boolean; hitY: boolean; hitTiles: { tileX: number; tileY: number }[] }`
  - Uses axis-separated resolution: resolve X axis first (using prevY for stability), then resolve Y axis (using resolved X).
  - For X resolution: compute AABB using `entity.x +/- radius` and `prevY +/- radius`, iterate tiles in that AABB, if solid tile found: set hitX=true, push back entity.x to tile edge (if moving right: `entity.x = tileX * tileSize - radius`, if moving left: `entity.x = (tileX + 1) * tileSize + radius`)
  - For Y resolution: compute AABB using resolved `entity.x +/- radius` and `entity.y +/- radius`, iterate tiles, if solid: set hitY=true, push back entity.y similarly
  - Collect all hit tile coordinates in hitTiles array
  - Return `{ hitX, hitY, hitTiles }`

Important: This module must be pure TypeScript with no Phaser or server dependencies -- used by both server and client prediction.
  </action>
  <verify>
Run `npx tsc --noEmit` from server/ and client/ directories to confirm both can import the shared modules without type errors. Verify CollisionGrid constructor processes a sample wall layer data array correctly.
  </verify>
  <done>
shared/collisionGrid.ts exports CollisionGrid class and resolveCollisions function. shared/obstacles.ts exports OBSTACLE_TILES, OBSTACLE_TIER_HP, and OBSTACLE_TILE_IDS. Both files compile cleanly and are importable from server and client.
  </done>
</task>

<task type="auto">
  <name>Task 2: Expand tileset and update all 4 map JSON files with obstacle layouts</name>
  <files>client/public/tilesets/placeholder.png, client/public/maps/test_arena.json, client/public/maps/corridor_chaos.json, client/public/maps/cross_fire.json, client/public/maps/pillars.json</files>
  <action>
**Tileset expansion (placeholder.png):**
The current tileset is 128x64px (4 columns x 2 rows = 8 tiles at 32x32). Tile IDs 1-8 are available (1-indexed in Tiled format). Currently used: 2=floor (dark green), 3=wall (bright green). Tiles 4-6 need distinct visuals for destructible obstacles.

Use the `canvas` npm package (already available from Phase 1) to generate the updated tileset programmatically. Create a script or inline Node.js code that:
- Loads existing placeholder.png (or recreates it)
- Keeps tile 2 (floor) and tile 3 (wall/indestructible) as-is
- Adds tile 4 (Heavy destructible): dark brownish-red (#8B4513 or similar), with subtle border outline
- Adds tile 5 (Medium destructible): orange/amber (#D2691E or similar), with subtle border outline
- Adds tile 6 (Light destructible): pale yellow/sand (#DAA520 or similar), with subtle border outline
- Each obstacle tile should be visually distinct from floor (tile 2) and clearly readable as blocking
- Save as 128x64 PNG (same dimensions, tiles 4-6 occupy positions in the existing grid)

Tile positions in the 4x2 grid (0-indexed): Row 0: [tile1, tile2, tile3, tile4], Row 1: [tile5, tile6, tile7, tile8]. So tile 4 is at position (3,0), tile 5 at (0,1), tile 6 at (1,1).

**Map JSON updates:**
Update the Walls layer `data` array in each map to add obstacle tiles. Keep border walls (tile 3) untouched. Add obstacles in the interior:

**test_arena.json (Open arena -- low density):**
- Keep existing L-shaped wall blocks
- Add 4-6 small destructible clusters scattered in center area
- Use mostly Light (6) and Medium (5) destructibles
- Keep spawn areas clear (corners and center)

**corridor_chaos.json (Corridors -- medium density):**
- Keep existing corridor wall structure
- Add destructible obstacles inside corridors (Light/Medium) so Paran can "break through"
- Add a few Heavy (4) destructibles at key chokepoints
- Keep corridors navigable (at least 1-tile-wide paths)

**cross_fire.json (Central cross -- medium-high density):**
- Keep existing cross wall structure
- Add Heavy (4) destructibles near the center cross
- Fill dead-end areas with Medium (5) and Light (6) destructibles
- Create interesting sight lines that can be modified by destruction

**pillars.json (Scattered cover -- low-medium density):**
- Keep existing pillar pairs as indestructible (tile 3)
- Add Light (6) and Medium (5) destructible "barricades" between pillar pairs
- Create cover positions that Paran can smash through

Important layout rules:
- Never place obstacles on spawn points (check shared/maps.ts for spawn coordinates, convert to tile coords: Math.floor(px / 32))
- Keep at least 1-tile-wide navigable paths (players are 24px wide with 12px radius, tiles are 32px -- fits comfortably)
- Border walls remain tile 3 (indestructible)
  </action>
  <verify>
Open each map JSON file and verify: (1) Walls layer data array has correct length (25*19=475 elements), (2) border tiles are all 3, (3) new obstacle tiles (4,5,6) appear in interior positions, (4) no obstacles placed on spawn point tiles. Verify placeholder.png exists and tiles 4-6 have distinct colors.
  </verify>
  <done>
All 4 map JSON files updated with strategically placed destructible obstacles (tile IDs 4-6). Tileset PNG has visually distinct tiles for each obstacle tier. Spawn points remain clear. Maps have appropriate density per their design intent.
  </done>
</task>

</tasks>

<verification>
1. `shared/collisionGrid.ts` and `shared/obstacles.ts` exist and export all documented types
2. CollisionGrid constructor correctly parses a walls layer array into a 2D grid
3. resolveCollisions returns correct hitX/hitY flags and pushes entity out of solid tiles
4. Tileset has 3 new visually distinct obstacle tile graphics
5. All 4 map JSON files contain obstacle tiles with correct density
6. No obstacles placed on spawn points in any map
7. TypeScript compiles cleanly for both server and client
</verification>

<success_criteria>
- Shared collision infrastructure compiles and is importable by both server and client
- All 4 maps have obstacles placed with appropriate density and strategic intent
- Tileset has visually distinct tiles for indestructible walls and 3 destructible tiers
- No regression in existing code (TypeScript compiles, server starts)
</success_criteria>

<output>
After completion, create `.planning/phases/05.1-arenas-should-have-obstacles-and-walls-that-players-collides-with-also-paran-should-be-able-to-instantly-kill-faran-or-baran-when-he-collides-with-them/05.1-01-SUMMARY.md`
</output>
