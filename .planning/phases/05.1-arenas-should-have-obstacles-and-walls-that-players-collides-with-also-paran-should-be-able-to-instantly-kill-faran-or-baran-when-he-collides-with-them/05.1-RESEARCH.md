# Phase 05.1: Arena Collisions & Paran Contact Kill - Research

**Researched:** 2026-02-11
**Domain:** Tile-based collision detection, server-authoritative physics, destructible map objects, contact kill mechanics
**Confidence:** HIGH

## Summary

This phase adds tile-based obstacle collision for all players, projectile-wall destruction, destructible obstacles with 3 durability tiers, and Paran's signature contact kill mechanic. The current codebase uses server-authoritative physics with client prediction, where the server performs pure math (no Phaser) and the client uses a shared `applyMovementPhysics()` function. Collision detection against map obstacles must therefore be implemented as a **shared collision grid** (a 2D array of tile collision data) that both server and client prediction can query without any Phaser dependency.

The 4 existing maps use Tiled JSON format with 25x19 tiles at 32x32px (800x608 total). Each map has a "Ground" layer (all tile ID 2 = floor) and a "Walls" layer (tile ID 3 = wall, 0 = empty). The server currently ignores tile data entirely -- it only clamps player positions to `ARENA = { width: 800, height: 600 }`. The wall tiles around map borders are purely visual. This phase must bridge that gap: the server needs to load map collision data and enforce tile-based collisions for players and projectiles.

**Primary recommendation:** Create a shared `CollisionGrid` class that parses Tiled JSON wall layer data into a queryable 2D boolean/number array. Both server (GameRoom.fixedTick) and client (PredictionSystem) use it to resolve AABB-vs-tile collisions after position integration. Destructible obstacles are tracked via a separate Colyseus `MapSchema` keyed by `"tileX,tileY"` string, synced to clients for both physics and visual updates.

<user_constraints>
## User Constraints (from CONTEXT.md)

### Locked Decisions

#### Wall & obstacle collision behavior
- All players collide with tile-based obstacles (aligned to tile grid, using collision layer)
- On obstacle hit: full stop + resolve overlap (player stops exactly at obstacle edge)
- Arena edges: existing behavior preserved (clamp position)
- Mid-arena obstacles: separate collision response from edges (full stop + pushback to edge)
- Paran wall penalty (lose ALL velocity) applies to mid-arena obstacles too -- obstacles become strategic tools for guardians to use against Paran
- Guardians: just resolve overlap on obstacle hit (stop at edge, no velocity penalty beyond stopping)
- All 4 existing maps (open_arena, corridor_chaos, cross_fire, pillars) must be updated with obstacle layouts
- Obstacles visually distinct from floor tiles (different color/appearance, clearly readable as blocking)

#### Paran contact kill mechanics
- Any Paran-guardian hitbox overlap = instant kill, regardless of Paran speed (no speed threshold)
- Instant kill bypasses HP -- guardian dies immediately regardless of remaining health
- One-directional: only Paran kills guardians on contact. Guardian touching Paran has no effect
- After contact kill, Paran keeps moving (maintains velocity, passes through killed guardian) -- chain kills possible
- Paran is always a lethal contact threat, even when stationary

#### Projectile-wall interaction
- Projectiles destroyed on contact with any wall or obstacle (both arena edges and mid-arena obstacles)
- No ricochet or bounce mechanics -- projectiles simply disappear on wall contact
- No impact visual effect -- clean destroy (projectile just disappears)
- Projectiles can pass through 1-tile gaps between obstacles if aimed correctly (skill-based)
- Collision detection respects gap geometry based on projectile hitbox size vs tile size

#### Obstacle types & destructibility
- Two categories: indestructible obstacles and destructible obstacles
- Destructible obstacles have 3 tiers:
  - Light: 1-2 projectile hits to destroy
  - Medium: ~3 projectile hits to destroy
  - Heavy: 5+ projectile hits to destroy
- Paran contact instant-breaks any destructible obstacle (regardless of tier)
- Projectiles take multiple hits based on tier to destroy
- Each tier should be visually distinguishable (different appearance per durability level)
- Map designers decide mix of indestructible vs destructible per map

### Claude's Discretion
- Exact hit points per destructible tier (within the ranges above)
- Visual style for each obstacle tier
- Obstacle density and layout per map (balanced for gameplay)
- Destruction animation/effect (if any)
- How destroyed obstacles sync to clients (Schema removal vs state flag)
- Exact collision detection algorithm for tile-based obstacles

### Deferred Ideas (OUT OF SCOPE)
None -- discussion stayed within phase scope
</user_constraints>

## Standard Stack

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| Colyseus | 0.15.57 | Server state sync for destructible obstacles | Already in use; MapSchema ideal for keyed obstacle state |
| @colyseus/schema | 0.15.x | Schema definitions for Obstacle type | Already in use; pairs with Colyseus 0.15 |
| Phaser | 3.90 | Client rendering of tilemap layers + obstacle visuals | Already in use; tilemap APIs handle visual layer updates |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| shared/physics.ts | N/A | Shared collision grid + collision resolution | Extend with CollisionGrid class for server+client use |
| shared/maps.ts | N/A | Map metadata with collision data paths | Extend to reference collision layer data |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| Custom CollisionGrid | Phaser Arcade Physics on server | Server has no Phaser -- cannot use. Custom grid is correct |
| MapSchema for obstacles | ArraySchema for obstacles | MapSchema allows O(1) lookup by coordinate key; ArraySchema requires linear scan |
| Embedded collision data in map JSON | Separate collision files | Map JSON already has wall layer data; parse it directly -- no new files needed |

**Installation:** No new packages required. All dependencies already installed.

## Architecture Patterns

### Current Architecture (Before Phase 05.1)

```
shared/
  physics.ts       # applyMovementPhysics(), ARENA bounds, PHYSICS constants
  characters.ts    # CHARACTERS stats, COMBAT constants (playerRadius=12, projectileRadius=4)
  maps.ts          # MAPS[] metadata (name, file, dimensions, spawnPoints)

server/
  rooms/GameRoom.ts # fixedTick(): physics -> edge clamp -> projectile move -> hit detection

client/
  systems/Prediction.ts  # sendInput() + reconcile() using shared physics
  scenes/GameScene.ts     # Tilemap rendering, input, sprite management
```

### Recommended Project Structure (After Phase 05.1)

```
shared/
  physics.ts         # applyMovementPhysics() -- UNCHANGED
  characters.ts      # CHARACTERS, COMBAT -- UNCHANGED
  maps.ts            # MapMetadata extended with obstacle tile IDs; MAPS[] updated
  collisionGrid.ts   # NEW: CollisionGrid class (parse tile data, AABB queries)
  obstacles.ts       # NEW: Obstacle constants (tier HP values, tile ID mappings)

server/
  schema/GameState.ts   # MODIFIED: add obstacles MapSchema<ObstacleState>
  schema/Obstacle.ts    # NEW: ObstacleState schema (x, y, hp, tier, destroyed)
  rooms/GameRoom.ts     # MODIFIED: load collision grid, tile collision in fixedTick,
                        #   Paran contact kill, projectile-wall + projectile-obstacle,
                        #   destructible obstacle HP tracking

client/
  systems/Prediction.ts   # MODIFIED: apply collision grid during prediction + reconciliation
  scenes/GameScene.ts      # MODIFIED: load collision grid for client, render obstacle changes,
                           #   visual updates on obstacle destruction
  public/maps/*.json       # MODIFIED: add obstacle tiles to Walls layer or new Obstacles layer
  public/tilesets/placeholder.png  # MODIFIED: add new tile graphics for obstacle tiers
```

### Pattern 1: Shared Collision Grid

**What:** A pure-TypeScript class that converts Tiled JSON wall/obstacle layer data into a 2D grid, then provides AABB-vs-tile queries for both server and client.

**When to use:** Every physics tick on server, every prediction step on client.

**Example:**
```typescript
// shared/collisionGrid.ts

export interface TileInfo {
  solid: boolean;       // true = blocks movement
  destructible: boolean; // true = can be destroyed
  tileId: number;       // original tile ID from map data
}

export class CollisionGrid {
  private grid: TileInfo[][];
  readonly width: number;   // tiles
  readonly height: number;  // tiles
  readonly tileSize: number;

  constructor(
    wallLayerData: number[],
    mapWidth: number,
    mapHeight: number,
    tileSize: number,
    destructibleTileIds: Set<number>,
    indestructibleTileIds: Set<number>
  ) {
    this.width = mapWidth;
    this.height = mapHeight;
    this.tileSize = tileSize;
    this.grid = [];

    for (let y = 0; y < mapHeight; y++) {
      this.grid[y] = [];
      for (let x = 0; x < mapWidth; x++) {
        const tileId = wallLayerData[y * mapWidth + x];
        const isDestructible = destructibleTileIds.has(tileId);
        const isIndestructible = indestructibleTileIds.has(tileId);
        this.grid[y][x] = {
          solid: isDestructible || isIndestructible,
          destructible: isDestructible,
          tileId,
        };
      }
    }
  }

  isSolid(tileX: number, tileY: number): boolean {
    if (tileX < 0 || tileX >= this.width || tileY < 0 || tileY >= this.height) {
      return true; // Out of bounds = solid
    }
    return this.grid[tileY][tileX].solid;
  }

  clearTile(tileX: number, tileY: number): void {
    if (tileX >= 0 && tileX < this.width && tileY >= 0 && tileY < this.height) {
      this.grid[tileY][tileX].solid = false;
      this.grid[tileY][tileX].destructible = false;
    }
  }

  // Convert world position to tile coordinates
  worldToTile(worldX: number, worldY: number): { tileX: number; tileY: number } {
    return {
      tileX: Math.floor(worldX / this.tileSize),
      tileY: Math.floor(worldY / this.tileSize),
    };
  }
}
```

### Pattern 2: AABB-vs-Tile Collision Resolution

**What:** After integrating position (in applyMovementPhysics or after it), check if the player's bounding box overlaps any solid tiles. Resolve by pushing player out along the axis of least penetration. Handle X and Y axes separately to allow "sliding" along walls (important for guardians) and to correctly detect which axis hit a wall (important for Paran's full velocity loss).

**When to use:** After every position integration step, before edge clamping.

**Example:**
```typescript
// shared/collisionGrid.ts - collision resolution function

export interface CollidableEntity {
  x: number;
  y: number;
  vx: number;
  vy: number;
  role?: string;
}

/**
 * Resolve AABB-vs-tile collisions for an entity.
 * Uses "resolve X first, then Y" approach with half-size radius.
 * Returns true if any collision occurred.
 */
export function resolveCollisions(
  entity: CollidableEntity,
  radius: number,
  grid: CollisionGrid,
  prevX: number,
  prevY: number
): { hitX: boolean; hitY: boolean; hitTiles: { tileX: number; tileY: number }[] } {
  const hitTiles: { tileX: number; tileY: number }[] = [];
  let hitX = false;
  let hitY = false;
  const ts = grid.tileSize;

  // Resolve X axis first (using previous Y position for stability)
  const left = entity.x - radius;
  const right = entity.x + radius;
  const top = prevY - radius;
  const bottom = prevY + radius;

  const tileLeft = Math.floor(left / ts);
  const tileRight = Math.floor(right / ts);
  const tileTop = Math.floor(top / ts);
  const tileBottom = Math.floor(bottom / ts);

  for (let ty = tileTop; ty <= tileBottom; ty++) {
    for (let tx = tileLeft; tx <= tileRight; tx++) {
      if (grid.isSolid(tx, ty)) {
        hitX = true;
        hitTiles.push({ tileX: tx, tileY: ty });
        // Push out of tile
        if (entity.x > prevX) {
          // Moving right -- push left
          entity.x = tx * ts - radius;
        } else {
          // Moving left -- push right
          entity.x = (tx + 1) * ts + radius;
        }
      }
    }
  }

  // Resolve Y axis (using resolved X position)
  const left2 = entity.x - radius;
  const right2 = entity.x + radius;
  const top2 = entity.y - radius;
  const bottom2 = entity.y + radius;

  const tileLeft2 = Math.floor(left2 / ts);
  const tileRight2 = Math.floor(right2 / ts);
  const tileTop2 = Math.floor(top2 / ts);
  const tileBottom2 = Math.floor(bottom2 / ts);

  for (let ty = tileTop2; ty <= tileBottom2; ty++) {
    for (let tx = tileLeft2; tx <= tileRight2; tx++) {
      if (grid.isSolid(tx, ty)) {
        hitY = true;
        if (!hitTiles.some(t => t.tileX === tx && t.tileY === ty)) {
          hitTiles.push({ tileX: tx, tileY: ty });
        }
        if (entity.y > prevY) {
          entity.y = ty * ts - radius;
        } else {
          entity.y = (ty + 1) * ts + radius;
        }
      }
    }
  }

  return { hitX, hitY, hitTiles };
}
```

### Pattern 3: Destructible Obstacle State Sync via MapSchema

**What:** Track destructible obstacles as a `MapSchema<ObstacleState>` keyed by `"tileX,tileY"` string. When an obstacle is destroyed (HP reaches 0), set its `destroyed` flag and update the collision grid. Clients listen for changes and update tilemap visuals.

**When to use:** Whenever projectile or Paran collides with a destructible tile.

**Example:**
```typescript
// server/schema/Obstacle.ts
import { Schema, type } from "@colyseus/schema";

export class ObstacleState extends Schema {
  @type("uint8") tileX: number = 0;
  @type("uint8") tileY: number = 0;
  @type("uint8") hp: number = 0;
  @type("uint8") maxHp: number = 0;
  @type("boolean") destroyed: boolean = false;
}

// In GameState:
// @type({ map: ObstacleState }) obstacles = new MapSchema<ObstacleState>();
```

### Pattern 4: Paran Contact Kill (Circle-vs-Circle)

**What:** Each tick, check if Paran's hitbox overlaps any guardian's hitbox. If so, instant kill the guardian (health = 0). Uses the same `COMBAT.playerRadius` already used for projectile-player collision.

**When to use:** Every server tick, after position resolution, before win condition check.

**Example:**
```typescript
// In GameRoom.fixedTick(), after collision resolution:
const paranPlayer = /* find paran */;
if (paranPlayer && paranPlayer.health > 0) {
  this.state.players.forEach((target, targetId) => {
    if (target.role === "paran") return;
    if (target.health <= 0) return;

    const dx = paranPlayer.x - target.x;
    const dy = paranPlayer.y - target.y;
    const dist = Math.sqrt(dx * dx + dy * dy);

    if (dist < COMBAT.playerRadius * 2) {
      // Contact kill
      target.health = 0;
      // Track stats
      // ... (kills/deaths tracking)
    }
  });
}
```

### Anti-Patterns to Avoid

- **Using Phaser physics on server:** The server has no Phaser. All collision must be pure math. The shared CollisionGrid is the correct approach.
- **Modifying applyMovementPhysics for collision:** Keep physics and collision separate. Physics integrates position; collision resolves overlaps afterward. Mixing them breaks the separation of concerns and makes client prediction harder.
- **Using tile position as entity position:** Players use pixel-space positions (float), tiles use integer grid coordinates. Always convert correctly with `Math.floor(worldPos / tileSize)`.
- **Checking only the center point for collision:** Players have a radius of 12px. A player at x=63 with radius 12 spans from 51-75px. Must check ALL tiles the AABB touches, not just the center tile.
- **Syncing full collision grid every frame:** Only sync destructible obstacle state changes. The base collision grid is loaded from map data which both client and server have.

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Map data loading on server | Custom file reader | `require()` or `fs.readFileSync` for JSON | Tiled JSON is standard JSON; just import it |
| Tile coordinate math | Custom formulas | `Math.floor(worldPos / tileSize)` | Standard, proven, no edge cases if consistent |
| Obstacle state sync | Custom WebSocket messages | Colyseus MapSchema + onChange listeners | Already have Colyseus; MapSchema handles delta sync automatically |
| Tilemap visual updates | Manual canvas drawing | Phaser Tilemap `putTileAt` / `removeTileAt` | Phaser's tilemap API handles rendering |

**Key insight:** The server already does custom physics (no game engine). Collision detection is straightforward 2D AABB-vs-grid math -- no library needed. The complexity is in correctly sharing collision data between server and client prediction, and syncing destructible state changes.

## Common Pitfalls

### Pitfall 1: Client Prediction Desync from Missing Collision Grid
**What goes wrong:** Client prediction uses `applyMovementPhysics` but does NOT apply tile collisions, causing the predicted position to diverge from the server's. Player appears to jitter as server corrections fight client prediction.
**Why it happens:** The PredictionSystem currently only runs physics + edge clamping. Adding tile collision to the server without the client causes constant reconciliation corrections.
**How to avoid:** The PredictionSystem must have access to the same CollisionGrid and apply the same collision resolution after every predicted physics step.
**Warning signs:** Player visually passes through walls momentarily, then snaps back.

### Pitfall 2: ARENA Edge Clamp vs Tile Wall Collision Ordering
**What goes wrong:** If edge clamping happens before tile collision, a player near both an edge and a tile wall gets double-clamped. If tile collision happens first and pushes the player outside arena bounds, edge clamping then zeroes velocity incorrectly.
**Why it happens:** The current code does: physics -> edge clamp -> wall penalty. Adding tile collision between physics and edge clamp creates ordering dependencies.
**How to avoid:** Order: (1) Integrate position via physics, (2) Resolve tile collisions (including wall penalty for Paran), (3) Clamp to arena edges (existing code). Since border tiles ARE the arena edge in the tile grid, tile collision will naturally prevent players from reaching the arena edge clamp. The edge clamp becomes a safety net only.
**Warning signs:** Players get stuck in corners, or Paran loses velocity from edge clamp when they should have been stopped by a tile wall.

### Pitfall 3: Paran Wall Penalty Applied Per-Axis Instead of Per-Collision
**What goes wrong:** If collision detection resolves X and Y separately, and wall penalty is applied per-axis, Paran might lose X velocity from an X-axis wall hit but retain Y velocity, then hit a Y-axis wall and lose Y velocity too -- but the intent is "lose ALL velocity on ANY wall hit."
**Why it happens:** Separate axis resolution naturally reports hitX and hitY independently.
**How to avoid:** Check `hitX || hitY` at the end. If Paran hit ANY wall/obstacle, zero BOTH vx and vy.
**Warning signs:** Paran slides along walls instead of stopping dead.

### Pitfall 4: Destructible Obstacle Key Collisions in MapSchema
**What goes wrong:** Using `"x,y"` as MapSchema key with raw tile coordinates works, but if two maps have different obstacle layouts and the same coordinates, old data could leak if the map changes mid-session.
**Why it happens:** MapSchema keys persist until explicitly deleted.
**How to avoid:** Initialize obstacle MapSchema fresh in `onCreate` for each GameRoom. Each room uses one map, so no cross-contamination. Key format `"tileX,tileY"` is unambiguous within a single room.
**Warning signs:** Ghost obstacles appearing in wrong positions.

### Pitfall 5: Projectile Passing Through Thin Walls (Tunneling)
**What goes wrong:** A fast projectile (speed=400 px/s, dt=1/60) moves ~6.67px per tick. A tile is 32px wide. This is fine for single tiles, but if a projectile skips past a 1-tile-thick wall at a glancing angle, it could tunnel through.
**Why it happens:** Discrete position integration doesn't check intermediate positions.
**How to avoid:** Projectile speed (300-400 px/s) at 60Hz moves 5-6.67px/tick. Tiles are 32px wide. Even at max speed, a projectile moves less than one tile per tick, so point-in-tile checks are sufficient. No raycast needed. However, if future phases increase projectile speed, this should be revisited.
**Warning signs:** Projectiles appearing on the wrong side of walls.

### Pitfall 6: Obstacle Destruction Not Updating Client Collision Grid
**What goes wrong:** Server destroys an obstacle and syncs state via Schema. Client renders the tile removal visually but does NOT update its local CollisionGrid. Client prediction still treats the destroyed tile as solid, causing jitter.
**Why it happens:** Two separate systems: Phaser tilemap (visual) and CollisionGrid (prediction physics). Must update both.
**How to avoid:** When client receives obstacle destruction via Schema onChange, call BOTH `grid.clearTile(tileX, tileY)` AND update the Phaser tilemap visual.
**Warning signs:** Player can walk through visually-destroyed obstacles on server but prediction blocks them on client.

### Pitfall 7: "No-Input" Tick Velocity Integration Bypasses Collision
**What goes wrong:** The current `fixedTick` has a "no input received" path that does `player.x += player.vx * FIXED_DT; player.y += player.vy * FIXED_DT;` without any collision check after it.
**Why it happens:** That code path was added for network timing gaps and runs outside the normal physics pipeline.
**How to avoid:** The no-input path must ALSO run collision resolution after integrating position. Extract collision resolution into a function called in BOTH code paths.
**Warning signs:** Players clip through walls during network hiccups.

## Code Examples

### Loading Map Collision Data on Server

```typescript
// server/rooms/GameRoom.ts - in onCreate()
import * as fs from 'fs';
import * as path from 'path';
import { CollisionGrid } from '../../../shared/collisionGrid';
import { OBSTACLE_TILE_IDS } from '../../../shared/obstacles';

// Load the Tiled JSON map file
const mapPath = path.join(__dirname, '../../../client/public', this.mapMetadata.file);
const mapJson = JSON.parse(fs.readFileSync(mapPath, 'utf-8'));

// Extract wall/obstacle layer data
const wallLayer = mapJson.layers.find((l: any) => l.name === 'Walls');
const wallData: number[] = wallLayer.data;

// Build collision grid
this.collisionGrid = new CollisionGrid(
  wallData,
  mapJson.width,   // 25 tiles
  mapJson.height,  // 19 tiles
  mapJson.tilewidth, // 32px
  OBSTACLE_TILE_IDS.destructible,
  OBSTACLE_TILE_IDS.indestructible
);

// Initialize destructible obstacles in state
for (let y = 0; y < mapJson.height; y++) {
  for (let x = 0; x < mapJson.width; x++) {
    const tileId = wallData[y * mapJson.width + x];
    if (OBSTACLE_TILE_IDS.destructible.has(tileId)) {
      const obs = new ObstacleState();
      obs.tileX = x;
      obs.tileY = y;
      obs.maxHp = OBSTACLE_TIER_HP[tileId];
      obs.hp = obs.maxHp;
      this.state.obstacles.set(`${x},${y}`, obs);
    }
  }
}
```

### Client Loading Collision Grid for Prediction

```typescript
// client/src/scenes/GameScene.ts - in map load callback
// After loading the Tiled JSON, also build collision grid for prediction
const mapData = this.cache.tilemap.get(mapKey);
const wallLayer = mapData.data.layers.find((l: any) => l.name === 'Walls');
this.collisionGrid = new CollisionGrid(
  wallLayer.data,
  mapData.data.width,
  mapData.data.height,
  mapData.data.tilewidth,
  OBSTACLE_TILE_IDS.destructible,
  OBSTACLE_TILE_IDS.indestructible
);

// Pass collision grid to prediction system
if (this.prediction) {
  this.prediction.setCollisionGrid(this.collisionGrid);
}
```

### Updated PredictionSystem with Collision

```typescript
// client/src/systems/Prediction.ts
import { CollisionGrid, resolveCollisions } from '../../../shared/collisionGrid';
import { COMBAT } from '../../../shared/characters';

export class PredictionSystem {
  private collisionGrid: CollisionGrid | null = null;

  setCollisionGrid(grid: CollisionGrid): void {
    this.collisionGrid = grid;
  }

  sendInput(input: InputState, room: Room): void {
    // ... existing input send code ...

    // Store previous position
    const prevX = this.localState.x;
    const prevY = this.localState.y;

    // Apply physics (existing)
    applyMovementPhysics(this.localState, input, 1 / 60, { ... });

    // Apply tile collision (NEW)
    if (this.collisionGrid) {
      const result = resolveCollisions(
        this.localState,
        COMBAT.playerRadius,
        this.collisionGrid,
        prevX,
        prevY
      );
      if (result.hitX || result.hitY) {
        if (this.role === 'paran') {
          this.localState.vx = 0;
          this.localState.vy = 0;
        } else {
          if (result.hitX) this.localState.vx = 0;
          if (result.hitY) this.localState.vy = 0;
        }
      }
    }

    // ... existing pending input storage ...
  }

  reconcile(serverState: { ... }): void {
    // ... existing reconcile code ...
    // Replay must also apply collision after each physics step
    for (const pending of this.pendingInputs) {
      const prevX = this.localState.x;
      const prevY = this.localState.y;
      applyMovementPhysics(this.localState, pending.input, 1 / 60, { ... });
      if (this.collisionGrid) {
        const result = resolveCollisions(
          this.localState, COMBAT.playerRadius,
          this.collisionGrid, prevX, prevY
        );
        if (result.hitX || result.hitY) {
          if (this.role === 'paran') {
            this.localState.vx = 0;
            this.localState.vy = 0;
          } else {
            if (result.hitX) this.localState.vx = 0;
            if (result.hitY) this.localState.vy = 0;
          }
        }
      }
    }
  }
}
```

### Obstacle Tile ID Mapping

```typescript
// shared/obstacles.ts

// Tile IDs in the placeholder tileset (1-based, matching Tiled format)
// Current: 1=unused, 2=floor, 3=wall (indestructible), 4-8=available
export const OBSTACLE_TILES = {
  WALL: 3,          // Existing indestructible wall
  HEAVY: 4,         // Heavy destructible (5 HP)
  MEDIUM: 5,        // Medium destructible (3 HP)
  LIGHT: 6,         // Light destructible (2 HP)
  // 7, 8 reserved for damaged states or future use
} as const;

export const OBSTACLE_TIER_HP: Record<number, number> = {
  [OBSTACLE_TILES.HEAVY]: 5,
  [OBSTACLE_TILES.MEDIUM]: 3,
  [OBSTACLE_TILES.LIGHT]: 2,
};

export const OBSTACLE_TILE_IDS = {
  indestructible: new Set([OBSTACLE_TILES.WALL]),
  destructible: new Set([OBSTACLE_TILES.HEAVY, OBSTACLE_TILES.MEDIUM, OBSTACLE_TILES.LIGHT]),
};
```

### Tileset Expansion

The current placeholder tileset is 128x64px (4x2 tiles, 8 tiles total). It needs to be expanded to include distinct visuals for the 3 destructible tiers. The tileset can be expanded by adding a new row (128x96 = 4x3 = 12 tiles) or using the existing unused tiles (IDs 1, 4, 5, 6, 7, 8). Since tiles 4-8 are available:

| Tile ID | Purpose | Suggested Visual |
|---------|---------|-----------------|
| 1 | (unused/transparent) | Keep as-is |
| 2 | Floor | Dark green (existing) |
| 3 | Indestructible wall | Bright green (existing) |
| 4 | Heavy destructible | Dark red/brown |
| 5 | Medium destructible | Orange/tan |
| 6 | Light destructible | Light yellow/sand |
| 7 | Reserved (damaged state or future) | - |
| 8 | Reserved (damaged state or future) | - |

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Pixel-perfect collision | AABB + tile grid | Standard since 1990s | Tile grids are fast, simple, correct for axis-aligned obstacles |
| Client-side physics with server validation | Server-authoritative with client prediction | Industry standard | Server must own collision resolution; client predicts |
| Full state broadcast for map changes | Delta-sync via Schema | Colyseus design | Only changed obstacle HP/destroyed syncs, not entire grid |

## Discretion Recommendations

### Exact HP per Destructible Tier
- **Light:** 2 HP (2 projectile hits, each dealing 10 damage from guardians -- projectile damage is 10, so 2 hits)
- **Medium:** 3 HP
- **Heavy:** 5 HP
- Rationale: HP represents "number of hits" not damage amount. Each projectile hit reduces HP by 1 regardless of damage value. This decouples obstacle durability from character damage balance.

### Visual Style for Obstacle Tiers
- Use distinct colors in the placeholder tileset that read clearly at 32x32:
  - Indestructible (tile 3): Keep existing bright green -- players already recognize it as wall
  - Heavy (tile 4): Dark brownish-red -- looks tough, clearly different from walls
  - Medium (tile 5): Orange/amber -- medium durability feel
  - Light (tile 6): Pale yellow/sand -- looks fragile
- All tiles should have a subtle border/outline to be visually distinguishable from floor tiles

### Obstacle Density Per Map
- **test_arena (open arena):** Low density -- a few scattered obstacles in the center. Currently has minimal walls (L-shaped blocks). Add 4-6 destructible clusters. Keep spawn areas clear.
- **corridor_chaos:** Medium density -- add destructible obstacles in corridor interiors so Paran can "break through." Keep corridors navigable but add cover. Mix light and medium destructibles.
- **cross_fire:** Medium-high density -- the cross structure already constrains movement. Add destructible fill in dead-end areas. Heavy destructibles near the center cross.
- **pillars:** Low-medium density -- existing pillar pairs are indestructible. Add light/medium destructible "barricades" between pillars for additional cover that Paran can smash.

### Destruction Animation
- No animation for now (KISS). When an obstacle is destroyed:
  - Server: set `destroyed = true`, clear collision grid tile
  - Client: remove the tile from tilemap (replace with floor tile ID or empty)
  - Keep it clean and functional. Visual polish can come in a later UX phase.

### Destroyed Obstacle Sync Strategy
- **Use `destroyed` boolean flag on ObstacleState**, not removal from MapSchema.
  - Reason: Schema removal triggers `onRemove` callbacks, which is fine but means the client loses the position reference. A `destroyed` flag via `onChange` is simpler -- client already has the obstacle's tileX/tileY and can update both collision grid and tilemap visual in one handler.
  - Additionally, keeping destroyed obstacles in state allows late-joining or reconnecting clients to see the full map state (which tiles have been destroyed).

### Collision Detection Algorithm
- **Swept AABB is unnecessary.** At 60Hz with max player speed 300px/s, a player moves 5px/tick. With 32px tiles and 12px player radius, there is no tunneling risk. Simple overlap-then-resolve is sufficient.
- **Axis-separated resolution** (resolve X first, then Y) prevents corner-stuck issues and correctly identifies which axis hit.

## Open Questions

1. **Arena bounds constant vs tile-based bounds**
   - What we know: ARENA = { width: 800, height: 600 } but maps are 800x608 (25*32 x 19*32). The current edge clamp uses ARENA bounds, which are 8px shorter than the actual map height.
   - What's unclear: Should ARENA be updated to 800x608 to match map dimensions? Or should the tile-based border walls handle this (they already exist in all maps)?
   - Recommendation: Update ARENA to match map pixel dimensions (800x608). The border wall tiles provide the actual collision boundary. Edge clamping becomes a safety net at map pixel edges. This also fixes the 8px discrepancy at the bottom of the map.

2. **Player radius vs tile alignment**
   - What we know: Players have radius 12px (COMBAT.playerRadius). Tiles are 32px. A player's AABB is 24px wide, meaning players can navigate 1-tile (32px) gaps with 8px clearance on each side.
   - What's unclear: Should player radius be adjusted for better gap navigation feel?
   - Recommendation: Keep radius at 12px. 32px gaps with 24px players leaves comfortable margins. This satisfies the "projectiles can pass through 1-tile gaps" requirement (projectile radius=4, so 8px diameter easily fits in 32px gap).

3. **Map data loading on server -- path resolution**
   - What we know: Server needs to read Tiled JSON files that are currently in `client/public/maps/`. The server runs from `server/src/`.
   - What's unclear: Will `path.join(__dirname, '...')` resolve correctly in the compiled output?
   - Recommendation: Since the project uses TypeScript compilation, use a path relative to the project root. Test the path resolution during implementation. Alternative: copy map JSON into shared/ or embed collision data in shared/maps.ts directly.

## Sources

### Primary (HIGH confidence)
- **Codebase analysis** - Direct reading of all source files: server/src/rooms/GameRoom.ts, shared/physics.ts, shared/maps.ts, shared/characters.ts, client/src/systems/Prediction.ts, client/src/scenes/GameScene.ts, all 4 map JSON files, tileset image
- **/colyseus/docs** (Context7) - Schema, ArraySchema, MapSchema usage patterns for state sync
- **/websites/phaser_io_api-documentation** (Context7) - Tilemap API: getTileAtWorldXY, worldToTileXY, HasTileAt, setCollisionByProperty

### Secondary (MEDIUM confidence)
- **Tile-based collision resolution patterns** - Standard game development technique (axis-separated AABB resolution). Well-documented in game programming literature.

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - No new dependencies; all patterns use existing Colyseus + Phaser stack
- Architecture: HIGH - CollisionGrid pattern is standard for server-authoritative tile-based games; codebase structure is well understood
- Pitfalls: HIGH - All pitfalls identified from direct codebase analysis (no-input path, edge clamp ordering, prediction desync)
- Collision algorithm: HIGH - AABB-vs-tile is textbook; player speed vs tile size confirms no tunneling risk

**Research date:** 2026-02-11
**Valid until:** 2026-03-11 (stable domain, no dependency version concerns)
