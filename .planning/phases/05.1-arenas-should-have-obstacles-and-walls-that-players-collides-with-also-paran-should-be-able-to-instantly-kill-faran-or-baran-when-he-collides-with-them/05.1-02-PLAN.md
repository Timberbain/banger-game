---
phase: 05.1-arena-collisions-contact-kill
plan: 02
type: execute
wave: 2
depends_on: ["05.1-01"]
files_modified:
  - server/src/schema/Obstacle.ts
  - server/src/schema/GameState.ts
  - server/src/rooms/GameRoom.ts
  - shared/physics.ts
autonomous: true

must_haves:
  truths:
    - "All players are physically blocked by tile-based obstacles (cannot walk through walls or obstacle tiles)"
    - "Paran loses ALL velocity (both vx and vy) when hitting any wall or obstacle"
    - "Guardians stop at obstacle edge without extra velocity penalty beyond stopping"
    - "Paran instantly kills guardians on body-to-body collision (circle overlap), regardless of speed"
    - "After contact kill, Paran maintains velocity and passes through the killed guardian"
    - "Projectiles are destroyed on contact with any wall or obstacle tile"
    - "Destructible obstacles lose 1 HP per projectile hit and are destroyed at 0 HP"
    - "Paran contact instant-breaks any destructible obstacle regardless of tier"
    - "Destroyed obstacles are cleared from collision grid and synced to clients via Schema"
    - "No-input tick code path also runs collision resolution (no clipping during network gaps)"
    - "ARENA dimensions updated to 800x608 to match actual map pixel dimensions"
  artifacts:
    - path: "server/src/schema/Obstacle.ts"
      provides: "ObstacleState schema for destructible obstacle sync"
      exports: ["ObstacleState"]
      contains: "class ObstacleState extends Schema"
    - path: "server/src/schema/GameState.ts"
      provides: "Updated GameState with obstacles MapSchema"
      contains: "obstacles"
    - path: "server/src/rooms/GameRoom.ts"
      provides: "Full collision enforcement: tile collision, Paran contact kill, projectile-wall, destructible HP"
      contains: "resolveCollisions"
    - path: "shared/physics.ts"
      provides: "Updated ARENA constant (800x608)"
      contains: "height: 608"
  key_links:
    - from: "server/src/rooms/GameRoom.ts"
      to: "shared/collisionGrid.ts"
      via: "CollisionGrid instance loaded from map data, resolveCollisions called in fixedTick"
      pattern: "new CollisionGrid.*resolveCollisions"
    - from: "server/src/rooms/GameRoom.ts"
      to: "shared/obstacles.ts"
      via: "OBSTACLE_TILE_IDS and OBSTACLE_TIER_HP used for grid construction and HP lookup"
      pattern: "OBSTACLE_TILE_IDS.*OBSTACLE_TIER_HP"
    - from: "server/src/schema/GameState.ts"
      to: "server/src/schema/Obstacle.ts"
      via: "MapSchema<ObstacleState> for obstacle state sync"
      pattern: "MapSchema.*ObstacleState"
    - from: "server/src/rooms/GameRoom.ts"
      to: "server/src/schema/Obstacle.ts"
      via: "ObstacleState instances created in onCreate, modified on projectile/Paran hit"
      pattern: "new ObstacleState"
---

<objective>
Implement server-side collision enforcement, Paran contact kill mechanic, and destructible obstacle system.

Purpose: This is the core gameplay plan. The server must enforce tile collisions for all players (not just visual), apply Paran's wall penalty to mid-arena obstacles, check for Paran-guardian body collisions (instant kill), destroy projectiles on wall/obstacle contact, and track destructible obstacle HP with Schema-based sync to clients. The server is the authority -- if it doesn't enforce collisions, they don't exist.

Output: ObstacleState schema, updated GameState, GameRoom with full collision pipeline, ARENA fix.
</objective>

<execution_context>
@/Users/jonasbrandvik/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jonasbrandvik/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05.1-arenas-should-have-obstacles-and-walls-that-players-collides-with-also-paran-should-be-able-to-instantly-kill-faran-or-baran-when-he-collides-with-them/05.1-01-SUMMARY.md
@shared/collisionGrid.ts
@shared/obstacles.ts
@shared/physics.ts
@shared/characters.ts
@shared/maps.ts
@server/src/rooms/GameRoom.ts
@server/src/schema/GameState.ts
@server/src/schema/Projectile.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ObstacleState schema, update GameState, and fix ARENA dimensions</name>
  <files>server/src/schema/Obstacle.ts, server/src/schema/GameState.ts, shared/physics.ts</files>
  <action>
**Create server/src/schema/Obstacle.ts:**
```typescript
import { Schema, type } from "@colyseus/schema";

export class ObstacleState extends Schema {
  @type("uint8") tileX: number = 0;
  @type("uint8") tileY: number = 0;
  @type("uint8") hp: number = 0;
  @type("uint8") maxHp: number = 0;
  @type("boolean") destroyed: boolean = false;
}
```

**Update server/src/schema/GameState.ts:**
- Import `ObstacleState` from `./Obstacle`
- Add to GameState class: `@type({ map: ObstacleState }) obstacles = new MapSchema<ObstacleState>();`

**Update shared/physics.ts:**
- Change `ARENA.height` from 600 to 608 to match actual map pixel dimensions (25 tiles x 32px = 800, 19 tiles x 32px = 608). This fixes the 8px discrepancy at the bottom of the map. The border wall tiles already exist at row 18 (y=576-608) in all maps, so the edge clamp becomes a safety net behind the tile collision.
  </action>
  <verify>
Run `npx tsc --noEmit` from server/ to confirm schema compiles. Verify ObstacleState has all 5 fields. Verify GameState has obstacles MapSchema. Verify ARENA.height is 608.
  </verify>
  <done>
ObstacleState schema exists with tileX, tileY, hp, maxHp, destroyed fields. GameState has obstacles MapSchema. ARENA height fixed to 608 matching map dimensions.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement collision enforcement, contact kill, and destructible obstacles in GameRoom</name>
  <files>server/src/rooms/GameRoom.ts</files>
  <action>
This is the core gameplay task. Modify GameRoom.ts extensively:

**In onCreate():**
1. Import `CollisionGrid`, `resolveCollisions` from shared/collisionGrid.ts
2. Import `OBSTACLE_TILE_IDS`, `OBSTACLE_TIER_HP` from shared/obstacles.ts
3. Import `ObstacleState` from schema/Obstacle.ts
4. Import `fs` and `path` from Node.js
5. Add class member: `private collisionGrid!: CollisionGrid;`
6. After selecting map, load the Tiled JSON map file:
   ```
   const mapPath = path.join(__dirname, '../../../../client/public', this.mapMetadata.file);
   const mapJson = JSON.parse(fs.readFileSync(mapPath, 'utf-8'));
   ```
   Note: path from compiled server output `server/dist/rooms/` to `client/public/` -- verify and adjust `__dirname` path. If using ts-node-dev (no dist), path is `../../../client/public/`.
7. Extract wall layer data: `const wallLayer = mapJson.layers.find((l: any) => l.name === 'Walls');`
8. Build collision grid: `this.collisionGrid = new CollisionGrid(wallLayer.data, mapJson.width, mapJson.height, mapJson.tilewidth, OBSTACLE_TILE_IDS.destructible, OBSTACLE_TILE_IDS.indestructible);`
9. Initialize destructible obstacles in state:
   ```
   for (let y = 0; y < mapJson.height; y++) {
     for (let x = 0; x < mapJson.width; x++) {
       const tileId = wallLayer.data[y * mapJson.width + x];
       if (OBSTACLE_TILE_IDS.destructible.has(tileId)) {
         const obs = new ObstacleState();
         obs.tileX = x;
         obs.tileY = y;
         obs.maxHp = OBSTACLE_TIER_HP[tileId];
         obs.hp = obs.maxHp;
         this.state.obstacles.set(`${x},${y}`, obs);
       }
     }
   }
   ```

**In fixedTick() -- Player collision resolution:**
After the existing `applyMovementPhysics` call AND after the no-input velocity integration, add tile collision resolution. This needs to happen in BOTH code paths (with input and no-input):

Extract collision resolution into a helper method `resolvePlayerCollision(player: Player)`:
1. Store `prevX = player.x, prevY = player.y` BEFORE physics/integration
2. After physics/integration, call: `const result = resolveCollisions(player, COMBAT.playerRadius, this.collisionGrid, prevX, prevY);`
3. Handle Paran wall penalty: if `(result.hitX || result.hitY) && player.role === 'paran'`: zero BOTH vx and vy
4. Handle guardian wall response: if `result.hitX`: zero vx. If `result.hitY`: zero vy
5. Handle destructible obstacle breaking by Paran contact: if `player.role === 'paran'` and hitTiles contains destructible tiles, destroy them immediately:
   ```
   for (const tile of result.hitTiles) {
     const key = `${tile.tileX},${tile.tileY}`;
     const obs = this.state.obstacles.get(key);
     if (obs && !obs.destroyed) {
       obs.hp = 0;
       obs.destroyed = true;
       this.collisionGrid.clearTile(tile.tileX, tile.tileY);
     }
   }
   ```

Restructure the player processing loop in fixedTick:
- For each player (after skipping dead/disconnected):
  1. Save prevX, prevY
  2. Process input queue (existing code) -- call applyMovementPhysics per input
  3. After EACH applyMovementPhysics call, also call resolveCollisions and handle response
  4. For the no-input path (`!processedAny`): integrate position, THEN call resolveCollisions and handle response
  5. REMOVE the old edge-clamping code (`Math.max(0, Math.min(ARENA.width, player.x))`) since tile border walls now handle this. Keep edge clamp as a SAFETY NET after collision resolution but do NOT apply wall penalty from edge clamp anymore (tile collision handles it). Simplify to: `player.x = Math.max(0, Math.min(ARENA.width, player.x)); player.y = Math.max(0, Math.min(ARENA.height, player.y));` with no velocity zeroing from edge clamp.

**Paran Contact Kill (after collision resolution, before projectile processing):**
After processing all player collisions, check for Paran-guardian body overlap:
```
// Find Paran
let paranPlayer: Player | null = null;
let paranId: string = '';
this.state.players.forEach((p, id) => {
  if (p.role === 'paran' && p.health > 0) { paranPlayer = p; paranId = id; }
});

if (paranPlayer) {
  this.state.players.forEach((target, targetId) => {
    if (target.role === 'paran') return;
    if (target.health <= 0) return;
    if (targetId === paranId) return;

    const dx = paranPlayer!.x - target.x;
    const dy = paranPlayer!.y - target.y;
    const dist = Math.sqrt(dx * dx + dy * dy);

    if (dist < COMBAT.playerRadius * 2) {
      // Contact kill: instant death regardless of HP
      target.health = 0;
      // Track stats
      const paranStats = this.state.matchStats.get(paranId);
      if (paranStats) paranStats.kills++;
      const targetStats = this.state.matchStats.get(targetId);
      if (targetStats) targetStats.deaths++;
    }
  });
}
```
Note: Paran maintains velocity after contact kill (no velocity change). One-directional: only Paran kills guardians.

**Projectile-wall/obstacle collision (in projectile processing loop):**
After moving each projectile (`proj.x += proj.vx * FIXED_DT; proj.y += proj.vy * FIXED_DT`), check if projectile center overlaps any solid tile:
```
const projTile = this.collisionGrid.worldToTile(proj.x, proj.y);
if (this.collisionGrid.isSolid(projTile.tileX, projTile.tileY)) {
  // Check if destructible obstacle
  const obsKey = `${projTile.tileX},${projTile.tileY}`;
  const obs = this.state.obstacles.get(obsKey);
  if (obs && !obs.destroyed) {
    obs.hp--;
    if (obs.hp <= 0) {
      obs.destroyed = true;
      this.collisionGrid.clearTile(projTile.tileX, projTile.tileY);
    }
  }
  // Destroy projectile (remove from array)
  this.state.projectiles.splice(i, 1);
  continue;
}
```
This replaces the existing bounds check (which checked ARENA edges). The tile border walls and collision grid handle bounds. Keep the existing lifetime check. Remove the old bounds check (`proj.x < 0 || proj.x > ARENA.width...`) since tile collision handles it, OR keep it as a safety net after tile check.

Also consider the projectile's radius for tile collision: For precision, check all tiles the projectile AABB covers (not just center). Since projectile radius is 4px (8px diameter vs 32px tile), center-point check is sufficient for most cases. But for shooting through 1-tile gaps, we need correct behavior. Use center-point check for wall destruction but check if any corner of the projectile AABB hits a solid tile for collision destruction:
- Actually, for simplicity and per research findings: point check (projectile center) is sufficient. Projectile radius (4px) is small relative to tile size (32px). A projectile aimed at a 1-tile gap (32px wide, projectile 8px wide = 12px clearance each side) will pass through if aimed correctly.
  </action>
  <verify>
1. Start the server with `npm run dev` from server/ directory
2. Verify server starts without errors and logs collision grid loading
3. Verify ObstacleState instances are created for destructible tiles (check console log count)
4. Run `npx tsc --noEmit` to confirm type checking passes
  </verify>
  <done>
Server enforces tile-based collisions for all players. Paran loses ALL velocity on any wall/obstacle hit. Guardians stop at obstacle edges. Paran instantly kills guardians on body collision. Projectiles destroyed on wall/obstacle contact. Destructible obstacles lose HP from projectile hits and instant-break from Paran contact. No-input code path includes collision resolution. ARENA height fixed to 608.
  </done>
</task>

</tasks>

<verification>
1. Server starts cleanly and loads collision grid from map JSON
2. ObstacleState schema properly initialized for all destructible tiles
3. TypeScript compiles without errors
4. Collision resolution runs in both input-processing and no-input code paths
5. Contact kill correctly checks Paran-guardian circle overlap
6. Projectile-wall collision removes projectiles and damages destructibles
7. ARENA.height is 608 across shared code
</verification>

<success_criteria>
- Server loads collision grid on room creation and enforces tile collisions every tick
- Paran wall penalty applies to both arena edges and mid-arena obstacles (both vx and vy zeroed)
- Paran contact kill works: any overlap with guardian = instant death, Paran keeps velocity
- Projectiles destroyed on wall/obstacle contact, destructibles take 1 HP damage per hit
- Paran smashes through any destructible obstacle instantly
- No-input ticks also resolve collisions (no clipping through walls during network gaps)
</success_criteria>

<output>
After completion, create `.planning/phases/05.1-arenas-should-have-obstacles-and-walls-that-players-collides-with-also-paran-should-be-able-to-instantly-kill-faran-or-baran-when-he-collides-with-them/05.1-02-SUMMARY.md`
</output>
