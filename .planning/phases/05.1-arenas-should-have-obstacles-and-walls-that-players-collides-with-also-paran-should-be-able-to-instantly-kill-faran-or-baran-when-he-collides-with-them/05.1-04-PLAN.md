---
phase: 05.1-arena-collisions-contact-kill
plan: 04
type: execute
wave: 1
depends_on: []
files_modified: [shared/collisionGrid.ts]
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Characters collide with RIGHT and BOTTOM walls and stop cleanly, same as LEFT and TOP"
    - "Moving along a wall in a perpendicular direction works without speed exploits or jitter"
    - "Guardian diagonal into any wall slides along the non-colliding axis on all 4 edges"
    - "Paran wall penalty (zero ALL velocity) triggers only on actual wall hits, not false positives"
    - "Client prediction and server collision agree at tile boundaries (no reconciliation oscillation)"
    - "Obstacle tiles block characters identically to walls on all 4 sides"
  artifacts:
    - path: "shared/collisionGrid.ts"
      provides: "Symmetric AABB-vs-tile collision resolution for all 4 directions"
      contains: "epsilon"
  key_links:
    - from: "shared/collisionGrid.ts"
      to: "server/src/rooms/GameRoom.ts"
      via: "import resolveCollisions"
      pattern: "resolveCollisions"
    - from: "shared/collisionGrid.ts"
      to: "client/src/prediction/PredictionSystem.ts"
      via: "import resolveCollisions"
      pattern: "resolveCollisions"
---

<objective>
Fix Math.floor boundary asymmetry in resolveCollisions() that causes right/bottom wall collisions to jitter, produce super speed, and clip through walls.

Purpose: All 4 UAT failures (tests 1, 2, 4, 10) share this single root cause. The fix is in shared code so both server and client prediction get it automatically.
Output: Corrected `shared/collisionGrid.ts` with symmetric collision resolution on all 4 edges.
</objective>

<execution_context>
@/Users/jonasbrandvik/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jonasbrandvik/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/debug/collision-right-bottom-wall-bug.md
@.planning/phases/05.1-arenas-should-have-obstacles-and-walls-that-players-collides-with-also-paran-should-be-able-to-instantly-kill-faran-or-baran-when-he-collides-with-them/05.1-UAT.md
@shared/collisionGrid.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix Math.floor boundary asymmetry in resolveCollisions</name>
  <files>shared/collisionGrid.ts</files>
  <action>
Fix the right/bottom boundary asymmetry in the `resolveCollisions` function. The bug is that after push-back from RIGHT or DOWN solid tiles, the entity edge lands exactly on a tile boundary (e.g., `entity.x + radius = tx * tileSize`), and `Math.floor(exactInteger / tileSize)` maps back into the solid tile, causing perpetual re-collision.

Define a small epsilon constant at the top of the file:
```typescript
const COLLISION_EPSILON = 0.001;
```

**Fix 1 — Push-back positions (lines 153 and 185):**

For RIGHT push-back (line 153), subtract epsilon so the entity does not land exactly on the tile boundary:
```typescript
// Moving right: push to left edge of solid tile, minus epsilon to avoid boundary re-collision
entity.x = tx * tileSize - radius - COLLISION_EPSILON;
```

For DOWN push-back (line 185), same pattern:
```typescript
// Moving down: push to top edge of solid tile, minus epsilon to avoid boundary re-collision
entity.y = ty * tileSize - radius - COLLISION_EPSILON;
```

LEFT push-back (line 156) and UP push-back (line 188) are already correct — do NOT change them.

**Fix 2 — Tile range calculation (lines 139-140 and 170-171):**

For the RIGHT edge tile index calculation, subtract epsilon before flooring so that an entity edge sitting exactly on a tile boundary does not include that tile:
```typescript
const tileRight = Math.floor((right - COLLISION_EPSILON) / tileSize);
```

For the BOTTOM edge tile index calculation, same:
```typescript
const tileBottom = Math.floor((bottom - COLLISION_EPSILON) / tileSize);
```

Apply this in BOTH the X-axis resolution block (lines 139-142) and the Y-axis resolution block (lines 170-173). That means 4 lines total get the epsilon subtraction for right/bottom:

X-axis block:
- `tileRight = Math.floor((right - COLLISION_EPSILON) / tileSize);` (line ~140)
- `tileBottom` in this block uses `prevY`, same fix: `Math.floor((bottom - COLLISION_EPSILON) / tileSize);` (line ~142)

Y-axis block:
- `tileRight = Math.floor((right - COLLISION_EPSILON) / tileSize);` (line ~171)
- `tileBottom = Math.floor((bottom - COLLISION_EPSILON) / tileSize);` (line ~173)

**Why this works:** After RIGHT push-back, entity right edge is at `tx * tileSize - COLLISION_EPSILON`. The tile range calc computes `Math.floor((tx * tileSize - COLLISION_EPSILON - COLLISION_EPSILON) / tileSize)` which is `Math.floor(tx - 2*epsilon/tileSize)` = `tx - 1` (the empty tile). No re-collision. Same logic for DOWN/BOTTOM.

**What NOT to change:**
- LEFT push-back (`(tx + 1) * tileSize + radius`) — already correct
- UP push-back (`(ty + 1) * tileSize + radius`) — already correct
- `tileLeft` calculations — already correct (Math.floor of left edge naturally excludes left boundary)
- `tileTop` calculations — already correct
- No changes to any other file. The fix is entirely within `shared/collisionGrid.ts`.
  </action>
  <verify>
1. Run `npx tsc --noEmit -p server/tsconfig.json` — must compile with no errors
2. Run `npx tsc --noEmit -p client/tsconfig.json` — must compile with no errors
3. Manual arithmetic trace to verify symmetry:
   - RIGHT: entity at x=160, radius=8, tileSize=32. Push-back: entity.x = 160 - 8 - 0.001 = 151.999. Right edge = 159.999. tileRight = floor((159.999 - 0.001) / 32) = floor(159.998/32) = floor(4.99994) = 4 (empty tile, wall is at tile 5). Correct.
   - LEFT: entity at x=64, radius=8. Push-back: entity.x = 96 + 8 = 104. Left edge = 96. tileLeft = floor(96/32) = 3 (empty tile, wall is at tile 2). Correct.
   - DOWN: entity at y=160, radius=8. Push-back: entity.y = 160 - 8 - 0.001 = 151.999. Bottom edge = 159.999. tileBottom = floor((159.999-0.001)/32) = 4 (empty). Correct.
   - UP: entity at y=64, radius=8. Push-back: entity.y = 96 + 8 = 104. Top edge = 96. tileTop = floor(96/32) = 3 (empty). Correct.
  </verify>
  <done>
- resolveCollisions handles all 4 directions symmetrically with no re-collision at boundaries
- RIGHT and BOTTOM push-back positions include epsilon offset to avoid exact tile boundary
- Tile range calculations for right/bottom edges subtract epsilon before Math.floor
- Both server (GameRoom) and client (PredictionSystem) automatically get the fix via shared import
- TypeScript compiles cleanly for both server and client
  </done>
</task>

</tasks>

<verification>
After fixing collisionGrid.ts, the following UAT tests should now pass:
- Test 1: Wall collision blocks movement (all 4 edges, no jitter or speed exploits)
- Test 2: Obstacle collision blocks movement (same fix applies to all solid tiles)
- Test 4: Guardian diagonal wall sliding works on all 4 edges (no false hitX/hitY)
- Test 10: Client prediction matches server collision (no reconciliation oscillation at boundaries)

Previously passing tests (3, 5, 6, 7, 8, 9, 11, 12) must continue to pass — the epsilon is small enough (0.001 pixels) to be invisible but large enough to prevent Math.floor boundary overlap.
</verification>

<success_criteria>
- TypeScript compiles for both server and client with no errors
- COLLISION_EPSILON constant defined and used in 6 locations (2 push-backs + 4 tile range calcs)
- No changes to LEFT/UP push-back or tileLeft/tileTop calculations
- Arithmetic trace confirms symmetric behavior for all 4 directions
</success_criteria>

<output>
After completion, create `.planning/phases/05.1-arenas-should-have-obstacles-and-walls-that-players-collides-with-also-paran-should-be-able-to-instantly-kill-faran-or-baran-when-he-collides-with-them/05.1-04-SUMMARY.md`
</output>
