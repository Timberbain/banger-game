---
phase: 06-ux-polish
plan: 05
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - client/src/systems/AudioManager.ts
  - client/src/config/SoundDefs.ts
  - client/src/scenes/BootScene.ts
  - client/src/scenes/GameScene.ts
  - client/src/scenes/LobbyScene.ts
autonomous: true

must_haves:
  truths:
    - "Audio plays for shots, hits, deaths, and match events"
    - "Each role (Paran, Faran, Baran) has unique shot and hit sounds"
    - "Paran wall collision plays a distinct impact sound"
    - "UI sounds play for button clicks, countdown beeps, and match start"
    - "Separate Music and SFX volume sliders exist"
    - "Volume settings persist across sessions via localStorage"
    - "Music loop plays during gameplay"
    - "Audio starts only after first user interaction (browser autoplay policy)"
  artifacts:
    - path: "client/src/config/SoundDefs.ts"
      provides: "jsfxr parameter arrays for all procedural SFX"
      contains: "SOUND_DEFS"
    - path: "client/src/systems/AudioManager.ts"
      provides: "Centralized audio manager with jsfxr generation and volume controls"
      contains: "class AudioManager"
    - path: "client/src/scenes/BootScene.ts"
      provides: "Audio initialization after user interaction"
      contains: "AudioManager"
  key_links:
    - from: "client/src/systems/AudioManager.ts"
      to: "client/src/config/SoundDefs.ts"
      via: "imports SOUND_DEFS for jsfxr generation"
      pattern: "import.*SOUND_DEFS"
    - from: "client/src/scenes/GameScene.ts"
      to: "client/src/systems/AudioManager.ts"
      via: "AudioManager.playSFX() calls on game events"
      pattern: "audioManager\\.playSFX"
---

<objective>
Implement the complete audio system: procedural chiptune SFX via jsfxr, background music, character-specific sound profiles, UI sounds, and volume controls.

Purpose: Audio feedback makes the game feel alive and responsive. Character-specific sounds add identity, UI sounds provide interaction feedback, and music creates atmosphere.

Output: AudioManager with all SFX generated from jsfxr, integrated into gameplay and lobby scenes.
</objective>

<execution_context>
@/Users/jonasbrandvik/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jonasbrandvik/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-ux-polish/06-RESEARCH.md
@.planning/phases/06-ux-polish/06-01-SUMMARY.md
@client/src/scenes/BootScene.ts
@client/src/scenes/GameScene.ts
@client/src/scenes/LobbyScene.ts
@shared/characters.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SoundDefs and AudioManager</name>
  <files>client/src/config/SoundDefs.ts, client/src/systems/AudioManager.ts</files>
  <action>
    **SoundDefs.ts -- jsfxr parameter arrays:**

    Define `SOUND_DEFS: Record<string, number[]>` mapping sound keys to jsfxr parameter arrays.

    jsfxr parameter arrays follow the sfxr format (see jsfxr docs). Use the `jsfxr()` function which takes an array of parameters and returns a WAV data URL.

    Design sounds for chiptune aesthetic (8-bit/16-bit feel):

    **Combat sounds (per role):**
    - `paran_shoot`: Low-frequency laser blast (waveform=sawtooth, low frequency, short attack). Heavy, powerful.
    - `faran_shoot`: High-pitch quick dart (waveform=square, high frequency, very short). Rapid-fire feel.
    - `baran_shoot`: Medium-pitch energy shot (waveform=triangle, medium frequency). Steady, reliable.
    - `paran_hit`: Deep thud impact (noise + low freq, short).
    - `faran_hit`: Sharp ping impact (high freq, very short).
    - `baran_hit`: Medium crunch impact.
    - `paran_death`: Low explosion (noise, long decay, frequency slide down).
    - `faran_death`: High shatter (noise, short, frequency slide up then down).
    - `baran_death`: Medium crumble (noise, medium duration).

    **Movement sounds:**
    - `wall_impact`: Stone/metal clang (noise burst, very short, medium freq).
    - `speed_whoosh`: Wind rushing (noise, long attack, fade out, low volume). Play when Paran reaches high speed.

    **UI sounds:**
    - `button_click`: Short beep (square wave, very high freq, 50ms).
    - `countdown_beep`: Rising tone (square wave, ascending frequency).
    - `match_start_fanfare`: Quick ascending notes (square wave, freq slide up, 300ms).
    - `match_end_fanfare`: Descending notes (triangle wave, freq slide down, 500ms).
    - `ready_chime`: Pleasant ding (triangle wave, high freq, short decay).

    The jsfxr parameter format is an array of 24+ numbers. Use reasonable defaults and experiment with the waveform type (0=square, 1=sawtooth, 2=sine, 3=noise), attack, sustain, decay, frequency, and slide parameters. The exact arrays will need tuning -- start with the sfxr preset patterns:
    - Laser: [0, 0.1, , 0.2, 0.3, 0.8, , , , , , , , , , , , , 1, , , , , 0.5]
    - Explosion: [3, , , , 0.5, 0.1, , , , , , , , , , , , , 1, , , , , 0.5]
    - Pickup: [0, , , , 0.4, 0.4, , , , , , , , , , , , , 1, , , , , 0.5]
    - Hit: [3, , , , 0.4, 0.2, , , , , , , , , , , , , 1, , , , , 0.5]

    Note: If jsfxr's CJS/ESM interop fails with Vite, implement a local `jsfxr` function. The alternative approach from research: use the sfxr algorithm directly. But try `import jsfxr from 'jsfxr'` first, falling back to `const { jsfxr } = require('jsfxr')` or a local implementation.

    **AudioManager.ts:**

    ```typescript
    export class AudioManager {
      private scene: Phaser.Scene;
      private sfxVolume: number;
      private musicVolume: number;
      private sounds: Map<string, HTMLAudioElement> = new Map();
      private currentMusic: HTMLAudioElement | null = null;
      private initialized: boolean = false;

      constructor(scene: Phaser.Scene) {
        this.scene = scene;
        this.sfxVolume = parseFloat(localStorage.getItem('sfxVolume') || '0.7');
        this.musicVolume = parseFloat(localStorage.getItem('musicVolume') || '0.4');
      }
    ```

    **init() method:**
    - Generate all SFX from SOUND_DEFS using jsfxr.
    - For each key in SOUND_DEFS: `const dataUrl = jsfxr(params); const audio = new Audio(dataUrl); this.sounds.set(key, audio);`
    - Using HTMLAudioElement directly (not Phaser's sound manager) for data URL compatibility (per pitfall #5 from research).
    - Set `this.initialized = true`.

    **playSFX(key: string):**
    - If not initialized, return.
    - Get audio element from sounds map. Clone it (`audio.cloneNode()` for overlapping sounds). Set volume to `this.sfxVolume`. Call `.play()`.
    - Wrap in try/catch for autoplay policy errors.

    **playMusic(src: string, loop: boolean = true):**
    - Stop current music if playing.
    - Create new Audio element with src path.
    - Set volume to `this.musicVolume`, loop = loop.
    - Call `.play()`. Store reference.

    **stopMusic():**
    - Pause and reset current music.

    **setSFXVolume(v: number) / setMusicVolume(v: number):**
    - Clamp 0-1, store in member, persist to localStorage.
    - setMusicVolume also updates current music element volume.

    **getSFXVolume() / getMusicVolume():**
    - Return current values.

    **destroy():**
    - Stop music, clear sounds map.

    Make AudioManager a singleton-like pattern: store instance on the Phaser game registry so it persists across scenes:
    ```typescript
    // In BootScene: this.registry.set('audioManager', audioManager);
    // In other scenes: const audio = this.registry.get('audioManager') as AudioManager;
    ```
  </action>
  <verify>
    Run `cd /Users/jonasbrandvik/Projects/banger-game/client && npx tsc --noEmit` to verify TypeScript compiles.
    Verify SOUND_DEFS has entries for all required sounds (shoot/hit/death per role, wall_impact, speed_whoosh, button_click, etc.).
    Verify AudioManager has init, playSFX, playMusic, volume methods.
  </verify>
  <done>
    SoundDefs contains jsfxr parameter arrays for all 17+ sound effects. AudioManager generates sounds on init, plays SFX with volume control, manages music playback, and persists volume to localStorage.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate audio into game scenes</name>
  <files>client/src/scenes/BootScene.ts, client/src/scenes/GameScene.ts, client/src/scenes/LobbyScene.ts</files>
  <action>
    **BootScene.ts:**
    1. Import AudioManager and instantiate it.
    2. Call `audioManager.init()` to generate all SFX (runs jsfxr).
    3. Store in Phaser registry: `this.registry.set('audioManager', audioManager)`.
    4. Audio context will be unlocked by user clicks in LobbyScene (browser autoplay policy -- no special handling needed since game requires menu interaction before gameplay).
    5. Load music file: The project has `assets/soundtrack/Pixel Jitter Jive.mp3`. Check if it's accessible from client. If the file is in `assets/` (outside client/public), it needs to be copied or the path adjusted. For now, reference it as a relative path from the client. Actually, look at the Vite config -- assets outside public/ won't be served. Copy the mp3 to `client/public/audio/` or reference it via import. Use `this.load.audio('match_music', 'audio/match_music.mp3')` if the file exists in public. For this task, create a `client/public/audio/` directory and note that the implementer should copy the existing soundtrack there.

    **GameScene.ts -- trigger SFX on game events:**
    1. Get AudioManager from registry: `this.audioManager = this.registry.get('audioManager') as AudioManager;`
    2. On fire input sent (where `input.fire` is true and cooldown check passes): `audioManager.playSFX(`${this.localRole}_shoot`)`
    3. On damage detected (in handlePlayerChange when health decreased):
       - `audioManager.playSFX(`${player.role}_hit`)`
    4. On death detected (health reaches 0):
       - `audioManager.playSFX(`${player.role}_death`)`
    5. On wall collision detected (Paran velocity goes to zero from non-zero):
       - `audioManager.playSFX('wall_impact')`
    6. On speed threshold reached (Paran velocity > 200):
       - `audioManager.playSFX('speed_whoosh')` -- rate limit to once per second to avoid spam.
    7. On match start (matchState -> 'playing'):
       - `audioManager.playSFX('match_start_fanfare')`
       - Start match music: `audioManager.playMusic('audio/match_music.mp3')`
    8. On match end:
       - `audioManager.playSFX('match_end_fanfare')`
       - `audioManager.stopMusic()`

    **LobbyScene.ts -- UI sounds:**
    1. Get AudioManager from registry.
    2. On button click (in each button's pointerdown handler): `audioManager.playSFX('button_click')`
    3. On ready toggle: `audioManager.playSFX('ready_chime')`
    4. On countdown (in the countdown state listener): `audioManager.playSFX('countdown_beep')`
    5. Add volume controls to main menu:
       - Two horizontal sliders (Phaser rectangles + drag interaction or simple clickable bars):
         - "Music: [====----]" style bar with draggable handle
         - "SFX:   [======--]" style bar with draggable handle
       - Position at bottom of main menu.
       - On drag/click: update audioManager volume.
       - Show current percentage labels.
       - Simpler alternative: just use +/- buttons with percentage text display. "Music: [<] 40% [>]" and "SFX: [<] 70% [>]". Less complex to implement.
    6. Start lobby music if available (could reuse the same track at lower volume or skip if only one track exists).
  </action>
  <verify>
    Run `cd /Users/jonasbrandvik/Projects/banger-game/client && npx tsc --noEmit` to verify TypeScript compiles.
    Grep for "audioManager.playSFX" in GameScene.ts to verify SFX triggers.
    Grep for "audioManager" in LobbyScene.ts to verify UI sounds.
    Verify volume controls exist in LobbyScene.
  </verify>
  <done>
    Audio plays for all combat events (shots, hits, deaths per role), movement events (wall impact, speed whoosh), UI interactions (button clicks, countdown, ready), and match events (start/end fanfares). Volume controls with persistence. Music plays during matches.
  </done>
</task>

</tasks>

<verification>
1. Client compiles without errors
2. jsfxr generates valid audio data URLs for all sound definitions
3. Shot sounds play per role when firing
4. Hit sounds play per role when damaged
5. Death sounds play per role when eliminated
6. Wall impact sound plays on Paran collision
7. UI sounds play on button clicks and ready toggles
8. Match music starts on match begin
9. Volume controls visible in lobby with persistence
10. No autoplay errors in console
</verification>

<success_criteria>
Complete audio system with procedural chiptune SFX for all game events, per-role sound differentiation, UI sounds, background music, and user-controllable volume settings that persist across sessions.
</success_criteria>

<output>
After completion, create `.planning/phases/06-ux-polish/06-05-SUMMARY.md`
</output>
