---
phase: 09-multi-stage-rounds
plan: 02
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - client/src/scenes/GameScene.ts
  - client/src/scenes/StageIntroScene.ts
  - client/src/scenes/BootScene.ts
  - client/src/main.ts
autonomous: true

must_haves:
  truths:
    - "Between stages, a transition screen shows the round number, arena name, and current score"
    - "Client tilemap swaps to the new arena between stages with no visual artifacts"
    - "Camera zooms out smoothly at stage end and zooms in on new arena at stage start (DISP-05)"
    - "Controls are locked during stage transition (no ghost inputs)"
    - "All game visuals (sprites, particles, labels) from previous stage are cleaned up before new stage renders"
    - "All 3 tileset images and tilemap JSONs are preloaded at match start (no load delay during transitions)"
  artifacts:
    - path: "client/src/scenes/StageIntroScene.ts"
      provides: "Overlay scene showing stage number, arena name, and score between stages"
      min_lines: 40
    - path: "client/src/scenes/GameScene.ts"
      provides: "Stage transition message handlers, tilemap swap, camera zoom transitions, visual cleanup"
      contains: "stageTransition"
    - path: "client/src/scenes/BootScene.ts"
      provides: "Preloads all 3 tileset images and tilemap JSONs"
      contains: "tileset_hedge"
    - path: "client/src/main.ts"
      provides: "StageIntroScene registered in Phaser scene config"
      contains: "StageIntroScene"
  key_links:
    - from: "client/src/scenes/GameScene.ts"
      to: "server broadcast stageEnd/stageTransition/stageStart"
      via: "room.onMessage handlers"
      pattern: "room\\.onMessage.*stageEnd"
    - from: "client/src/scenes/GameScene.ts"
      to: "client/src/scenes/StageIntroScene.ts"
      via: "scene.launch('StageIntroScene', data)"
      pattern: "scene\\.launch.*StageIntroScene"
    - from: "client/src/scenes/BootScene.ts"
      to: "client/src/scenes/GameScene.ts"
      via: "Preloaded tileset cache shared across scenes"
      pattern: "load\\.image.*tileset"
---

<objective>
Implement client-side stage transition handling: tilemap swap between stages, camera zoom transitions (DISP-05), StageIntroScene overlay, visual cleanup, and tileset preloading in BootScene.

Purpose: Players experience smooth, polished transitions between stages with no visual glitches, loading delays, or ghost entities from the previous stage.

Output: GameScene handles all stage lifecycle messages, tilemap swaps mid-scene, StageIntroScene shows between-stage info, camera zooms provide cinematic transition feel.
</objective>

<execution_context>
@/Users/jonasbrandvik/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jonasbrandvik/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-multi-stage-rounds/09-RESEARCH.md
@.planning/phases/09-multi-stage-rounds/09-01-SUMMARY.md
@client/src/scenes/GameScene.ts
@client/src/scenes/BootScene.ts
@client/src/scenes/VictoryScene.ts
@client/src/main.ts
@shared/maps.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Preload all tilemaps in BootScene and create StageIntroScene overlay</name>
  <files>
    client/src/scenes/BootScene.ts
    client/src/scenes/StageIntroScene.ts
    client/src/main.ts
  </files>
  <action>
  **BootScene changes (client/src/scenes/BootScene.ts):**
  In the `preload()` method, add preloading for ALL 3 tileset images and tilemap JSONs. This eliminates any load delay during stage transitions. Add after the existing asset loads (before the "Note:" comment):

  ```typescript
  // Preload all arena tilesets and tilemaps for instant stage transitions
  this.load.image('tileset_hedge', 'tilesets/arena_hedge.png');
  this.load.image('tileset_brick', 'tilesets/arena_brick.png');
  this.load.image('tileset_wood', 'tilesets/arena_wood.png');
  this.load.tilemapTiledJSON('hedge_garden', 'maps/hedge_garden.json');
  this.load.tilemapTiledJSON('brick_fortress', 'maps/brick_fortress.json');
  this.load.tilemapTiledJSON('timber_yard', 'maps/timber_yard.json');
  ```

  Remove the "Note: Tileset images are loaded per-map in GameScene" comment since we now preload them.

  **StageIntroScene (client/src/scenes/StageIntroScene.ts) -- NEW FILE:**
  Create a Phaser overlay scene (same pattern as VictoryScene) that displays between-stage information:

  ```typescript
  import Phaser from 'phaser';
  import { Colors, TextStyle } from '../ui/designTokens';

  export class StageIntroScene extends Phaser.Scene {
    constructor() {
      super({ key: 'StageIntroScene' });
    }

    create(data: {
      stageNumber: number;
      arenaName: string;
      paranWins: number;
      guardianWins: number;
    }) {
      const cx = this.cameras.main.centerX;
      const cy = this.cameras.main.centerY;
      const w = this.cameras.main.width;
      const h = this.cameras.main.height;

      // Semi-transparent dark overlay
      this.add.rectangle(cx, cy, w, h, 0x000000, 0.7).setDepth(0);

      // "STAGE X" large text
      this.add.text(cx, cy - 80, `STAGE ${data.stageNumber}`, {
        ...TextStyle.hero,
        fontSize: '56px',
        fontFamily: 'monospace',
      }).setOrigin(0.5).setDepth(1);

      // Arena name
      this.add.text(cx, cy - 10, data.arenaName, {
        fontSize: '28px',
        color: Colors.gold.light,
        fontFamily: 'monospace',
        fontStyle: 'bold',
        stroke: '#000000',
        strokeThickness: 3,
      }).setOrigin(0.5).setDepth(1);

      // Score display
      const scoreText = `Paran ${data.paranWins} - ${data.guardianWins} Guardians`;
      this.add.text(cx, cy + 50, scoreText, {
        fontSize: '22px',
        color: Colors.text.primary,
        fontFamily: 'monospace',
        stroke: '#000000',
        strokeThickness: 2,
      }).setOrigin(0.5).setDepth(1);

      // Gold divider
      const gfx = this.add.graphics();
      gfx.lineStyle(2, Colors.gold.primaryNum, 0.7);
      gfx.lineBetween(cx - 200, cy + 90, cx + 200, cy + 90);
      gfx.setDepth(1);

      // "Get ready..." subtitle
      this.add.text(cx, cy + 120, 'Get ready...', {
        fontSize: '16px',
        color: Colors.text.secondary,
        fontFamily: 'monospace',
        fontStyle: 'italic',
        stroke: '#000000',
        strokeThickness: 2,
      }).setOrigin(0.5).setDepth(1);
    }
  }
  ```

  **main.ts changes:**
  - Import StageIntroScene: `import { StageIntroScene } from './scenes/StageIntroScene';`
  - Add to scene array: `[BootScene, LobbyScene, GameScene, HUDScene, VictoryScene, HelpScene, StageIntroScene]`
  </action>
  <verify>
  `cd /Users/jonasbrandvik/Projects/banger-game/client && npx tsc --noEmit` compiles without errors.
  Verify StageIntroScene.ts exists with create() method.
  Verify BootScene preloads all 3 tileset images and 3 tilemap JSONs.
  Verify main.ts includes StageIntroScene in scene array.
  </verify>
  <done>All 3 arena assets are preloaded in BootScene (zero load delay during transitions). StageIntroScene overlay renders stage number, arena name, and score. Scene registered in Phaser config.</done>
</task>

<task type="auto">
  <name>Task 2: Implement stage transition handlers and tilemap swap in GameScene</name>
  <files>client/src/scenes/GameScene.ts</files>
  <action>
  Add stage transition handling to GameScene. This is the most complex client-side change.

  **1. Add new member variable for tilemap reference:**
  Add to the class member variables (near wallsLayer/wallFrontsLayer):
  ```typescript
  private currentTilemap: Phaser.Tilemaps.Tilemap | null = null;
  private groundLayer: Phaser.Tilemaps.TilemapLayer | null = null;
  ```
  Reset these in `create()` along with all other member variable resets:
  ```typescript
  this.currentTilemap = null;
  this.groundLayer = null;
  ```

  **2. Update createTilemap to store references:**
  In the existing `createTilemap(mapKey)` method, store references to the created tilemap and ground layer:
  ```typescript
  this.currentTilemap = map; // Store tilemap reference for destroy on stage transition
  // After creating groundLayer:
  this.groundLayer = groundLayer; // Store for destroy
  ```

  **3. Add cleanupStageVisuals method:**
  Create a method that destroys all game objects from the current stage:
  ```typescript
  private cleanupStageVisuals(): void {
    // Destroy all projectile sprites and trails
    this.projectileSprites.forEach((sprite) => sprite.destroy());
    this.projectileSprites.clear();
    this.projectileVelocities.clear();
    this.projectileTrails.forEach((trail) => {
      if (this.particleFactory) this.particleFactory.destroyTrail(trail);
    });
    this.projectileTrails.clear();

    // Destroy eliminated texts and DC labels
    this.eliminatedTexts.forEach((text) => text.destroy());
    this.eliminatedTexts.clear();
    this.dcLabels.forEach((text) => text.destroy());
    this.dcLabels.clear();

    // Reset player sprite alpha and animations (but keep sprites alive -- players persist)
    this.playerSprites.forEach((sprite, sessionId) => {
      sprite.setAlpha(1.0);
      sprite.clearTint();
      const role = this.playerRoles.get(sessionId);
      if (role) {
        sprite.play(`${role}-idle`);
        this.playerAnimKeys.set(sessionId, `${role}-idle`);
      }
    });

    // Reset health cache
    this.playerHealthCache.clear();
    this.prevHealth.clear();

    // Destroy particle factory (recreated after new tilemap)
    if (this.particleFactory) {
      this.particleFactory.destroy();
      this.particleFactory = null;
    }

    // Reset spectator state (players are alive again)
    this.isSpectating = false;
    this.spectatorTarget = null;
  }
  ```

  **4. Add destroyTilemap method:**
  ```typescript
  private destroyTilemap(): void {
    // Destroy layers (must destroy before tilemap)
    if (this.wallsLayer) { this.wallsLayer.destroy(); this.wallsLayer = null; }
    if (this.wallFrontsLayer) { this.wallFrontsLayer.destroy(); this.wallFrontsLayer = null; }
    if (this.groundLayer) { this.groundLayer.destroy(); this.groundLayer = null; }
    // Destroy tilemap itself (cleans up layer cache)
    if (this.currentTilemap) { this.currentTilemap.destroy(); this.currentTilemap = null; }
    // Clear collision grid
    this.collisionGrid = null;
    if (this.prediction) {
      this.prediction.setCollisionGrid(null);
    }
  }
  ```

  **5. Add stage lifecycle message handlers in create() (after existing room message handlers):**

  ```typescript
  // Stage End: lock controls, zoom out camera
  this.room.onMessage("stageEnd", (data: any) => {
    this.controlsLocked = true;

    // Camera zoom out for dramatic effect (DISP-05)
    const cam = this.cameras.main;
    cam.zoomTo(0.5, 1500, 'Sine.easeInOut');

    // Audio: stage end fanfare
    if (this.audioManager) this.audioManager.playSFX('match_end_fanfare');
  });

  // Stage Transition: fade to black, swap tilemap, show intro overlay
  this.room.onMessage("stageTransition", (data: any) => {
    const cam = this.cameras.main;
    cam.fade(500, 0, 0, 0, false, (_cam: any, progress: number) => {
      if (progress >= 1) {
        // Clean up old stage visuals
        this.cleanupStageVisuals();

        // Destroy old tilemap
        this.destroyTilemap();

        // Update map metadata reference
        const mapData = MAPS.find(m => m.name === data.mapName);
        this.mapMetadata = mapData || MAPS[0];

        // Create new tilemap (assets already preloaded in BootScene)
        this.createTilemap(data.mapName);

        // Update prediction arena bounds for new map
        if (this.prediction && this.mapMetadata) {
          this.prediction.setArenaBounds({
            width: this.mapMetadata.width,
            height: this.mapMetadata.height,
          });
        }

        // Launch StageIntroScene overlay
        this.scene.launch("StageIntroScene", {
          stageNumber: data.stageNumber,
          arenaName: data.arenaName,
          paranWins: data.paranWins,
          guardianWins: data.guardianWins,
        });
      }
    });
  });

  // Stage Start: dismiss intro, fade in, start overview animation
  this.room.onMessage("stageStart", (data: any) => {
    // Stop stage intro overlay
    this.scene.stop("StageIntroScene");

    // Re-launch HUD if needed (it persists across stages, but re-ensure)
    // HUD should already be running. If it was stopped for any reason, re-launch.
    if (!this.scene.isActive('HUDScene') && this.room) {
      this.hudLaunched = true;
      this.scene.launch('HUDScene', {
        room: this.room,
        localSessionId: this.room.sessionId,
        localRole: this.localRole,
      });
    }

    // Fade in from black
    this.cameras.main.fadeIn(500, 0, 0, 0);

    // Overview zoom animation (same as match start)
    this.matchEnded = false;  // Reset for new stage
    this.startMatchOverview();
  });
  ```

  **6. Also add the same handlers in attachRoomListeners() (for reconnection):**
  Copy the same 3 message handlers (stageEnd, stageTransition, stageStart) into the `attachRoomListeners()` method. This ensures reconnected clients handle stage transitions correctly.

  **7. Update matchState listener to handle new states:**
  In both the create() and attachRoomListeners() matchState listeners, add handling for new states:
  ```typescript
  // Add cases for new match states
  } else if (value === 'stage_end') {
    // Stage ended -- controls already locked by stageEnd message
    this.statusText.setText('Stage complete!');
    this.statusText.setVisible(true);
  } else if (value === 'stage_transition') {
    this.statusText.setText('Loading next arena...');
    this.statusText.setVisible(true);
  } else if (value === 'match_end') {
    // Final match end -- handled by matchEnd message
  }
  ```

  **8. Update the existing onStateChange.once map loading:**
  Since all tilemaps are now preloaded in BootScene, simplify the initial map load in the `onStateChange.once` callback. The tileset image and tilemap JSON should already be in cache. Remove the dynamic load.image and load.tilemapTiledJSON calls -- just call createTilemap directly:
  ```typescript
  this.room.onStateChange.once((state: any) => {
    const mapName = state.mapName || "hedge_garden";
    const mapData = MAPS.find(m => m.name === mapName);
    this.mapMetadata = mapData || MAPS[0];
    console.log(`Loading map: ${mapName}`);

    // Assets preloaded in BootScene -- create tilemap directly
    // Check cache in case BootScene preload hasn't completed (safety)
    const tilesetInfo = MAP_TILESET_INFO[mapName] || Object.values(MAP_TILESET_INFO)[0];
    if (this.textures.exists(tilesetInfo.key) && this.cache.tilemap.has(mapName)) {
      this.createTilemap(mapName);
    } else {
      // Fallback: dynamic load (shouldn't happen with BootScene preload)
      if (!this.textures.exists(tilesetInfo.key)) {
        this.load.image(tilesetInfo.key, tilesetInfo.image);
      }
      if (!this.cache.tilemap.has(mapName)) {
        this.load.tilemapTiledJSON(mapName, mapData?.file || `maps/${mapName}.json`);
      }
      this.load.once('complete', () => this.createTilemap(mapName));
      this.load.start();
    }
  });
  ```

  **9. Update player sprite positions on stage reset:**
  The server resets player positions between stages. The client already handles this via onChange callbacks (prediction.reconcile for local, interpolation.addSnapshot for remote). No additional code needed -- the existing player change handler will update positions from the server state.

  However, the local prediction system needs its state reset for the new spawn position. Add to the stageTransition handler after setting mapMetadata:
  ```typescript
  // Reset prediction state to new spawn position (server will send new positions via onChange)
  // The reconcile call from handlePlayerChange will handle this naturally
  // But reset the prediction velocity state to prevent drift
  if (this.prediction) {
    // Force prediction to accept next server state without reconciliation drift
    this.prediction.reset();
  }
  ```
  Note: Check if PredictionSystem has a reset() method. If not, we may need to add a simple reset method or just let reconcile handle it. The reconcile should work since lastProcessedSeq is reset on server. Let me NOT add prediction.reset() and instead rely on the existing reconcile flow (server resets lastProcessedSeq to 0, prediction will re-sync on next reconcile).

  Actually, on reflection, the prediction system will naturally re-sync when the server sends the new player position with lastProcessedSeq = 0. The pending inputs buffer will all have seq > 0, so they'll be discarded during reconciliation. This is correct behavior -- no special reset needed.
  </action>
  <verify>
  `cd /Users/jonasbrandvik/Projects/banger-game/client && npx tsc --noEmit` compiles without errors.
  Verify GameScene has stageEnd, stageTransition, stageStart message handlers in both create() and attachRoomListeners().
  Verify cleanupStageVisuals destroys projectiles, trails, labels but preserves player sprites.
  Verify destroyTilemap destroys layers and tilemap object.
  Verify StageIntroScene is launched during stageTransition and stopped during stageStart.
  Verify camera zoom out on stageEnd and fade/overview on stageStart.
  </verify>
  <done>Client handles full stage transition lifecycle: camera zoom out on stage end, fade to black, tilemap swap, StageIntroScene overlay, fade in with overview animation on stage start. All visual cleanup between stages prevents ghost entities. Preloaded assets ensure instant tilemap creation.</done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `cd /Users/jonasbrandvik/Projects/banger-game/client && npx tsc --noEmit`
2. BootScene preloads all 3 tilesets and tilemaps
3. StageIntroScene exists and is registered in main.ts
4. GameScene has cleanupStageVisuals, destroyTilemap methods
5. GameScene handles stageEnd (zoom out), stageTransition (fade + swap + intro), stageStart (fade in + overview)
6. Both create() and attachRoomListeners() register stage message handlers
7. Client builds: `cd /Users/jonasbrandvik/Projects/banger-game/client && npm run build`
</verification>

<success_criteria>
Client seamlessly transitions between stages: camera zooms out at stage end, fades to black, swaps tilemap to new arena, shows StageIntroScene overlay with stage number/arena name/score, then fades in with overview animation at stage start. All assets preloaded for zero loading delay. All visual artifacts from previous stage are cleaned up.
</success_criteria>

<output>
After completion, create `.planning/phases/09-multi-stage-rounds/09-02-SUMMARY.md`
</output>
