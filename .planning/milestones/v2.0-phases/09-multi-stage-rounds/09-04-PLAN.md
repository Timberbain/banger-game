---
phase: 09-multi-stage-rounds
plan: 04
type: execute
wave: 1
depends_on: ["09-02"]
files_modified:
  - client/src/scenes/GameScene.ts
  - server/src/rooms/GameRoom.ts
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Stage transition uses a single smooth iris wipe animation (circle mask shrinks to black, expands to reveal new arena) with no multi-phase gaps or dead time"
    - "Characters do NOT visibly teleport to new positions before the screen is fully obscured"
    - "Players never spawn inside walls -- spawn positions are validated against collision grid"
  artifacts:
    - path: "client/src/scenes/GameScene.ts"
      provides: "Geometry mask iris wipe transition replacing camera fade"
      contains: "createGeometryMask"
    - path: "server/src/rooms/GameRoom.ts"
      provides: "Delayed resetStage call and spawn collision validation"
      contains: "isSolid"
  key_links:
    - from: "server/src/rooms/GameRoom.ts"
      to: "client stageTransition handler"
      via: "resetStage delayed until after broadcast"
      pattern: "setTimeout.*resetStage|clock\\.setTimeout.*resetStage"
    - from: "client/src/scenes/GameScene.ts"
      to: "handlePlayerChange"
      via: "inStageTransition guard skips position updates"
      pattern: "inStageTransition.*return|inStageTransition.*skip"
---

<objective>
Fix two diagnosed UAT gaps in stage transitions: (1) replace janky multi-phase camera transitions with a smooth geometry mask iris wipe effect, and (2) prevent characters from visibly teleporting before the screen is obscured by delaying server state reset and adding a client-side position guard, plus validate spawn positions against collision grid.

Purpose: Stage transitions should feel like a single continuous cinematic effect with no visible position teleportation or spawn-inside-wall bugs.
Output: Smooth iris wipe transitions, no visible teleportation, collision-validated spawn points.
</objective>

<execution_context>
@/Users/jonasbrandvik/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jonasbrandvik/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-multi-stage-rounds/09-02-SUMMARY.md
@.planning/debug/stage-zoom-janky.md
@.planning/debug/stage-teleport-spawn.md
@client/src/scenes/GameScene.ts
@server/src/rooms/GameRoom.ts
@shared/collisionGrid.ts
@shared/maps.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Server-side -- delay resetStage and add spawn collision validation</name>
  <files>server/src/rooms/GameRoom.ts</files>
  <action>
Two changes in GameRoom.ts:

**1a. Delay resetStage() to prevent visible teleportation:**

In `beginStageTransition()` (currently line ~709-733), the problem is that `resetStage(nextMap)` is called IMMEDIATELY after setting matchState, which updates player x/y in Schema BEFORE the client has time to obscure the screen. Fix:

- Move the `resetStage(nextMap)` call to happen AFTER a 600ms delay (enough time for the client's iris wipe to fully close -- the close animation is 500ms + buffer).
- Keep the `stageTransition` broadcast BEFORE the delay so clients receive it immediately and start their iris wipe.
- Keep the `loadMap(newMap)` call inside resetStage -- it all happens together after the delay.
- The existing 4s timeout to `startStage()` stays, but now starts from AFTER the resetStage delay completes (so the total server transition time becomes ~600ms + 4s = 4.6s, or adjust the startStage timeout to 3400ms to maintain the same ~4s total from client perspective).

Updated flow:
```
beginStageTransition() {
  state.matchState = STAGE_TRANSITION;
  state.currentStage++;
  const nextMap = stageArenas[currentStage - 1];

  // Broadcast FIRST -- client starts iris wipe immediately
  broadcast("stageTransition", { stageNumber, arenaName, mapName, paranWins, guardianWins });

  // Delay resetStage by 600ms so client iris wipe fully closes before position updates
  clock.setTimeout(() => {
    resetStage(nextMap);

    // After map is loaded and positions set, wait for client to show intro + open iris
    clock.setTimeout(() => {
      startStage();
    }, 3400); // 3400ms so total transition ~4s from client perspective
  }, 600);
}
```

**1b. Add spawn collision validation in setSpawnPosition():**

After setting player.x and player.y from mapMetadata spawn points, validate the position against the collision grid. If the spawn position overlaps a solid tile, nudge the player to the nearest safe position.

In `setSpawnPosition()` (currently line ~263-274), add after the position assignment:
```typescript
// Validate spawn position against collision grid
if (this.collisionGrid) {
  const radius = 12; // Player collision radius (half of 24px hitbox)
  const tileSize = this.collisionGrid.tileSize;

  // Check all tiles the player's AABB overlaps
  const left = Math.floor((player.x - radius) / tileSize);
  const right = Math.floor((player.x + radius) / tileSize);
  const top = Math.floor((player.y - radius) / tileSize);
  const bottom = Math.floor((player.y + radius) / tileSize);

  let isBlocked = false;
  for (let ty = top; ty <= bottom; ty++) {
    for (let tx = left; tx <= right; tx++) {
      if (this.collisionGrid.isSolid(tx, ty)) {
        isBlocked = true;
        break;
      }
    }
    if (isBlocked) break;
  }

  if (isBlocked) {
    console.warn(`Spawn position (${player.x}, ${player.y}) for ${role} is inside a wall! Nudging to safe position.`);
    // Nudge by one tile in each direction until clear
    const offsets = [[0,0],[32,0],[-32,0],[0,32],[0,-32],[32,32],[-32,-32],[32,-32],[-32,32]];
    for (const [dx, dy] of offsets) {
      const testX = player.x + dx;
      const testY = player.y + dy;
      const tl = Math.floor((testX - radius) / tileSize);
      const tr = Math.floor((testX + radius) / tileSize);
      const tt = Math.floor((testY - radius) / tileSize);
      const tb = Math.floor((testY + radius) / tileSize);
      let clear = true;
      for (let ty = tt; ty <= tb; ty++) {
        for (let tx = tl; tx <= tr; tx++) {
          if (this.collisionGrid.isSolid(tx, ty)) { clear = false; break; }
        }
        if (!clear) break;
      }
      if (clear) {
        player.x = testX;
        player.y = testY;
        console.log(`  Nudged to (${testX}, ${testY})`);
        break;
      }
    }
  }
}
```

Note: The collision grid may not yet be loaded when setSpawnPosition is called from onJoin (initial match start). The guard `if (this.collisionGrid)` handles this -- spawn validation only runs when the grid exists (i.e., during stage resets when loadMap has already been called for the new map). However, in resetStage, loadMap is called AFTER setSpawnPosition. Reorder resetStage so loadMap(newMap) is called BEFORE the player reset loop. This ensures the collision grid is populated for the new map before spawn validation runs.
  </action>
  <verify>
Run `cd /Users/jonasbrandvik/Projects/banger-game/server && npx tsc --noEmit` -- TypeScript compiles cleanly.
Verify the delay: grep for the resetStage call and confirm it's inside a clock.setTimeout.
Verify spawn validation: grep for `isSolid` in setSpawnPosition or nearby.
  </verify>
  <done>
resetStage() is called 600ms after stageTransition broadcast (not synchronously). setSpawnPosition() validates against collision grid and nudges blocked spawns. loadMap() is called before player position reset in resetStage(). TypeScript compiles.
  </done>
</task>

<task type="auto">
  <name>Task 2: Client-side -- iris wipe transition and position update guard</name>
  <files>client/src/scenes/GameScene.ts</files>
  <action>
Three changes in GameScene.ts:

**2a. Add `inStageTransition` flag as a member variable:**

Add a new member variable (near the other camera/control flags around line 98):
```typescript
private inStageTransition: boolean = false;
```

Reset it in `create()` alongside other state resets.

**2b. Guard position updates during stage transition:**

In `handlePlayerChange()` (line ~1048), add an early guard at the TOP of the position-update section (before both the local prediction reconcile and remote interpolation addSnapshot):

After the health/role/disconnect handling but before the position update block (around line 1153-1172), add:
```typescript
// Skip position updates during stage transition to prevent visible teleportation
if (this.inStageTransition) return;
```

This prevents sprites from moving to new spawn positions before the iris wipe has fully closed.

**2c. Replace camera fade transitions with geometry mask iris wipe:**

Replace the THREE separate stage transition handlers (stageEnd, stageTransition, stageStart) with a unified iris wipe approach. The pattern is from Phaser's geometry mask API:

**stageEnd handler** (line ~328-338) -- Replace the camera zoom with iris CLOSE:
```typescript
this.room.onMessage("stageEnd", (data: any) => {
  this.controlsLocked = true;
  this.inStageTransition = true;  // Block position updates

  // Audio: stage end fanfare
  if (this.audioManager) this.audioManager.playSFX('match_end_fanfare');

  // Create iris wipe circle (starts at full size, shrinks to 0)
  const cam = this.cameras.main;
  const cx = cam.width / 2;
  const cy = cam.height / 2;
  const maxRadius = Math.sqrt(cx * cx + cy * cy) + 50; // Cover full screen diagonal + margin

  // Create circle shape for geometry mask
  const irisShape = this.add.circle(cx, cy, maxRadius, 0x000000).setScrollFactor(0).setDepth(1000);
  const mask = irisShape.createGeometryMask();
  cam.setMask(mask);

  // Tween: shrink circle to zero over 1500ms
  this.tweens.add({
    targets: irisShape,
    scaleX: 0,
    scaleY: 0,
    duration: 1500,
    ease: 'Sine.easeInOut',
    onComplete: () => {
      // Screen is now fully black (mask is zero-size, nothing visible)
      // Store iris objects for stageTransition to expand later
      this.irisShape = irisShape;
      this.irisMask = mask;
    }
  });
});
```

Add member variables for iris objects (near other member vars):
```typescript
private irisShape: Phaser.GameObjects.Arc | null = null;
private irisMask: Phaser.Display.Masks.GeometryMask | null = null;
```

**stageTransition handler** (line ~341-375) -- Do the tilemap swap (screen is already black from iris close), keep StageIntroScene launch:
```typescript
this.room.onMessage("stageTransition", (data: any) => {
  // Screen should already be fully obscured by iris mask from stageEnd
  // If iris hasn't finished closing yet, force it
  if (this.irisShape) {
    this.irisShape.setScale(0);
  }

  // Clean up old stage visuals
  this.cleanupStageVisuals();

  // Destroy old tilemap
  this.destroyTilemap();

  // Update map metadata reference
  const mapData = MAPS.find(m => m.name === data.mapName);
  this.mapMetadata = mapData || MAPS[0];

  // Create new tilemap (assets already preloaded in BootScene)
  this.createTilemap(data.mapName);

  // Update prediction arena bounds for new map
  if (this.prediction && this.mapMetadata) {
    this.prediction.setArenaBounds({
      width: this.mapMetadata.width,
      height: this.mapMetadata.height,
    });
  }

  // Launch StageIntroScene overlay
  this.scene.launch("StageIntroScene", {
    stageNumber: data.stageNumber,
    arenaName: data.arenaName,
    paranWins: data.paranWins,
    guardianWins: data.guardianWins,
  });
});
```

**stageStart handler** (line ~378-398) -- Expand iris to reveal new arena + overview:
```typescript
this.room.onMessage("stageStart", (data: any) => {
  // Stop stage intro overlay
  this.scene.stop("StageIntroScene");

  // Re-launch HUD if needed
  if (!this.scene.isActive('HUDScene') && this.room) {
    this.hudLaunched = true;
    this.scene.launch('HUDScene', {
      room: this.room,
      localSessionId: this.room.sessionId,
      localRole: this.localRole,
    });
  }

  // Allow position updates again (new positions are already set)
  this.inStageTransition = false;

  // Iris OPEN: expand circle from 0 to full size
  if (this.irisShape && this.irisMask) {
    // Set up overview camera BEFORE revealing (so reveal shows overview)
    this.matchEnded = false;
    this.overviewActive = true;
    this.controlsLocked = true;
    const cam = this.cameras.main;
    cam.stopFollow();
    if (this.mapMetadata) {
      const overviewZoom = Math.min(
        cam.width / this.mapMetadata.width,
        cam.height / this.mapMetadata.height
      );
      cam.setZoom(overviewZoom);
      cam.centerOn(this.mapMetadata.width / 2, this.mapMetadata.height / 2);
    }

    // Expand iris circle to reveal new arena
    this.tweens.add({
      targets: this.irisShape,
      scaleX: 1,
      scaleY: 1,
      duration: 800,
      ease: 'Sine.easeInOut',
      onComplete: () => {
        // Remove mask (no longer needed)
        cam.clearMask(false);
        if (this.irisShape) { this.irisShape.destroy(); this.irisShape = null; }
        this.irisMask = null;

        // Now do the zoom-in to player (second half of overview)
        this.time.delayedCall(700, () => {
          if (this.room) {
            const localSprite = this.playerSprites.get(this.room.sessionId);
            if (localSprite) {
              cam.startFollow(localSprite, true, 0.12, 0.12);
              cam.setDeadzone(20, 15);
            }
          }
          cam.zoomTo(2, 800, 'Sine.easeInOut');
          this.time.delayedCall(800, () => {
            this.controlsLocked = false;
            this.overviewActive = false;
          });
        });
      }
    });
  } else {
    // Fallback: no iris (e.g., reconnect mid-transition) -- just do overview
    this.matchEnded = false;
    this.startMatchOverview();
  }
});
```

**IMPORTANT -- Duplicate all three handler changes in attachRoomListeners() too** (the reconnect path, lines ~1240-1320). The reconnect path has identical copies of stageEnd, stageTransition, and stageStart handlers. Apply the same iris wipe logic there.

**2d. Reset iris state in create():**

In the `create()` method, alongside other state resets, add:
```typescript
this.inStageTransition = false;
this.irisShape = null;
this.irisMask = null;
```

**Key implementation detail -- Geometry mask vs camera mask:**
The geometry mask created by `irisShape.createGeometryMask()` acts as a REVEAL mask (shows what's inside the shape, hides everything outside). So:
- Full-size circle = everything visible (normal gameplay)
- Zero-size circle = nothing visible (fully black)
- The background color (0x000000) of the Phaser game config shows through where the mask hides content, creating the "black screen" effect

The circle must have `setScrollFactor(0)` so it stays fixed on screen regardless of camera position. Set depth to 1000 to ensure it's above all game objects.

**NOTE on the geometry mask shape:** The shape used with `createGeometryMask()` should NOT have a fill color -- it's a shape mask, not a visual element. Use `this.make.graphics({})` instead of `this.add.circle()`:

Actually, the simplest approach matching the reference example: use `this.add.circle(cx, cy, maxRadius)` with `.setVisible(false)` since the circle itself doesn't need to be drawn -- only its geometry matters for the mask. The mask reveals content within the circle shape. Setting the circle invisible prevents it from rendering as a visual element while still functioning as a mask shape.

Revised creation:
```typescript
const irisShape = this.add.circle(cx, cy, maxRadius).setScrollFactor(0).setVisible(false);
```

Wait -- if setVisible(false) the geometry mask might not work as expected. Looking at the reference code more carefully, the example uses `setVisible(false)` and it works. The geometry mask uses the shape's geometry regardless of visibility. This is correct.

But there's a subtlety: when the circle is scaled to 0, the mask reveals nothing, so the background color shows through (black by default). This gives us the "faded to black" effect. When scaled back to 1, the mask reveals everything.

Use `setVisible(false)` on the circle. Do NOT set fill color (it's invisible anyway).
  </action>
  <verify>
Run `cd /Users/jonasbrandvik/Projects/banger-game/client && npx tsc --noEmit` -- TypeScript compiles cleanly.
Grep for `createGeometryMask` in GameScene.ts to confirm iris wipe is implemented.
Grep for `inStageTransition` to confirm the position update guard exists.
Grep for `cam.fade` in GameScene.ts to confirm the old fade-based transition is REMOVED (should find zero matches in stage transition handlers).
  </verify>
  <done>
Stage transitions use a geometry mask iris wipe (circle shrinks to black, expands to reveal). No more multi-phase camera fade/zoom gaps. handlePlayerChange() skips position updates when inStageTransition is true. Both primary and reconnect handler paths are updated. TypeScript compiles cleanly.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles on both server and client with no errors
2. `grep -n "cam.fade" client/src/scenes/GameScene.ts` returns NO matches in stageEnd/stageTransition/stageStart handlers (old fade removed)
3. `grep -n "createGeometryMask" client/src/scenes/GameScene.ts` returns matches (iris wipe implemented)
4. `grep -n "inStageTransition" client/src/scenes/GameScene.ts` returns matches showing guard in handlePlayerChange and flag set/clear in stage handlers
5. `grep -n "isSolid" server/src/rooms/GameRoom.ts` returns match (spawn collision validation)
6. `grep -n "setTimeout.*resetStage\|resetStage.*setTimeout" server/src/rooms/GameRoom.ts` or check that resetStage is inside a delayed callback (not called synchronously in beginStageTransition)
</verification>

<success_criteria>
- Stage transitions use a single continuous iris wipe animation: circle shrinks to black over 1.5s, arena swaps while fully obscured, circle expands over 0.8s to reveal new arena
- Characters never visibly teleport -- position updates are blocked on client during transition, and server delays position reset until after clients have obscured the screen
- Spawn positions are validated against collision grid with automatic nudging if blocked
- Both primary and reconnect handler paths implement the same transition logic
- No regressions: stage intro overlay still shows, overview camera still works, controls lock/unlock correctly
</success_criteria>

<output>
After completion, create `.planning/phases/09-multi-stage-rounds/09-04-SUMMARY.md`
</output>
