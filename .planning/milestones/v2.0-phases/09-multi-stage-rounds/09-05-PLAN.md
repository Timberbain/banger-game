---
phase: 09-multi-stage-rounds
plan: 05
type: execute
wave: 1
depends_on: ["09-04"]
files_modified:
  - client/src/scenes/GameScene.ts
  - client/src/systems/Interpolation.ts
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Iris wipe circle visually shrinks/expands as a smooth circular animation (not instant black)"
    - "Characters appear at correct spawn positions when iris opens on new stage (no visible teleport from old positions)"
    - "Players eliminated in previous stage regain full controller input in subsequent stages"
  artifacts:
    - path: "client/src/scenes/GameScene.ts"
      provides: "Fixed iris wipe with fill color, position backfill on stageStart, isSpectating reset and guard"
      contains: "0xffffff"
    - path: "client/src/systems/Interpolation.ts"
      provides: "snapTo method for teleport scenarios"
      contains: "snapTo"
  key_links:
    - from: "client/src/scenes/GameScene.ts"
      to: "stageStart handler"
      via: "Position backfill reads room.state.players and syncs prediction + interpolation"
      pattern: "prediction\\.reset|interpolation\\.snapTo"
    - from: "client/src/scenes/GameScene.ts"
      to: "update() spectator entry"
      via: "inStageTransition guard prevents re-entry during transition window"
      pattern: "inStageTransition.*return|inStageTransition.*spectating"
---

<objective>
Fix three diagnosed UAT regressions from 09-04: (1) iris wipe renders as instant black instead of gradual circle animation due to missing fill color on geometry mask circle, (2) characters appear at old-stage positions when new stage reveals because blocked position updates are never backfilled, (3) eliminated players permanently lose input because isSpectating flag is re-set during the 600ms health reset delay.

Purpose: All three are regressions from the 09-04 iris wipe implementation. Each has a diagnosed root cause with a precise code fix.
Output: Working iris wipe animation, correct spawn positions on reveal, functional input for all players after stage transitions.
</objective>

<execution_context>
@/Users/jonasbrandvik/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jonasbrandvik/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-multi-stage-rounds/09-04-SUMMARY.md
@.planning/debug/iris-wipe-not-rendering.md
@.planning/debug/stage-teleport-spawn.md
@.planning/debug/eliminated-player-input-lost.md
@client/src/scenes/GameScene.ts
@client/src/systems/Interpolation.ts
@client/src/systems/Prediction.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix iris wipe fill color and add InterpolationSystem.snapTo</name>
  <files>client/src/scenes/GameScene.ts, client/src/systems/Interpolation.ts</files>
  <action>
Two changes across two files:

**1a. Fix iris wipe circle fill color in GameScene.ts:**

The geometry mask circle is created without a fill color, so Phaser's ArcWebGLRenderer skips FillPathWebGL (the `if (src.isFilled)` check), leaving an empty stencil buffer that clips everything immediately instead of gradually.

In the PRIMARY stageEnd handler (around line 365), change:
```typescript
const irisShape = this.add.circle(cx, cy, maxRadius).setScrollFactor(0).setVisible(false);
```
to:
```typescript
const irisShape = this.add.circle(cx, cy, maxRadius, 0xffffff).setScrollFactor(0).setVisible(false);
```

In the RECONNECT stageEnd handler (around line 1394), make the same change:
```typescript
const irisShape = this.add.circle(cx, cy, maxRadius, 0xffffff).setScrollFactor(0).setVisible(false);
```

The fill color (0xffffff -- white) sets `isFilled=true` on the Arc shape, which causes ArcWebGLRenderer to actually render geometry to the stencil buffer. The color itself doesn't matter (the shape is invisible and used only for masking), but a fill color MUST be provided to trigger stencil rendering. Without it, the mask clips everything immediately (instant black) instead of clipping based on the circle's geometry (gradual iris wipe).

**1b. Add snapTo method to InterpolationSystem (Interpolation.ts):**

Add a new method after the existing `removePlayer` method (around line 33):

```typescript
/**
 * Snap a player's interpolation buffer to a specific position.
 * Used during stage transitions to prevent lerping from old positions.
 * Clears the buffer and injects a single snapshot at the given position.
 */
snapTo(sessionId: string, x: number, y: number, angle: number): void {
  const now = Date.now();
  this.buffers.set(sessionId, [
    { timestamp: now - 1, x, y, angle },
    { timestamp: now, x, y, angle },
  ]);
}
```

This creates two identical snapshots at the target position, so `getInterpolatedState` returns the exact position with no lerp. Two snapshots are needed because the interpolation system requires at least 2 snapshots to return a result (line 39: `if (!buffer || buffer.length < 2)`). Using `now - 1` and `now` ensures the snapshots are fresh and won't be pruned.
  </action>
  <verify>
Run `cd /Users/jonasbrandvik/Projects/banger-game/client && npx tsc --noEmit` -- TypeScript compiles cleanly.
Grep for `0xffffff` in GameScene.ts stageEnd handlers to confirm fill color is present (should find 2 matches -- primary and reconnect paths).
Grep for `snapTo` in Interpolation.ts to confirm the method exists.
  </verify>
  <done>
Iris wipe circle has fill color 0xffffff in both primary and reconnect stageEnd handlers. InterpolationSystem has a snapTo method that clears the buffer and injects a position without interpolation. TypeScript compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Backfill positions on stageStart and fix isSpectating race condition</name>
  <files>client/src/scenes/GameScene.ts</files>
  <action>
Two changes in GameScene.ts to fix the remaining two gaps:

**2a. Backfill positions from server state in stageStart handler:**

The `inStageTransition` guard in `handlePlayerChange` (line 1274) correctly blocks position updates during transitions, but Colyseus 0.15 only sends delta patches ONCE. The position changes from `resetStage()` are blocked and will NEVER be re-sent. When `inStageTransition` is set to false in `stageStart`, the prediction/interpolation systems still hold stale (old stage) positions.

In the PRIMARY stageStart handler (around line 438), AFTER `this.inStageTransition = false;`, add a position backfill block that reads current server state and syncs all systems:

```typescript
// Backfill positions from server state -- blocked updates during transition are permanently lost
// (Colyseus 0.15 delta patches are sent once, the inStageTransition guard discarded them)
if (this.room) {
  this.room.state.players.forEach((player: any, sessionId: string) => {
    const sprite = this.playerSprites.get(sessionId);
    if (!sprite) return;

    const isLocal = sessionId === this.room!.sessionId;

    if (isLocal) {
      // Snap prediction system to server's current position
      if (this.prediction) {
        this.prediction.reset({
          x: player.x,
          y: player.y,
          vx: 0,
          vy: 0,
          angle: player.angle || 0,
          lastProcessedSeq: player.lastProcessedSeq || 0,
        });
      }
      // Snap sprite directly
      sprite.setPosition(player.x, player.y);
    } else {
      // Snap interpolation system to server's current position (no lerp from old position)
      if (this.interpolation) {
        this.interpolation.snapTo(sessionId, player.x, player.y, player.angle || 0);
      }
      // Snap sprite directly
      sprite.setPosition(player.x, player.y);
    }
  });
}
```

Apply the SAME backfill block in the RECONNECT stageStart handler (around line 1464), right after `this.inStageTransition = false;`.

**2b. Fix isSpectating race condition -- guard spectator entry with inStageTransition:**

The `update()` loop's spectator entry (around line 569) checks `isDead && !isSpectating && !matchEnded` every frame. During the 600ms window between `stageTransition` (which resets `isSpectating=false` in `cleanupStageVisuals`) and `resetStage` (which resets health), the update loop sees `health<=0` and immediately re-sets `isSpectating=true`. Once health is restored, `isDead` becomes false but `isSpectating` stays true forever, permanently blocking input at line 651.

Fix: Add `inStageTransition` to the spectator entry guard. In `update()`, change the spectator entry condition (around line 569) from:

```typescript
if (isDead && !this.isSpectating && !this.matchEnded) {
```

to:

```typescript
if (isDead && !this.isSpectating && !this.matchEnded && !this.inStageTransition) {
```

This prevents the update loop from re-entering spectator mode during the transition window when health is still 0 but a new stage is about to start.

Additionally, as a safety net, add `isSpectating = false` and `spectatorTarget = null` resets to BOTH stageStart handlers (primary around line 438, reconnect around line 1464), right before the `inStageTransition = false` line:

```typescript
// Reset spectator state for new stage (safety net -- cleanupStageVisuals already resets,
// but the update() loop can re-set isSpectating during the 600ms health reset delay)
this.isSpectating = false;
this.spectatorTarget = null;
```

This ensures that even if the race condition somehow occurs (e.g., on slow networks), the stageStart handler always cleans it up.
  </action>
  <verify>
Run `cd /Users/jonasbrandvik/Projects/banger-game/client && npx tsc --noEmit` -- TypeScript compiles cleanly.
Grep for `prediction.reset` in stageStart handlers to confirm position backfill exists (should find matches in both primary and reconnect paths).
Grep for `interpolation.snapTo` in stageStart handlers to confirm remote player position backfill.
Grep for `inStageTransition` in the update() spectator entry line to confirm the guard is added.
Grep for `isSpectating = false` in stageStart handlers (should find matches in both primary and reconnect paths, separate from cleanupStageVisuals).
  </verify>
  <done>
stageStart handler backfills ALL player positions from room.state.players -- prediction.reset() for local player, interpolation.snapTo() for remote players, direct sprite.setPosition() for both. Spectator entry in update() is guarded by `!inStageTransition` to prevent re-entry during the 600ms health reset delay. stageStart handlers also reset isSpectating as a safety net. Both primary and reconnect paths are updated. TypeScript compiles cleanly.
  </done>
</task>

</tasks>

<verification>
1. `cd /Users/jonasbrandvik/Projects/banger-game/client && npx tsc --noEmit` -- TypeScript compiles on client with no errors
2. Grep for `0xffffff` in GameScene.ts -- should find 2 matches (both stageEnd iris wipe circle creations)
3. Grep for `snapTo` in Interpolation.ts -- should find the method definition
4. Grep for `prediction.reset` in GameScene.ts stageStart handlers -- should find matches in both primary and reconnect paths
5. Grep for `interpolation.snapTo` in GameScene.ts stageStart handlers -- should find matches in both primary and reconnect paths
6. Grep for `inStageTransition` on the spectator entry line in update() -- confirms the race condition guard
7. Grep for `isSpectating = false` in stageStart handler blocks (not just cleanupStageVisuals) -- confirms safety net reset
</verification>

<success_criteria>
- Iris wipe animation visually shrinks and expands as a gradual circle (not instant black cut)
- When iris opens on new stage, all characters are at their correct spawn positions (no visible teleport from old-stage locations)
- Players eliminated in a previous stage have full controller input in subsequent stages (isSpectating is reliably cleared)
- Both primary and reconnect handler paths are fixed identically
- No regressions: stage intro overlay, overview camera, controls lock/unlock all still work correctly
</success_criteria>

<output>
After completion, create `.planning/phases/09-multi-stage-rounds/09-05-SUMMARY.md`
</output>
