---
phase: 09-multi-stage-rounds
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - server/src/schema/GameState.ts
  - server/src/rooms/GameRoom.ts
  - shared/maps.ts
autonomous: true

must_haves:
  truths:
    - "A match consists of up to 3 stages -- first side to win 2 stages wins"
    - "Each stage uses a different arena (no repeats within a match)"
    - "All game state resets cleanly between stages (health, positions, projectiles, obstacles)"
    - "Match timer resets per stage (each stage gets full 5 minutes)"
    - "Stage winner is determined by same rules as current match winner (all guardians dead = paran wins, paran dead = guardians win, timeout = guardians win)"
    - "Per-stage stats are tracked for victory screen breakdown"
  artifacts:
    - path: "server/src/schema/GameState.ts"
      provides: "Extended schema with currentStage, paranStageWins, guardianStageWins, stageArenas"
      contains: "currentStage"
    - path: "server/src/rooms/GameRoom.ts"
      provides: "Stage lifecycle: selectArenas, endStage, beginStageTransition, startStage, resetStage"
      contains: "endStage"
  key_links:
    - from: "server/src/rooms/GameRoom.ts"
      to: "server/src/schema/GameState.ts"
      via: "Schema field mutations for stage tracking"
      pattern: "this\\.state\\.currentStage"
    - from: "server/src/rooms/GameRoom.ts"
      to: "shared/maps.ts"
      via: "MAPS array for arena selection"
      pattern: "this\\.stageArenas"
---

<objective>
Add server-side best-of-3 stage lifecycle to GameRoom with schema extensions for stage tracking, arena selection without repeats, and clean state reset between stages.

Purpose: Foundation for multi-stage rounds -- all client-side plans depend on the server correctly managing stage progression, broadcasting stage events, and resetting game state between stages.

Output: GameRoom handles full best-of-3 lifecycle; GameState schema has stage/score fields; clients receive stageEnd, stageTransition, stageStart messages.
</objective>

<execution_context>
@/Users/jonasbrandvik/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jonasbrandvik/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-multi-stage-rounds/09-RESEARCH.md
@server/src/schema/GameState.ts
@server/src/rooms/GameRoom.ts
@shared/maps.ts
@shared/characters.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend GameState schema and MatchState enum for multi-stage</name>
  <files>server/src/schema/GameState.ts</files>
  <action>
  1. Add new MatchState enum values to support stage lifecycle:
     - STAGE_END = "stage_end" (freeze after stage winner determined, 2s pause)
     - STAGE_TRANSITION = "stage_transition" (server resetting state, client swapping tilemap)
     - MATCH_END = "match_end" (best-of-3 winner determined, replaces current ENDED for final match end)
     Keep existing WAITING, PLAYING, ENDED values (ENDED stays for backward compat but MATCH_END is the new terminal state for best-of-3).

  2. Add new schema fields to GameState:
     - `@type("uint8") currentStage: number = 1;` -- current stage number (1, 2, or 3)
     - `@type("uint8") paranStageWins: number = 0;` -- paran side stage win count
     - `@type("uint8") guardianStageWins: number = 0;` -- guardian side stage win count

  3. Add a StageSnapshot class (NOT a Schema subclass -- plain class, server-only) for per-stage stat tracking:
     ```typescript
     // Server-only: not synced via Schema
     export interface StageSnapshot {
       stageNumber: number;
       arenaName: string;
       winner: string;
       duration: number;
       stats: Record<string, { kills: number; deaths: number; damageDealt: number; shotsFired: number; shotsHit: number }>;
     }
     ```
     Export this interface from GameState.ts so GameRoom can import it.
  </action>
  <verify>
  `cd /Users/jonasbrandvik/Projects/banger-game/server && npx tsc --noEmit` compiles without errors.
  Verify MatchState has STAGE_END, STAGE_TRANSITION, MATCH_END values.
  Verify GameState has currentStage, paranStageWins, guardianStageWins fields.
  </verify>
  <done>GameState schema has all stage-tracking fields. MatchState enum covers full stage lifecycle. StageSnapshot interface exists for per-stage stats.</done>
</task>

<task type="auto">
  <name>Task 2: Implement stage lifecycle in GameRoom (arena selection, stage end/transition/start, state reset)</name>
  <files>server/src/rooms/GameRoom.ts</files>
  <action>
  This is the core implementation. Modify GameRoom to support best-of-3 stages:

  **1. Arena selection at match start (no repeats):**
  - Add private field: `private stageArenas: MapMetadata[] = [];`
  - Add private field: `private stageSnapshots: StageSnapshot[] = [];` (import StageSnapshot from schema)
  - Add `selectArenas()` method: Fisher-Yates shuffle of MAPS array indices [0, 1, 2], map to MapMetadata. Call in `onCreate()` instead of sequential rotation. First arena = stageArenas[0].
  - Remove `GameRoom.currentMapIndex` static counter. Replace `MAPS[GameRoom.currentMapIndex % MAPS.length]` with `this.stageArenas[0]` in onCreate.
  - Set `this.state.currentStage = 1` in onCreate.

  **2. Replace endMatch with endStage (stage winner detection):**
  - Rename current `endMatch` to `endStage(stageWinner: string)`.
  - In endStage:
    a. Drain all input queues.
    b. Take a StageSnapshot: capture current stage number, arena displayName, winner, duration (serverTime - matchStartTime), and per-player stats (iterate matchStats, snapshot kills/deaths/damageDealt/shotsFired/shotsHit). Push to stageSnapshots array.
    c. Increment paranStageWins or guardianStageWins on the schema.
    d. Check for match winner: if paranStageWins >= 2 or guardianStageWins >= 2, call `endMatch(stageWinner)` and return.
    e. Otherwise, set matchState = MatchState.STAGE_END.
    f. Broadcast "stageEnd" message: `{ stageWinner, stageNumber: this.state.currentStage, paranWins, guardianWins }`.
    g. After 2s delay via `this.clock.setTimeout`, call `beginStageTransition()`.

  **3. Stage transition (state reset + new arena):**
  - Add `beginStageTransition()` method:
    a. Set matchState = STAGE_TRANSITION.
    b. Increment currentStage.
    c. Get next arena: `this.stageArenas[this.state.currentStage - 1]`.
    d. Call `resetStage(nextMap)`.
    e. Broadcast "stageTransition" message: `{ stageNumber, arenaName: nextMap.displayName, mapName: nextMap.name, paranWins, guardianWins }`.
    f. After 4s delay via `this.clock.setTimeout`, call `startStage()`.

  **4. State reset between stages (CRITICAL -- follow Colyseus 0.15 patterns):**
  - Add `resetStage(newMap: MapMetadata)` method:
    a. Clear projectiles: `while (this.state.projectiles.length > 0) this.state.projectiles.pop();` (NOT .clear() -- Colyseus 0.15 bug).
    b. Clear obstacles: collect keys first, then delete individually. `const keys: string[] = []; this.state.obstacles.forEach((_, k) => keys.push(k)); for (const k of keys) this.state.obstacles.delete(k);` (NOT .clear()).
    c. Reset players IN-PLACE (do NOT delete/re-add): iterate players, for each player:
       - Reset health to CHARACTERS[role].maxHealth
       - Reset vx, vy to 0
       - Clear inputQueue = []
       - Reset lastFireTime = 0
       - Reset lastProcessedSeq = 0
       - Set spawn position from newMap.spawnPoints based on role (same logic as onJoin)
       - Set connected = true (re-confirm)
    d. Reset per-player match stats to 0 (iterate matchStats, reset all fields). These are cumulative per-stage, but the StageSnapshot already captured the stage's stats. Actually -- per research recommendation, stats should ACCUMULATE across stages. So do NOT reset matchStats. The snapshot captures the cumulative state at stage end; the victory screen can diff snapshots to show per-stage deltas.
    e. Load new map collision data: reuse the existing map loading logic from onCreate. Extract map loading into a `loadMap(mapMeta: MapMetadata)` method that both onCreate and resetStage call. This method:
       - Reads the Tiled JSON file
       - Creates a new CollisionGrid
       - Initializes obstacles in state
       - Updates this.mapMetadata and this.state.mapName
    f. Update mapMetadata reference to newMap.

  **5. Start new stage:**
  - Add `startStage()` method:
    a. Set matchState = MatchState.PLAYING.
    b. Reset matchStartTime = this.state.serverTime (each stage gets fresh 5-minute timer).
    c. Broadcast "stageStart" message: `{ stageNumber: this.state.currentStage, startTime: this.state.serverTime }`.

  **6. Update endMatch for best-of-3 final:**
  - Add new `endMatch(matchWinner: string)` method (the final match end, not per-stage):
    a. Set this.state.winner = matchWinner.
    b. Build final stats object (same as current endMatch).
    c. Build stageResults array from stageSnapshots for per-stage breakdown.
    d. Broadcast "matchEnd" with: `{ winner: matchWinner, stats, stageResults: this.stageSnapshots, duration: totalMatchDuration }`. Where totalMatchDuration = sum of all stage durations from snapshots.
    e. Set matchState = MatchState.MATCH_END (use new enum value).
    f. Set matchEndTime.
    g. Auto-disconnect after 15s (same as current).

  **7. Update checkWinConditions:**
  - Change `this.endMatch(winner)` calls to `this.endStage(winner)`.

  **8. Update fixedTick:**
  - The guard `if (this.state.matchState !== MatchState.PLAYING)` already correctly blocks game logic during non-PLAYING states (STAGE_END, STAGE_TRANSITION, MATCH_END will all skip). Ensure serverTime still increments during STAGE_END and STAGE_TRANSITION (it does -- the existing code increments serverTime before the return).

  **9. Update startMatch:**
  - Current startMatch just sets PLAYING and locks. Keep it, but also call selectArenas() here (or in onCreate -- either works, but match start is cleaner since that's when the 3 players are confirmed).
  - Actually, selectArenas() should be in onCreate since we need stageArenas[0] for the initial map. Keep it in onCreate.

  **10. Update onLeave:**
  - The `MatchState.PLAYING` check in onLeave should also handle STAGE_END and STAGE_TRANSITION as "active match" states (player might disconnect between stages). Update the conditions:
    - During PLAYING, STAGE_END, or STAGE_TRANSITION: allow reconnection with grace period.
    - After reconnection during STAGE_TRANSITION: player receives current state which includes new map data.

  **11. Extract map loading into loadMap method:**
  - Factor out the map loading code from onCreate into `private loadMap(mapMeta: MapMetadata): void` that:
    - Reads the JSON file at the map path
    - Creates CollisionGrid from Walls layer
    - Initializes obstacles in state
    - Sets this.mapMetadata and this.state.mapName
  - Call loadMap(this.stageArenas[0]) in onCreate
  - Call loadMap(newMap) in resetStage (after clearing old obstacles)

  IMPORTANT anti-patterns to avoid (from research):
  - NEVER call this.setState() between stages
  - NEVER use ArraySchema.clear() or MapSchema.clear()
  - NEVER delete/re-add players between stages (reset in-place)
  - NEVER create new rooms per stage
  </action>
  <verify>
  `cd /Users/jonasbrandvik/Projects/banger-game/server && npx tsc --noEmit` compiles without errors.
  Verify GameRoom has: selectArenas, endStage, beginStageTransition, startStage, resetStage, loadMap methods.
  Verify no calls to .clear() on ArraySchema or MapSchema.
  Verify stageArenas is populated with 3 unique maps.
  Verify endStage checks for best-of-3 winner before transitioning.
  </verify>
  <done>GameRoom manages full best-of-3 lifecycle. Arenas selected without repeats at room creation. State resets cleanly between stages following Colyseus 0.15 safe patterns. Server broadcasts stageEnd, stageTransition, stageStart, and enhanced matchEnd messages with per-stage data.</done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `cd /Users/jonasbrandvik/Projects/banger-game/server && npx tsc --noEmit`
2. MatchState enum has: WAITING, PLAYING, STAGE_END, STAGE_TRANSITION, MATCH_END, ENDED
3. GameState schema has: currentStage, paranStageWins, guardianStageWins
4. GameRoom.selectArenas produces 3 unique arenas from MAPS
5. GameRoom.resetStage uses pop() for projectiles, iterate+delete for obstacles, in-place reset for players
6. GameRoom.endStage snapshots stats, increments wins, checks for best-of-3 winner
7. Server starts and runs: `cd /Users/jonasbrandvik/Projects/banger-game/server && npm run dev` (verify no runtime errors in logs)
</verification>

<success_criteria>
Server-side best-of-3 stage lifecycle is fully implemented. When a stage ends (all guardians or paran eliminated, or timeout), the server increments win count, checks for match winner, and either transitions to next stage (with full state reset) or ends the match. Three unique arenas are pre-selected per match. All state (projectiles, obstacles, player health/position) resets cleanly between stages without using Colyseus anti-patterns.
</success_criteria>

<output>
After completion, create `.planning/phases/09-multi-stage-rounds/09-01-SUMMARY.md`
</output>
