---
phase: 09-multi-stage-rounds
plan: 03
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - client/src/scenes/HUDScene.ts
  - client/src/scenes/VictoryScene.ts
autonomous: true

must_haves:
  truths:
    - "Round score (e.g., '1-0') is visible throughout the match during gameplay"
    - "Round score updates live when a stage is won"
    - "Final victory screen shows best-of-3 results with per-stage breakdown"
    - "Victory screen shows which arena each stage was played on and who won each stage"
    - "HUD persists across stages and resets visual state (health bars, timer) correctly between stages"
  artifacts:
    - path: "client/src/scenes/HUDScene.ts"
      provides: "Round score display, stage reset handling for health bars and timer"
      contains: "roundScoreText"
    - path: "client/src/scenes/VictoryScene.ts"
      provides: "Per-stage breakdown section showing arena, winner, and stats per stage"
      contains: "stageResults"
  key_links:
    - from: "client/src/scenes/HUDScene.ts"
      to: "server/src/schema/GameState.ts"
      via: "Schema listeners for paranStageWins and guardianStageWins"
      pattern: "listen.*paranStageWins|guardianStageWins"
    - from: "client/src/scenes/VictoryScene.ts"
      to: "server matchEnd broadcast"
      via: "data.stageResults array from matchEnd message"
      pattern: "stageResults"
---

<objective>
Add round score display to HUD and per-stage breakdown to VictoryScene for the best-of-3 match structure.

Purpose: Players need to see the current round score during gameplay and get a detailed breakdown of how each stage went at the end of the match.

Output: HUD shows live "Paran X - Y Guardians" score, VictoryScene shows per-stage arena/winner/stats breakdown.
</objective>

<execution_context>
@/Users/jonasbrandvik/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jonasbrandvik/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-multi-stage-rounds/09-RESEARCH.md
@.planning/phases/09-multi-stage-rounds/09-01-SUMMARY.md
@client/src/scenes/HUDScene.ts
@client/src/scenes/VictoryScene.ts
@client/src/ui/designTokens.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add round score display and stage-aware reset to HUDScene</name>
  <files>client/src/scenes/HUDScene.ts</files>
  <action>
  **1. Add round score display member variable:**
  ```typescript
  private roundScoreText: Phaser.GameObjects.Text | null = null;
  private stageLabel: Phaser.GameObjects.Text | null = null;
  ```
  Reset in create(): `this.roundScoreText = null; this.stageLabel = null;`

  **2. Create round score display in create() (add as step 9, after match countdown):**
  Add a `createRoundScore()` method and call it from create():
  ```typescript
  // 9. Create round score display (top center, below timer)
  this.createRoundScore();
  ```

  The createRoundScore method:
  ```typescript
  private createRoundScore(): void {
    if (!this.room) return;

    // Stage label: "Stage 1" above the score
    this.stageLabel = this.add.text(this.W * 0.5, this.H * 0.06, 'Stage 1', {
      fontSize: '12px',
      color: Colors.text.secondary,
      fontFamily: 'monospace',
      stroke: '#000000',
      strokeThickness: 2,
    });
    this.stageLabel.setOrigin(0.5, 0.5);
    this.stageLabel.setDepth(200);

    // Score text: "0 - 0" below the timer
    this.roundScoreText = this.add.text(this.W * 0.5, this.H * 0.09, '0 - 0', {
      fontSize: '16px',
      color: Colors.gold.primary,
      fontFamily: 'monospace',
      fontStyle: 'bold',
      stroke: '#000000',
      strokeThickness: 3,
    });
    this.roundScoreText.setOrigin(0.5, 0.5);
    this.roundScoreText.setDepth(200);

    // Listen for schema changes on stage wins
    this.room.state.listen("paranStageWins", (value: number) => {
      this.updateRoundScore();
    });
    this.room.state.listen("guardianStageWins", (value: number) => {
      this.updateRoundScore();
    });
    this.room.state.listen("currentStage", (value: number) => {
      if (this.stageLabel) {
        this.stageLabel.setText(`Stage ${value}`);
      }
    });
  }
  ```

  **3. Add updateRoundScore method:**
  ```typescript
  private updateRoundScore(): void {
    if (!this.roundScoreText || !this.room) return;
    const paranWins = this.room.state.paranStageWins || 0;
    const guardianWins = this.room.state.guardianStageWins || 0;
    this.roundScoreText.setText(`${paranWins} - ${guardianWins}`);
  }
  ```

  **4. Handle HUD persistence across stages:**
  The HUD persists across stages (it's not stopped/restarted). But health bars and timer need to visually reset when a new stage starts.

  Add a listener for matchState changes in create() to handle stage transitions:
  In the existing `setupMatchCountdown()` method, extend the matchState listener:
  ```typescript
  this.room.state.listen('matchState', (value: string) => {
    if (value === 'playing') {
      this.showMatchStart(); // existing "FIGHT!" text
      // Reset timer flash state for new stage
      this.isTimerFlashing = false;
      if (this.timerFlashTimer) {
        this.timerFlashTimer.destroy();
        this.timerFlashTimer = null;
      }
      if (this.timerText) {
        this.timerText.setColor(Colors.text.primary);
        this.timerText.setAlpha(1);
      }
    } else if (value === 'stage_end') {
      // Stage ended -- keep HUD visible but show stage result briefly
    } else if (value === 'stage_transition') {
      // Rebuild health bars (players reset to full health)
      this.time.delayedCall(200, () => this.rebuildHealthBars());
      // Reset low health flash timers
      for (const timer of this.lowHealthFlashTimers.values()) {
        timer.destroy();
      }
      this.lowHealthFlashTimers.clear();
    }
  });
  ```

  Remove the duplicate matchState listener from the existing setupMatchCountdown -- consolidate into a single listener. The current setupMatchCountdown has its own `this.room.state.listen('matchState', ...)`. Merge the stage_end/stage_transition/playing handling into this single listener.

  **5. Reset spectator state between stages:**
  When a new stage starts (matchState = 'playing'), reset spectator HUD:
  ```typescript
  // In the matchState listener, when value === 'playing':
  this.hideSpectatorHUD();
  ```
  </action>
  <verify>
  `cd /Users/jonasbrandvik/Projects/banger-game/client && npx tsc --noEmit` compiles without errors.
  Verify HUDScene has roundScoreText and stageLabel.
  Verify Schema listeners for paranStageWins, guardianStageWins, currentStage exist.
  Verify health bars rebuild on stage_transition.
  Verify timer flash state resets on new stage.
  </verify>
  <done>HUD shows persistent round score ("X - Y") with stage label. Score updates live via Schema listeners. Health bars and timer reset correctly between stages. Spectator HUD hides when new stage begins.</done>
</task>

<task type="auto">
  <name>Task 2: Add per-stage breakdown to VictoryScene</name>
  <files>client/src/scenes/VictoryScene.ts</files>
  <action>
  Update VictoryScene to display best-of-3 results with per-stage breakdown.

  **1. Update create() data interface to accept stage results:**
  The matchEnd broadcast from Plan 01 includes a `stageResults` array (StageSnapshot[]). Update the create signature:
  ```typescript
  create(data: {
    winner: string;
    stats: Record<string, any>;
    duration: number;
    localSessionId: string;
    room: any;
    stageResults?: Array<{
      stageNumber: number;
      arenaName: string;
      winner: string;
      duration: number;
      stats: Record<string, { kills: number; deaths: number; damageDealt: number; shotsFired: number; shotsHit: number }>;
    }>;
  })
  ```

  **2. Update the winner subtitle to show best-of-3 score:**
  Replace the simple "Paran Wins!" / "Guardians Win!" subtitle with the series score:
  ```typescript
  // Calculate series score from stageResults
  const stageResults = data.stageResults || [];
  let paranWins = 0, guardianWins = 0;
  for (const stage of stageResults) {
    if (stage.winner === 'paran') paranWins++;
    else guardianWins++;
  }
  const scoreLabel = `${winner === 'paran' ? 'Paran' : 'Guardians'} Win (${paranWins} - ${guardianWins})`;
  ```
  Use this scoreLabel instead of the simple winnerLabel.

  **3. Add per-stage breakdown section AFTER the match stats table:**
  After the existing stats table and gold divider, add a stage-by-stage breakdown:

  ```typescript
  // Per-Stage Breakdown (only if stageResults available)
  if (stageResults.length > 0) {
    yOffset += 20; // Space after divider

    this.add.text(cx, yOffset, 'STAGE BREAKDOWN', {
      ...TextStyle.heroHeading,
      fontSize: '18px',
      fontFamily: 'monospace',
    }).setOrigin(0.5).setDepth(1);
    yOffset += 30;

    for (const stage of stageResults) {
      const stageWinColor = stage.winner === 'paran' ? Colors.char.paran : Colors.char.faran;
      const stageWinLabel = stage.winner === 'paran' ? 'Paran' : 'Guardians';
      const durationSec = Math.round(stage.duration / 1000);
      const min = Math.floor(durationSec / 60);
      const sec = durationSec % 60;

      // Stage line: "Stage 1: Hedge Garden - Paran (2:34)"
      this.add.text(cx, yOffset,
        `Stage ${stage.stageNumber}: ${stage.arenaName}`, {
        fontSize: '15px',
        color: Colors.text.primary,
        fontFamily: 'monospace',
        fontStyle: 'bold',
        stroke: '#000000',
        strokeThickness: 2,
      }).setOrigin(0.5).setDepth(1);
      yOffset += 22;

      this.add.text(cx, yOffset,
        `Winner: ${stageWinLabel}  (${min}:${sec.toString().padStart(2, '0')})`, {
        fontSize: '13px',
        color: stageWinColor,
        fontFamily: 'monospace',
        stroke: '#000000',
        strokeThickness: 2,
      }).setOrigin(0.5).setDepth(1);
      yOffset += 26;
    }
  }
  ```

  **4. Adjust layout to accommodate new content:**
  The stage breakdown adds content below the existing stats table. The "Return to Lobby" button position needs to be dynamic based on content height. Change the button Y position from hardcoded `580` to `Math.max(580, yOffset + 30)`:
  ```typescript
  const buttonY = Math.max(580, yOffset + 30);
  const button = this.add.text(cx, buttonY, 'Return to Lobby', { ... });
  ```

  **5. Update the matchEnd handler in GameScene to pass stageResults:**
  This requires a SMALL change in GameScene.ts (both create() and attachRoomListeners() matchEnd handlers). Update the VictoryScene launch to include stageResults from the matchEnd data:
  ```typescript
  this.scene.launch("VictoryScene", {
    winner: data.winner,
    stats: data.stats,
    duration: data.duration,
    localSessionId: this.room!.sessionId,
    room: this.room,
    stageResults: data.stageResults || [],  // <-- ADD THIS
  });
  ```
  NOTE: This is a small edit in GameScene.ts. Plan 02 handles GameScene transitions, but this is a separate data-passing concern. If Plan 02 is executed first, this line needs adding. If Plan 03 executes first, Plan 02 needs it. Either way, add `stageResults: data.stageResults || []` to BOTH VictoryScene launch sites in GameScene (create() matchEnd handler and attachRoomListeners() matchEnd handler). This is a single property addition, not a structural conflict.
  </action>
  <verify>
  `cd /Users/jonasbrandvik/Projects/banger-game/client && npx tsc --noEmit` compiles without errors.
  Verify VictoryScene create() accepts stageResults parameter.
  Verify series score (e.g., "2 - 1") displayed instead of simple "Paran Wins!".
  Verify per-stage breakdown lists each stage with arena name, winner, and duration.
  Verify "Return to Lobby" button adjusts position based on content height.
  Verify GameScene matchEnd handlers pass stageResults to VictoryScene.
  </verify>
  <done>VictoryScene shows best-of-3 series score, per-stage breakdown with arena name/winner/duration for each stage, and dynamically positioned lobby button. GameScene passes stageResults data through to VictoryScene.</done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `cd /Users/jonasbrandvik/Projects/banger-game/client && npx tsc --noEmit`
2. HUD shows round score at top-center that updates when stages are won
3. HUD shows "Stage N" label that updates with currentStage
4. Health bars rebuild and timer resets between stages
5. VictoryScene shows series score (e.g., "Paran Win (2-1)")
6. VictoryScene shows per-stage breakdown (arena + winner + duration for each stage)
7. Return to Lobby button position adjusts dynamically
8. Client builds: `cd /Users/jonasbrandvik/Projects/banger-game/client && npm run build`
</verification>

<success_criteria>
Round score is visible throughout the match and updates live when stages are won. Victory screen shows full best-of-3 results with per-stage breakdown including arena names, stage winners, and durations. HUD correctly persists across stages with health bars and timer resetting for each new stage.
</success_criteria>

<output>
After completion, create `.planning/phases/09-multi-stage-rounds/09-03-SUMMARY.md`
</output>
