---
phase: 10-powerup-system
plan: 03
type: execute
wave: 2
depends_on: ["10-01"]
files_modified:
  - server/src/rooms/GameRoom.ts
  - client/src/systems/Prediction.ts
  - shared/physics.ts
autonomous: true

must_haves:
  truths:
    - "Speed buff increases effective maxVelocity by 50% in both server physics and client prediction"
    - "Invincibility buff blocks all damage (projectile and Paran contact kill)"
    - "Guardian projectile buff spawns 2x hitbox + 2x speed projectiles"
    - "Paran projectile buff fires beam projectiles (5x hitbox, wall-piercing, obstacle-destroying, 2x cooldown)"
    - "Beam projectiles pass through walls and destroy obstacles in their path"
    - "Client prediction uses synced speedMultiplier for rubber-band-free speed boost"
  artifacts:
    - path: "server/src/rooms/GameRoom.ts"
      provides: "Speed buff in physics, invincibility in damage checks, projectile/beam buff in fire processing"
      contains: "speedMultiplier"
    - path: "client/src/systems/Prediction.ts"
      provides: "speedMultiplier-aware prediction physics"
      contains: "speedMultiplier"
  key_links:
    - from: "server/src/rooms/GameRoom.ts"
      to: "shared/powerups.ts"
      via: "POWERUP_CONFIG constants for buff effects"
      pattern: "POWERUP_CONFIG\\.speedMultiplier"
    - from: "client/src/systems/Prediction.ts"
      to: "server/src/schema/GameState.ts"
      via: "reads Player.speedMultiplier for prediction"
      pattern: "speedMultiplier"
---

<objective>
Integrate buff effects into server-side gameplay mechanics (speed boost, invincibility, projectile/beam) and update client-side prediction to account for speed buff.

Purpose: Make powerup buffs actually affect gameplay. Speed boost changes movement, invincibility blocks damage, projectile buff enhances shots, and Paran's Beam creates a unique wall-piercing attack. Client prediction stays in sync via speedMultiplier.

Output: Modified `GameRoom.ts` with buff effects in physics, damage, and fire processing. Modified `Prediction.ts` reading speedMultiplier. Potentially modified `shared/physics.ts` if needed for parameterized maxVelocity.
</objective>

<execution_context>
@/Users/jonasbrandvik/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jonasbrandvik/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/10-powerup-system/10-RESEARCH.md
@.planning/phases/10-powerup-system/10-01-SUMMARY.md
@server/src/rooms/GameRoom.ts
@client/src/systems/Prediction.ts
@shared/physics.ts
@shared/characters.ts
@shared/powerups.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Apply speed buff to server physics and invincibility to damage checks</name>
  <files>
    server/src/rooms/GameRoom.ts
  </files>
  <action>
**1. Speed Buff in Player Physics Processing:**

In `fixedTick()`, inside the player processing loop (where `applyMovementPhysics` is called, around line ~540), modify the stats lookup to account for speed buff:

Before the existing `applyMovementPhysics` call:
```typescript
const stats = CHARACTERS[player.role];
// Apply speed buff: use effective maxVelocity
const effectiveMaxVelocity = stats.maxVelocity * player.speedMultiplier;
```

Then pass the effective value to `applyMovementPhysics`:
```typescript
applyMovementPhysics(player, input, FIXED_DT, {
  acceleration: stats.acceleration,
  drag: stats.drag,
  maxVelocity: effectiveMaxVelocity,
});
```

**Also** update the no-input velocity path (around line ~560). When player has no inputs this tick but is speed-buffed, the velocity integration should respect the boosted cap. The current no-input path just integrates position (`player.x += player.vx * FIXED_DT`), which is fine -- velocity was already capped during the last input processing. No change needed here.

**2. Invincibility Buff in Projectile Damage:**

In the projectile-player collision section of `fixedTick()` (around line ~657), after the `if (dist < COMBAT.playerRadius + COMBAT.projectileRadius)` check, add an invincibility guard BEFORE applying damage:

```typescript
if (dist < COMBAT.playerRadius + COMBAT.projectileRadius) {
  // Check invincibility buff
  const isInvincible = target.activeBuffs?.some(
    (b: any) => b.type === PowerupType.INVINCIBILITY && this.state.serverTime < b.expiresAt
  );
  if (isInvincible) {
    // Still destroy the projectile, but don't apply damage
    hit = true;
    return; // Skip damage
  }

  // Existing damage code follows...
}
```

Important: The projectile is still consumed (hit = true) even when target is invincible. This prevents projectiles from passing through invincible players.

**3. Invincibility Buff in Paran Contact Kill:**

In the Paran contact kill section (around line ~580), after the distance check `if (dist < COMBAT.playerRadius * 2)`, add invincibility guard:

```typescript
if (dist < COMBAT.playerRadius * 2) {
  // Check invincibility buff on guardian target
  const guardianInvincible = target.activeBuffs?.some(
    (b: any) => b.type === PowerupType.INVINCIBILITY && this.state.serverTime < b.expiresAt
  );
  if (guardianInvincible) return; // Skip kill -- guardian is invincible

  // Existing contact kill code follows...
}
```

Also check if Paran itself is invincible for the reverse case (this doesn't apply per game design since Paran is the contact killer, but for completeness, invincibility is per-decision only about damage immunity, not contact kill. Per decisions: "Fully immune to all damage" -- contact kill is damage, so invincible Paran should not be killable by projectiles. But Paran doesn't get killed by contact; Paran IS the contact killer. So only the guardian target needs the check here.)

**4. Projectile/Beam Buff in Fire Processing:**

In the fire input processing section (around line ~512-533), after the cooldown check but before spawning the projectile, add buff-aware logic:

```typescript
if (fire && player.health > 0) {
  const hasProjBuff = player.activeBuffs?.some(
    (b: any) => b.type === PowerupType.PROJECTILE && this.state.serverTime < b.expiresAt
  );

  // Determine effective fire rate
  let effectiveFireRate = stats.fireRate;
  if (hasProjBuff && player.role === 'paran') {
    effectiveFireRate = stats.fireRate * POWERUP_CONFIG.paranBeamCooldownMultiplier;
  }

  // Check cooldown with effective fire rate
  if (this.state.serverTime - player.lastFireTime >= effectiveFireRate) {
    const projectile = new Projectile();
    projectile.x = player.x;
    projectile.y = player.y;
    projectile.vx = Math.cos(player.angle) * stats.projectileSpeed;
    projectile.vy = Math.sin(player.angle) * stats.projectileSpeed;
    projectile.ownerId = sessionId;
    projectile.damage = stats.damage;
    projectile.spawnTime = this.state.serverTime;

    // Apply projectile buff effects
    if (hasProjBuff) {
      if (player.role === 'paran') {
        // Paran's Beam: 5x hitbox, wall-piercing
        projectile.isBeam = true;
        projectile.hitboxScale = POWERUP_CONFIG.paranBeamHitboxScale;
      } else {
        // Guardian: 2x hitbox + 2x speed
        projectile.hitboxScale = POWERUP_CONFIG.guardianHitboxScale;
        projectile.vx *= POWERUP_CONFIG.guardianSpeedScale;
        projectile.vy *= POWERUP_CONFIG.guardianSpeedScale;
      }
    }

    this.state.projectiles.push(projectile);
    player.lastFireTime = this.state.serverTime;

    const shooterStats = this.state.matchStats.get(sessionId);
    if (shooterStats) shooterStats.shotsFired++;
  }
}
```

**5. Beam Projectile Collision Handling:**

In the projectile processing loop (around line ~612-700), modify the tile/obstacle collision check to handle beam projectiles:

The current code at the wall collision check (around line ~627) does:
```typescript
if (this.collisionGrid.isSolid(projTile.tileX, projTile.tileY)) {
  // damage obstacle, destroy projectile
}
```

Replace with beam-aware logic:
```typescript
if (this.collisionGrid.isSolid(projTile.tileX, projTile.tileY)) {
  if (proj.isBeam) {
    // Beam passes through walls/obstacles -- destroy obstacle if destructible
    const obsKey = `${projTile.tileX},${projTile.tileY}`;
    const obs = this.state.obstacles.get(obsKey);
    if (obs && !obs.destroyed) {
      obs.hp = 0; // Beam instantly destroys any obstacle
      obs.destroyed = true;
      this.collisionGrid.clearTile(projTile.tileX, projTile.tileY);
    }
    // Do NOT remove the beam projectile -- it passes through
  } else {
    // Normal projectile: damage obstacle, destroy projectile
    const obsKey = `${projTile.tileX},${projTile.tileY}`;
    const obs = this.state.obstacles.get(obsKey);
    if (obs && !obs.destroyed) {
      obs.hp--;
      if (obs.hp <= 0) {
        obs.destroyed = true;
        this.collisionGrid.clearTile(projTile.tileX, projTile.tileY);
      }
    }
    this.state.projectiles.splice(i, 1);
    continue;
  }
}
```

**6. Buff-enhanced projectile-player collision radius:**

In the projectile-player collision check (around line ~666), account for `hitboxScale`:
```typescript
const effectiveRadius = COMBAT.projectileRadius * (proj.hitboxScale || 1);
if (dist < COMBAT.playerRadius + effectiveRadius) {
```

**7. Beam hits should NOT be consumed on first player hit:**
Normal projectiles splice on hit. Beam projectiles should continue through players (they're devastating). In the hit check, after damage is applied:
```typescript
if (hit && !proj.isBeam) {
  this.state.projectiles.splice(i, 1);
}
// If beam, it continues (not removed)
```

Wait -- the existing code uses `hit = true` inside the forEach, then after the forEach checks `if (hit) { splice }`. Modify this to:
```typescript
if (hit && !proj.isBeam) {
  this.state.projectiles.splice(i, 1);
}
```
  </action>
  <verify>
Run `cd /Users/jonasbrandvik/Projects/banger-game/server && npx tsc --noEmit` to confirm no TypeScript errors. Review the modified sections for logical correctness: speed buff applied before physics, invincibility checked before damage, beam passes through walls, enhanced hitbox used in collision radius.
  </verify>
  <done>All three buff types have gameplay effects: speed boost multiplies maxVelocity, invincibility blocks projectile damage and contact kills, projectile buff enhances guardian shots (2x hitbox + 2x speed) and creates Paran beam (5x hitbox, wall-piercing, obstacle-destroying, 2x cooldown). Beam projectiles correctly pass through walls and players.</done>
</task>

<task type="auto">
  <name>Task 2: Update client prediction to use speedMultiplier</name>
  <files>
    client/src/systems/Prediction.ts
  </files>
  <action>
**Modify `PredictionSystem`** to account for speed buff in client-side prediction.

The key issue: if the local player has a speed buff, the server applies `maxVelocity * 1.5` but the client prediction uses the base `maxVelocity`. This causes rubber-banding. The fix is to read `speedMultiplier` from the server state.

**1. Add a `speedMultiplier` field** to PredictionSystem:
```typescript
private speedMultiplier: number = 1;
```

**2. Add a setter method:**
```typescript
setSpeedMultiplier(multiplier: number): void {
  this.speedMultiplier = multiplier;
}
```

**3. In the replay/prediction method** (where `applyMovementPhysics` is called for input replay), modify the stats to use the effective maxVelocity:

Find where prediction calls `applyMovementPhysics` with character stats. It likely looks like:
```typescript
const stats = CHARACTERS[this.role];
applyMovementPhysics(this.localState, input.input, FIXED_DT, {
  acceleration: stats.acceleration,
  drag: stats.drag,
  maxVelocity: stats.maxVelocity,
});
```

Change to:
```typescript
const stats = CHARACTERS[this.role];
applyMovementPhysics(this.localState, input.input, FIXED_DT, {
  acceleration: stats.acceleration,
  drag: stats.drag,
  maxVelocity: stats.maxVelocity * this.speedMultiplier,
});
```

**4. In GameScene**, wherever the Player Schema's `speedMultiplier` changes, call `prediction.setSpeedMultiplier(newValue)`. This should happen in the player onChange handler. Look for where `player.onChange` or `player.listen` is set up for the local player. Add:
```typescript
// In the local player setup (where prediction is created)
// Listen for speedMultiplier changes
if (isLocal && this.prediction) {
  this.prediction.setSpeedMultiplier(player.speedMultiplier ?? 1);
}
```

This needs to be called in `handlePlayerChange()` (the method that fires on every player state change). Add a check:
```typescript
// Near the top of handlePlayerChange, for the local player:
if (isLocal && this.prediction) {
  this.prediction.setSpeedMultiplier(player.speedMultiplier ?? 1);
}
```

Note: Since `handlePlayerChange` fires on every property change, this will automatically pick up speedMultiplier changes. The `?? 1` fallback handles the case where the field hasn't synced yet.

**Important:** This file modification technically touches `GameScene.ts`, but it's a single line in an existing method (handlePlayerChange). The bulk of Plan 04's GameScene work is independent (powerup sprite rendering, aura management, stage cleanup). This one-line addition is a natural part of prediction integration and should be included here to keep the prediction system self-contained.
  </action>
  <verify>
Run `cd /Users/jonasbrandvik/Projects/banger-game/client && npx tsc --noEmit` to confirm no TypeScript errors. Verify PredictionSystem has `speedMultiplier` field and `setSpeedMultiplier()` method. Verify prediction replay uses `maxVelocity * this.speedMultiplier`. Verify GameScene's handlePlayerChange calls `setSpeedMultiplier` for local player.
  </verify>
  <done>Client prediction accounts for speed buff via synced speedMultiplier field. No rubber-banding when speed boost is active -- prediction and server agree on maxVelocity.</done>
</task>

</tasks>

<verification>
1. `cd server && npx tsc --noEmit` passes
2. `cd client && npx tsc --noEmit` passes
3. Speed buff multiplies maxVelocity in server physics AND client prediction
4. Invincibility blocks damage in projectile collision AND contact kill
5. Guardian projectile buff: 2x hitbox + 2x speed
6. Paran beam: 5x hitbox, isBeam=true, wall-piercing, obstacle-destroying, 2x cooldown
7. Beam projectiles survive wall and player collisions (not consumed)
8. Enhanced hitbox radius used in player collision detection
9. PredictionSystem reads speedMultiplier for accurate prediction replay
</verification>

<success_criteria>
Both server and client compile. All three buff types produce distinct, correct gameplay effects. Beam projectiles pass through walls and destroy obstacles. Client prediction stays in sync with speed-buffed movement. No invincible player can take damage from any source.
</success_criteria>

<output>
After completion, create `.planning/phases/10-powerup-system/10-03-SUMMARY.md`
</output>
