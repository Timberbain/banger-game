---
phase: 07-hd-viewport-camera
plan: 04
type: execute
wave: 2
depends_on: ["07-02"]
files_modified:
  - client/src/scenes/GameScene.ts
autonomous: true

must_haves:
  truths:
    - "GameScene camera is set to zoom=2 with roundPixels=true on create"
    - "Camera smoothly follows the local player with lerp 0.08 and small deadzone (40x30)"
    - "Camera clamps to world bounds -- no black void visible at arena edges"
    - "Look-ahead shifts camera in movement direction (60px for Paran, 30px for Guardians) via followOffset"
    - "Gentle lerp (0.04) on direction reversal prevents jarring camera whip"
    - "Paran gets subtle speed zoom-out at max velocity (zoom range 2.0 to 1.85)"
    - "Camera shake on wall impact (80ms, 0.003) and damage taken (100ms, 0.005)"
    - "Match-start overview shows full arena at zoom=1.0 for 1.5s then zooms to player at zoom=2.0"
    - "Controls are locked during match-start overview animation"
    - "Spectator camera follows closest alive player on death, Tab cycles targets"
    - "Spectating banner displayed with target player name"
    - "Camera state fully reset in create() for scene reuse (zoom, follow, offset, bounds)"
    - "Character sprites use setDisplaySize(32, 32) for correct world-space sizing with 64x64 textures"
    - "Projectile sprites use setDisplaySize(8, 8) for correct world-space sizing with 16x16 textures"
  artifacts:
    - path: "client/src/scenes/GameScene.ts"
      provides: "Complete camera system with follow, deadzone, look-ahead, speed zoom, shake, overview, spectator"
      contains: "setZoom(2)"
  key_links:
    - from: "client/src/scenes/GameScene.ts"
      to: "shared/maps.ts"
      via: "MapMetadata width/height for camera bounds"
      pattern: "setBounds.*mapMeta"
    - from: "client/src/scenes/GameScene.ts"
      to: "client/src/systems/Prediction.ts"
      via: "PredictionSystem constructor with arena bounds"
      pattern: "new PredictionSystem.*width.*height"
---

<objective>
Implement the complete camera system in GameScene: zoom=2 with pixel-perfect rendering, smooth follow with deadzone and look-ahead, speed zoom-out for Paran, camera shake on impacts, match-start overview animation, death spectator camera, and sprite display sizing for 2x textures in world space.

Purpose: The camera system is the core gameplay experience change of Phase 7. Players must see a smooth, responsive camera that follows their character, looks ahead in the movement direction, and provides cinematic effects (overview, shake, spectator).
Output: GameScene with fully functional camera system.
</objective>

<execution_context>
@/Users/jonasbrandvik/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jonasbrandvik/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@client/src/scenes/GameScene.ts
@client/src/systems/Prediction.ts
@shared/maps.ts
@shared/characters.ts
@.planning/phases/07-hd-viewport-camera/07-RESEARCH.md
@.planning/phases/07-hd-viewport-camera/07-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Camera setup, sprite sizing, and match-start overview</name>
  <files>client/src/scenes/GameScene.ts</files>
  <action>
**Camera State Reset in create():**
At the top of `create()`, before any game setup, reset camera state for scene reuse:
```typescript
const cam = this.cameras.main;
cam.setZoom(1);
cam.stopFollow();
cam.setBounds(0, 0, 99999, 99999); // temporary, will be set properly after map load
cam.setScroll(0, 0);
cam.followOffset.set(0, 0);
cam.setRoundPixels(true);
```
Also reset any new camera-related member variables:
```typescript
this.controlsLocked = false;
this.overviewActive = false;
```

**Camera Zoom + Bounds (after tilemap loads):**
After the tilemap is created and mapMetadata is available, set up the camera:
```typescript
cam.setZoom(2);
cam.setBounds(0, 0, this.mapMetadata.width, this.mapMetadata.height);
```
Where `this.mapMetadata` comes from the shared `MAPS` registry (already loaded in GameScene -- it has `.width` and `.height` in world pixels).

**Sprite Display Size for 2x Textures:**
Everywhere a player sprite is created (in `createPlayerSprite` or equivalent), after creating the sprite, add:
```typescript
sprite.setDisplaySize(32, 32);  // 64x64 texture displayed at 32x32 world size
```
This ensures 64x64 character textures occupy the correct 32x32 world-space area. Camera zoom=2 then renders them at 64x64 screen pixels with full detail.

Similarly for projectile sprites (in `createProjectileSprite` or wherever projectiles are created):
```typescript
projectileSprite.setDisplaySize(8, 8);  // 16x16 texture at 8x8 world size
```

**PredictionSystem with Dynamic Arena Bounds:**
When creating the PredictionSystem, pass the map's arena bounds:
```typescript
this.prediction = new PredictionSystem(initialState, role, {
  width: this.mapMetadata.width,
  height: this.mapMetadata.height,
});
```

**Match-Start Overview Animation:**
After camera setup and before gameplay begins, implement the overview:
```typescript
// Lock controls during overview
this.controlsLocked = true;
this.overviewActive = true;

// Calculate overview zoom to show full arena
// Use zoom=1.0 for clean integer rendering (shows 1280x720 of the 800x608 arena)
const overviewZoom = 1.0;
cam.setZoom(overviewZoom);
cam.centerOn(this.mapMetadata.width / 2, this.mapMetadata.height / 2);
cam.stopFollow();

// After 1.5s, zoom to player position
this.time.delayedCall(1500, () => {
  // Start following local player
  const localSprite = this.playerSprites.get(this.room.sessionId);
  if (localSprite) {
    cam.startFollow(localSprite, true, 0.08, 0.08);
    cam.setDeadzone(40, 30);
  }
  // Smooth zoom to gameplay level
  cam.zoomTo(2, 800, 'Sine.easeInOut');

  // Unlock controls after zoom completes
  this.time.delayedCall(800, () => {
    this.controlsLocked = false;
    this.overviewActive = false;
  });
});
```

The overview should trigger when the match state transitions to PLAYING (or when the local player first becomes ready). Integrate this with the existing match start flow. If there's already a "FIGHT!" text display, the overview should happen before/during it.

**Controls Lock Integration:**
In the input handling section of `update()`, check `this.controlsLocked` before processing any input:
```typescript
if (this.controlsLocked) {
  // Send no-input frame to server (keep connection alive)
  // Do NOT process keyboard state
  return; // or skip input processing
}
```
  </action>
  <verify>
1. `grep -n "setZoom(2)" client/src/scenes/GameScene.ts` shows camera zoom setup
2. `grep -n "setBounds" client/src/scenes/GameScene.ts` shows world bounds setting
3. `grep -n "setDisplaySize(32, 32)" client/src/scenes/GameScene.ts` shows sprite sizing
4. `grep -n "setDisplaySize(8, 8)" client/src/scenes/GameScene.ts` shows projectile sizing
5. `grep -n "controlsLocked" client/src/scenes/GameScene.ts` shows overview lock
6. `grep -n "centerOn" client/src/scenes/GameScene.ts` shows overview centering
7. `grep -n "zoomTo" client/src/scenes/GameScene.ts` shows overview-to-gameplay transition
8. `grep -n "new PredictionSystem" client/src/scenes/GameScene.ts` shows arena bounds param
  </verify>
  <done>Camera initialized at zoom=2, sprites sized for 2x textures in world space, match-start overview animation plays for 1.5s with controls locked, then zooms smoothly to follow local player.</done>
</task>

<task type="auto">
  <name>Task 2: Look-ahead, speed zoom, camera shake, and spectator camera</name>
  <files>client/src/scenes/GameScene.ts</files>
  <action>
**Look-Ahead System (in update() each frame):**
After processing input and before rendering, update camera follow offset based on velocity:
```typescript
// Only update look-ahead when not in overview and following local player
if (!this.overviewActive && !this.isSpectating && localPlayerState) {
  const vx = localPlayerState.vx;
  const vy = localPlayerState.vy;
  const localRole = this.localRole; // 'paran', 'faran', or 'baran'

  const LOOK_AHEAD_PARAN = 60;    // pixels ahead for Paran
  const LOOK_AHEAD_GUARDIAN = 30;  // pixels ahead for Guardians
  const maxLookAhead = localRole === 'paran' ? LOOK_AHEAD_PARAN : LOOK_AHEAD_GUARDIAN;

  const speed = Math.sqrt(vx * vx + vy * vy);
  const maxSpeed = CHARACTERS[localRole].maxVelocity;
  const lookFactor = Math.min(speed / maxSpeed, 1);

  // Target offset (followOffset is SUBTRACTED, so negate for look-ahead)
  const targetOffsetX = speed > 5 ? -(vx / speed) * maxLookAhead * lookFactor : 0;
  const targetOffsetY = speed > 5 ? -(vy / speed) * maxLookAhead * lookFactor : 0;

  // Gentle lerp for smooth direction reversal
  const OFFSET_LERP = 0.04;
  cam.followOffset.x += (targetOffsetX - cam.followOffset.x) * OFFSET_LERP;
  cam.followOffset.y += (targetOffsetY - cam.followOffset.y) * OFFSET_LERP;
}
```

**Speed Zoom-Out for Paran (in update()):**
Only when playing as Paran and not in overview/spectating:
```typescript
if (!this.overviewActive && localRole === 'paran' && localPlayerState) {
  const speed = Math.sqrt(localPlayerState.vx ** 2 + localPlayerState.vy ** 2);
  const maxSpeed = CHARACTERS.paran.maxVelocity;
  const speedRatio = Math.min(speed / maxSpeed, 1);

  const BASE_ZOOM = 2.0;
  const MIN_ZOOM = 1.85;
  const targetZoom = BASE_ZOOM - (BASE_ZOOM - MIN_ZOOM) * speedRatio;

  // Smooth lerp
  const currentZoom = cam.zoom;
  cam.setZoom(currentZoom + (targetZoom - currentZoom) * 0.03);
}
```
Guardians stay at zoom=2 always (no speed zoom).

**Camera Shake on Impacts:**
- Wall impact (Paran): When `this.prediction.getHadCollision()` returns true (already called in the existing code), trigger: `cam.shake(80, 0.003);`
- Taking damage: In the player health onChange handler (or wherever damage is detected via health cache), trigger: `cam.shake(100, 0.005);`
- These are subtle shakes -- 0.003 and 0.005 intensity are barely perceptible but provide tactile feedback.

Find the existing location where wall impact effects are triggered (after `getHadCollision()` call) and add the shake there. Find the existing location where damage is detected and add the shake there.

**Spectator Camera Enhancements:**
The existing spectator system (when local player dies) already follows a target. Enhance it:

1. When switching to spectator mode, change camera settings:
```typescript
// Spectator camera: wider deadzone, smoother follow
cam.setDeadzone(60, 45);
cam.followOffset.set(0, 0); // No look-ahead when spectating
```

2. Tab key to cycle spectator targets (add to input handling):
```typescript
if (this.isSpectating) {
  if (Phaser.Input.Keyboard.JustDown(this.tabKey)) {
    this.cycleSpectatorTarget();
  }
}
```
Add `this.tabKey = this.input.keyboard!.addKey(Phaser.Input.Keyboard.KeyCodes.TAB);` in create().
The `cycleSpectatorTarget()` method should cycle through alive players.

3. When starting to spectate (local player dies), find the closest alive player:
```typescript
// Find closest alive player
let closestId: string | null = null;
let closestDist = Infinity;
const localPos = /* last known position */;
this.room.state.players.forEach((p, id) => {
  if (id !== this.room.sessionId && p.health > 0) {
    const dist = Math.hypot(p.x - localPos.x, p.y - localPos.y);
    if (dist < closestDist) {
      closestDist = dist;
      closestId = id;
    }
  }
});
if (closestId) {
  this.setSpectatorTarget(closestId);
}
```

4. Add "Spectating: [Player Name]" banner. This should be emitted as an event for HUDScene to display (or rendered directly in GameScene if simpler). The spectator system already emits 'spectatorChanged' event -- ensure it includes the player name.

**New Member Variables to declare:**
```typescript
private controlsLocked: boolean = false;
private overviewActive: boolean = false;
private tabKey!: Phaser.Input.Keyboard.Key;
```
Reset all in create().
  </action>
  <verify>
1. `grep -n "followOffset" client/src/scenes/GameScene.ts` shows look-ahead implementation
2. `grep -n "LOOK_AHEAD" client/src/scenes/GameScene.ts` shows look-ahead constants
3. `grep -n "MIN_ZOOM" client/src/scenes/GameScene.ts` shows speed zoom-out
4. `grep -n "cam.shake" client/src/scenes/GameScene.ts` shows shake calls
5. `grep -n "tabKey" client/src/scenes/GameScene.ts` shows Tab key spectator cycling
6. `grep -n "cycleSpectatorTarget" client/src/scenes/GameScene.ts` shows target cycling
7. `grep -n "Spectating" client/src/scenes/GameScene.ts` or HUDScene shows spectator banner
  </verify>
  <done>Camera has look-ahead (60px Paran, 30px Guardians with gentle 0.04 lerp), speed zoom-out for Paran (2.0 to 1.85), shake on wall impact and damage, spectator camera follows closest alive player with Tab cycling and "Spectating" banner.</done>
</task>

</tasks>

<verification>
- Camera zoom=2 with roundPixels on GameScene
- Camera follows local player with deadzone 40x30
- Camera bounds set to map dimensions (no black void)
- Look-ahead active during gameplay, disabled during spectating/overview
- Speed zoom-out visible for Paran at max velocity
- Camera shake triggers on wall impact and damage
- Match-start overview shows full arena then zooms in
- Controls locked during overview
- Spectator camera works on death with Tab cycling
- Sprites correctly sized for world space (32x32 characters, 8x8 projectiles)
</verification>

<success_criteria>
The camera system provides a smooth, responsive gameplay experience: tight follow with look-ahead, cinematic overview on match start, subtle effects (shake, zoom), and functional death spectator mode. All 14 locked camera decisions from CONTEXT.md are implemented.
</success_criteria>

<output>
After completion, create `.planning/phases/07-hd-viewport-camera/07-04-SUMMARY.md`
</output>
