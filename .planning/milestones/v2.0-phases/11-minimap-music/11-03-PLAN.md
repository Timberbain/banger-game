---
phase: 11-minimap-music
plan: 03
type: execute
wave: 2
depends_on:
  - "11-01"
files_modified:
  - client/src/scenes/LobbyScene.ts
  - client/src/scenes/GameScene.ts
  - client/src/scenes/VictoryScene.ts
  - client/src/scenes/StageIntroScene.ts
autonomous: true
requirements:
  - AUD-01
  - AUD-02
  - AUD-03

must_haves:
  truths:
    - "Lobby scene plays Pixel Jitter Jive.mp3 on loop with ~1s pause between loops"
    - "A random stage track from 3 options is selected when a new game starts"
    - "The same stage track plays throughout all stages of a match"
    - "Lobby to stage transition crossfades music over ~1s"
    - "Between stages, music volume dips to ~30% during iris wipe and stage intro, then restores"
    - "Stage to victory/defeat transition fades out music over ~0.5s"
    - "Victory screen plays victory.mp3 once with firework SFX tied to particle bursts"
    - "Defeat screen plays lose_1.wav then defeat.mp3 once"
    - "Victory/defeat to lobby crossfades back to lobby music"
    - "WAV SFX replace jsfxr for: hurt (randomized 1-4), guardian fire (randomized laser_1/4/5), Paran power shot (earthquake+lightning), player killed (disappear), menu buttons (select_1/2)"
    - "Volume sliders for music and SFX in lobby scene settings area"
    - "Volume settings persist to localStorage across sessions"
  artifacts:
    - path: "client/src/scenes/LobbyScene.ts"
      provides: "Lobby music start with pause-loop, volume sliders, crossfade to game"
      contains: "playMusicWithPause"
    - path: "client/src/scenes/GameScene.ts"
      provides: "Stage music selection, crossfade from lobby, SFX replacements, stage transition volume dip"
      contains: "crossfadeTo"
    - path: "client/src/scenes/VictoryScene.ts"
      provides: "Victory/defeat music and firework SFX, crossfade back to lobby"
      contains: "victory.mp3"
    - path: "client/src/scenes/StageIntroScene.ts"
      provides: "Volume dip during stage intro"
      contains: "dipMusicVolume"
  key_links:
    - from: "client/src/scenes/GameScene.ts"
      to: "client/src/systems/AudioManager.ts"
      via: "crossfadeTo for lobby->stage music transition"
      pattern: "crossfadeTo\\("
    - from: "client/src/scenes/VictoryScene.ts"
      to: "client/src/systems/AudioManager.ts"
      via: "fadeOutMusic + playMusic for result tracks"
      pattern: "fadeOutMusic\\("
    - from: "client/src/scenes/LobbyScene.ts"
      to: "client/src/systems/AudioManager.ts"
      via: "playMusicWithPause for lobby loop"
      pattern: "playMusicWithPause\\("
---

<objective>
Wire music playback and crossfade transitions into all game scenes. Replace jsfxr SFX calls with WAV variants. Add volume sliders to lobby.

Purpose: Give the game atmosphere through music with smooth scene transitions and higher-quality WAV sound effects replacing procedural jsfxr sounds.
Output: Full music lifecycle (lobby loop -> crossfade to stage -> volume dip between stages -> fade to victory/defeat -> crossfade back to lobby). All key SFX replaced with WAV files.
</objective>

<execution_context>
@/Users/jonasbrandvik/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jonasbrandvik/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-minimap-music/11-RESEARCH.md
@.planning/phases/11-minimap-music/11-01-SUMMARY.md
@client/src/systems/AudioManager.ts
@client/src/scenes/GameScene.ts
@client/src/scenes/LobbyScene.ts
@client/src/scenes/VictoryScene.ts
@client/src/scenes/StageIntroScene.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Lobby music, volume sliders, and menu SFX replacements</name>
  <files>client/src/scenes/LobbyScene.ts</files>
  <action>
  **Lobby music start:**
  In LobbyScene, after the menu view is shown (or in create() after checkReconnection completes), start lobby music with a 0.5s delay:

  ```typescript
  // After audioManager is retrieved from registry in create():
  if (this.audioManager) {
    this.time.delayedCall(500, () => {
      if (this.audioManager) {
        this.audioManager.playMusicWithPause('audio/lobby/Pixel Jitter Jive.mp3', 1000);
      }
    });
  }
  ```

  Note: LobbyScene is reached both on first load AND when returning from VictoryScene. The VictoryScene will handle crossfading back to lobby music (Plan 03 Task 3), so LobbyScene should check if music is already playing. Actually, `playMusicWithPause` calls `stopMusic()` first internally, so it's safe to always call it. The crossfade from VictoryScene will have already transitioned to lobby music, but a second call 500ms later will just restart the loop -- this is fine since the lobby just loaded.

  Actually, better approach: Add a field `private lobbyMusicStarted: boolean = false;` and in create(), reset it to false. Start music only if not already playing. But simpler: just always call playMusicWithPause. If VictoryScene already crossfaded to it, the worst case is a brief restart.

  Wait -- cleanest approach per research: VictoryScene should crossfade TO the lobby music file. Then when LobbyScene loads, it should NOT restart music if it's already the lobby track. Add a simple check:

  ```typescript
  // In create(), after 500ms delay:
  // Only start if no music is currently playing (VictoryScene crossfade handles the transition case)
  if (this.audioManager && !this.audioManager.isPlayingMusic()) {
    this.audioManager.playMusicWithPause('audio/lobby/Pixel Jitter Jive.mp3', 1000);
  }
  ```

  This requires adding `isPlayingMusic(): boolean` to AudioManager (returns `this.currentMusic !== null && !this.currentMusic.paused`). If Plan 01 didn't add this, the executor should add it as a quick getter.

  **Menu button SFX replacement:**
  Replace all `this.audioManager.playSFX('button_click')` calls with `this.audioManager.playWAVSFX('select_1')`. There are approximately 6-7 occurrences in LobbyScene. Use find-and-replace.

  Also replace `this.audioManager.playSFX('ready_chime')` with `this.audioManager.playWAVSFX('select_2')` (the ready chime in lobby when player readies up).

  **Volume sliders:**
  The lobby already has volume controls (see the existing `createVolumeControls` or similar method with +/- buttons). Replace the +/- buttons with proper slider controls. The existing implementation uses simple increment/decrement buttons at lines ~1187-1200.

  Replace with slider-style UI. Per user decision, these are "Separate music + SFX volume sliders in lobby scene settings area." The exact visual design is Claude's discretion.

  Implementation: Replace the existing volume +/- buttons with two horizontal sliders (one for Music, one for SFX). Each slider:
  - Background bar (dark, 120px wide, 8px tall)
  - Fill bar (colored, width = volume * 120px)
  - Clickable area that sets volume based on click x-position
  - Label text: "Music" / "SFX" with percentage display
  - Position in the existing settings area of the lobby

  Use `this.add.rectangle` for the slider bars and `this.input.on('pointerdown')` or make the rectangle interactive for click-to-set. Update AudioManager volume on click. The slider fill updates on every click.

  Volume changes via slider should be immediately audible (music volume changes in real-time, SFX plays a test sound on change).
  </action>
  <verify>
  - Grep for `playMusicWithPause` in LobbyScene.ts -- should find at least 1 occurrence
  - Grep for `button_click` in LobbyScene.ts -- should find 0 occurrences (all replaced)
  - Verify LobbyScene compiles: `cd client && npx tsc --noEmit`
  </verify>
  <done>
  Lobby plays Pixel Jitter Jive.mp3 on loop with 1s pause. Menu buttons use select_1.wav SFX. Volume sliders for music and SFX replace +/- buttons. Volume settings persist via existing localStorage mechanism.
  </done>
</task>

<task type="auto">
  <name>Task 2: Stage music, WAV SFX replacements, and transition audio in GameScene</name>
  <files>client/src/scenes/GameScene.ts</files>
  <action>
  **Stage music constants (top of file):**
  ```typescript
  const STAGE_MUSIC_TRACKS = [
    'audio/stage/Forest Deco Run.mp3',
    'audio/stage/Art Deco Forest Arena.mp3',
    'audio/stage/Per Ropar Glas (Remastered v2).mp3',
  ];
  ```

  **New member variable:**
  ```typescript
  private stageTrack: string = '';
  ```
  Reset in create(): `this.stageTrack = '';`

  **Stage music selection and crossfade from lobby:**
  When the match starts (matchState becomes 'playing' for the first time), select a random stage track and crossfade from lobby music:

  In the matchState listener where `value === 'playing'`:
  ```typescript
  // Select stage track on first stage only (stageTrack empty means first start)
  if (!this.stageTrack && this.audioManager) {
    this.stageTrack = STAGE_MUSIC_TRACKS[Math.floor(Math.random() * STAGE_MUSIC_TRACKS.length)];
    this.audioManager.crossfadeTo(this.stageTrack, true, 1000); // 1s crossfade, loop
  }
  ```

  **Stage transition volume dip:**
  In the stageEnd handler (where `this.inStageTransition = true` is set):
  ```typescript
  if (this.audioManager) {
    this.audioManager.dipMusicVolume(0.3); // Dip to 30%
  }
  ```

  In the stageStart handler (where `this.inStageTransition = false` is set), after the overview animation completes:
  ```typescript
  if (this.audioManager) {
    this.audioManager.restoreMusicVolume();
  }
  ```

  Actually, restore should happen when gameplay starts (after overview). Put it in the overview completion callback, right after `this.overviewActive = false;`:
  ```typescript
  if (this.audioManager) this.audioManager.restoreMusicVolume();
  ```

  **Match end music fade:**
  In the matchEnd handler (where stats are received):
  ```typescript
  if (this.audioManager) {
    this.audioManager.fadeOutMusic(500); // 0.5s fade out
  }
  ```
  Remove the existing `this.audioManager.stopMusic()` calls -- replace with `fadeOutMusic(500)`.
  Also remove the existing `this.audioManager.playMusic('audio/match_music.mp3')` calls -- the new crossfade system handles this.

  **WAV SFX replacements in GameScene:**
  All replacements maintain the existing null-safe pattern (`if (this.audioManager) ...`).

  1. **Guardian fire** (currently `playSFX('${this.localRole}_shoot')`):
     Replace with logic that checks if the shooter is a guardian (faran/baran):
     ```typescript
     if (this.localRole === 'paran') {
       // Check if Paran has weapon powerup (beam)
       const localPlayer = this.room.state.players.get(this.room.sessionId);
       const hasWeaponBuff = localPlayer?.activeBuffs?.some?.((b: any) => Number(b) === PowerupType.PROJECTILE);
       if (hasWeaponBuff) {
         this.audioManager.playMultipleWAV(['earthquake', 'lightning']);
       } else {
         this.audioManager.playSFX(`paran_shoot`); // Keep jsfxr for normal Paran shot
       }
     } else {
       this.audioManager.playRandomWAV(['laser_1', 'laser_4', 'laser_5']);
     }
     ```
     Note: Paran's activeBuffs is server-only. We can't check it on client. Instead, check if speedMultiplier or another indicator exists. Actually simpler: check if the projectile fired is a beam via the 'beamFire' message, or just check `localRole !== 'paran'` for guardian fire. Paran normal shot keeps jsfxr. Paran beam fire is handled separately via the powerup system -- when Paran fires with weapon buff, check `hasProjectileBuff` (which can be tracked client-side from the 'powerupCollect' message). Add a field `private hasProjectileBuff: boolean = false;` that is set true on powerupCollect with type PROJECTILE and false on buffExpired with type PROJECTILE. Then:
     ```typescript
     if (this.localRole !== 'paran') {
       // Guardian fire
       this.audioManager.playRandomWAV(['laser_1', 'laser_4', 'laser_5']);
     } else if (this.hasProjectileBuff) {
       // Paran beam fire
       this.audioManager.playMultipleWAV(['earthquake', 'lightning']);
     } else {
       this.audioManager.playSFX('paran_shoot'); // Normal Paran jsfxr
     }
     ```

  2. **Remote player shoot** (currently `playSFX('${ownerPlayer.role}_shoot')`):
     Replace with:
     ```typescript
     if (ownerPlayer.role !== 'paran') {
       this.audioManager.playRandomWAV(['laser_1', 'laser_4', 'laser_5']);
     } else {
       this.audioManager.playSFX('paran_shoot');
     }
     ```
     (Paran beam detection for remote players: check if the newly created projectile has `isBeam` flag.)
     If `projectile.isBeam`: `this.audioManager.playMultipleWAV(['earthquake', 'lightning']);`

  3. **Player hurt / Paran wall collision** (currently `playSFX('wall_impact')` and `playSFX('${player.role}_hit')`):
     Replace both with: `this.audioManager.playRandomWAV(['hurt_1', 'hurt_2', 'hurt_3', 'hurt_4']);`

  4. **Player killed** (currently `playSFX('${player.role}_death')`):
     Replace with: `this.audioManager.playWAVSFX('disappear');`

  5. **Match start fanfare**: Keep existing jsfxr `match_start_fanfare` (no WAV replacement specified for this).

  6. **Match end fanfare**: Keep existing jsfxr `match_end_fanfare`.

  7. **Powerup sounds**: Keep existing (powerup_pickup WAV already registered, powerup_spawn and powerup_despawn are jsfxr).

  Add member variable and tracking for Paran projectile buff:
  ```typescript
  private hasProjectileBuff: boolean = false;
  ```
  Reset in create(). Set/clear via existing powerupCollect/buffExpired message handlers.
  </action>
  <verify>
  - Grep for `match_music.mp3` in GameScene.ts -- should find 0 occurrences (replaced)
  - Grep for `crossfadeTo` in GameScene.ts -- should find at least 1 occurrence
  - Grep for `playRandomWAV` in GameScene.ts -- should find occurrences for guardian fire and hurt
  - Grep for `disappear` in GameScene.ts -- should find at least 1 occurrence
  - Verify GameScene compiles: `cd client && npx tsc --noEmit`
  </verify>
  <done>
  Random stage track selected at match start, crossfaded from lobby music. Music dips to 30% during stage transitions, restores after overview. Music fades out on match end. WAV SFX replace jsfxr for: guardian fire (randomized laser), hurt/wall impact (randomized hurt), player killed (disappear), Paran beam fire (earthquake+lightning).
  </done>
</task>

<task type="auto">
  <name>Task 3: Victory/defeat music and firework SFX in VictoryScene + StageIntroScene volume dip</name>
  <files>
    client/src/scenes/VictoryScene.ts
    client/src/scenes/StageIntroScene.ts
  </files>
  <action>
  **VictoryScene:**
  Get AudioManager from registry (already done at line 277):
  ```typescript
  const audioManager = this.registry.get('audioManager') as AudioManager | null;
  ```

  After determining `didWin`:

  **If victory:**
  ```typescript
  // Small silence gap (music already fading from GameScene), then play victory track
  this.time.delayedCall(600, () => {
    if (audioManager) {
      audioManager.playMusic('audio/gameover/victory.mp3', false); // play once, no loop
    }
  });
  ```

  Add firework SFX tied to particle burst spawns. The existing victory burst code creates particles. Modify the victory particle burst to also play randomized firework SFX:
  ```typescript
  // Create timed firework bursts (3-5 bursts over 2-3 seconds)
  if (didWin && audioManager) {
    const fireworkTimes = [800, 1400, 2000, 2600, 3200];
    for (const delay of fireworkTimes) {
      this.time.delayedCall(delay, () => {
        audioManager.playRandomWAV(['fire_1', 'fire_2', 'fire_3']);
        // Spawn a particle burst at random position
        if (particleFactory) {
          const rx = cx + Phaser.Math.Between(-200, 200);
          const ry = cy + Phaser.Math.Between(-150, 50);
          particleFactory.victoryBurst(rx, ry);
        }
      });
    }
  }
  ```
  Note: The existing code may already have a victory burst. Integrate firework SFX into it, or add additional bursts if the existing one is just a single burst.

  **If defeat:**
  ```typescript
  if (audioManager) {
    audioManager.playWAVSFX('lose_1'); // Defeat sting first
    this.time.delayedCall(1200, () => {
      audioManager.playMusic('audio/gameover/defeat.mp3', false); // Then defeat track, play once
    });
  }
  ```

  **Return to lobby crossfade:**
  In the "Return to Lobby" button click handler, crossfade to lobby music:
  ```typescript
  if (audioManager) {
    audioManager.crossfadeTo('audio/lobby/Pixel Jitter Jive.mp3', false, 800);
    // Note: loop=false here because LobbyScene will call playMusicWithPause to set up the proper loop-with-pause
    // Actually, better: just fade out the result track, let LobbyScene handle starting lobby music
    audioManager.fadeOutMusic(500);
  }
  ```
  Wait, the user decision says "Victory/defeat -> lobby: crossfade (result track fades out, lobby music fades in with 0.5s delay)". So crossfade TO lobby music from VictoryScene:
  ```typescript
  if (audioManager) {
    // Small delay then crossfade to lobby music
    // Use crossfadeTo which handles the simultaneous fade-out/fade-in
    this.time.delayedCall(500, () => {
      audioManager.crossfadeTo('audio/lobby/Pixel Jitter Jive.mp3', false, 800);
      // LobbyScene will detect music is playing and set up the loop-with-pause properly
    });
  }
  ```
  Actually simpler: do the crossfade immediately on button click, the 0.5s delay is the crossfade duration. Use `crossfadeTo` with 800ms duration. The lobby scene on load checks if music is playing and skips restart.

  BUT: `crossfadeTo` with `loop=false` means the lobby track plays once then stops. We need the lobby track to loop with pause. The cleanest approach: In the Return to Lobby handler, just `fadeOutMusic(500)`. Then LobbyScene's create() starts playMusicWithPause after 500ms delay. The total transition: 500ms fade out, brief silence, then lobby music starts with 500ms delay = ~1s total, which feels like a crossfade to the player.

  Actually the user says "crossfade (result track fades out, lobby music fades in with 0.5s delay)". So: fade out result, 0.5s gap, then start lobby music. Implementation:
  ```typescript
  // In Return to Lobby button handler:
  if (audioManager) audioManager.fadeOutMusic(500);
  // LobbyScene.create() starts lobby music after 500ms delay (existing logic from Task 1)
  ```
  This matches: fade out (500ms) + silence gap + lobby starts (500ms delay in LobbyScene) = smooth transition.

  **Replace button_click SFX** in VictoryScene: change `audioManager.playSFX('button_click')` to `audioManager.playWAVSFX('select_1')`.

  **StageIntroScene:**
  Read StageIntroScene to understand its lifecycle. It's an overlay shown during stage transitions. Add volume dip when it appears and restore when it's done.

  In StageIntroScene create():
  ```typescript
  const audioManager = this.registry.get('audioManager') as AudioManager | null;
  if (audioManager) {
    audioManager.dipMusicVolume(0.3); // Dip during intro overlay
  }
  ```

  Actually, the dip is already handled in GameScene's stageEnd handler (Task 2). And restore is in the overview completion. StageIntroScene sits between those two points, so the dip is already active. No additional dip needed in StageIntroScene -- just ensure it doesn't call restoreMusicVolume prematurely.

  Verify by reading StageIntroScene: if it has any stopMusic/playMusic calls, remove them. If it has no audio calls, no changes needed here.

  If StageIntroScene does NOT need changes, note that in the summary and skip it. The dipMusicVolume in GameScene stageEnd and restoreMusicVolume in GameScene overview completion bracket the entire StageIntroScene lifecycle.
  </action>
  <verify>
  - Grep for `victory.mp3` in VictoryScene.ts -- should find at least 1 occurrence
  - Grep for `defeat.mp3` in VictoryScene.ts -- should find at least 1 occurrence
  - Grep for `fire_1` in VictoryScene.ts -- should find at least 1 occurrence (firework SFX)
  - Grep for `button_click` in VictoryScene.ts -- should find 0 occurrences (replaced)
  - Verify all modified files compile: `cd client && npx tsc --noEmit`
  </verify>
  <done>
  Victory screen plays victory.mp3 with firework SFX bursts. Defeat screen plays lose_1.wav then defeat.mp3. Return to lobby fades out result music, LobbyScene starts lobby loop. Music dip during stage transitions handled by GameScene bracketing StageIntroScene. VictoryScene button SFX uses select_1.wav.
  </done>
</task>

</tasks>

<verification>
1. Lobby music plays on loop with ~1s pause between repetitions
2. Starting a match crossfades from lobby to a random stage track over ~1s
3. Same stage track plays through all stages of a best-of-3 match
4. Between stages, music dips to ~30% during iris wipe and stage intro, then restores
5. Match end fades music out over ~0.5s
6. Victory screen plays victory.mp3 with randomized firework SFX
7. Defeat screen plays lose_1.wav then defeat.mp3
8. Returning to lobby fades out result track, lobby music resumes
9. Guardian fire uses randomized laser WAV sounds
10. Player hurt and wall collision use randomized hurt WAV sounds
11. Player death uses disappear.wav
12. Paran beam fire plays earthquake+lightning simultaneously
13. Menu buttons use select_1.wav / select_2.wav instead of jsfxr
14. Volume sliders in lobby work and persist settings
</verification>

<success_criteria>
Complete music lifecycle across all scenes with smooth crossfade transitions. WAV SFX replace jsfxr for all specified sounds. Volume sliders in lobby with localStorage persistence. No jarring audio cuts or silence gaps during normal gameplay flow.
</success_criteria>

<output>
After completion, create `.planning/phases/11-minimap-music/11-03-SUMMARY.md`
</output>
