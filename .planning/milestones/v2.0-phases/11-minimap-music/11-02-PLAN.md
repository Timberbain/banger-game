---
phase: 11-minimap-music
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - client/src/scenes/HUDScene.ts
  - client/src/scenes/GameScene.ts
autonomous: true
requirements:
  - MMAP-01
  - MMAP-02
  - MMAP-03

must_haves:
  truths:
    - "A semi-transparent minimap overlay is visible in the top-right corner during gameplay"
    - "Minimap shows dark gray rectangles for solid wall/obstacle tiles from CollisionGrid"
    - "Player positions appear as role-colored dots (green Paran, blue Faran, red Baran) that move in real-time"
    - "Powerup positions appear as small colored dots (gold/cyan/purple) matching type"
    - "Destroyed obstacles disappear from minimap in real-time"
    - "Minimap can be toggled on/off with M key"
    - "Minimap is hidden during stage transitions and overview camera, reappears when gameplay starts"
    - "Toggle state persists across stages"
    - "Eliminated players show a brief death marker that fades out over 2 seconds"
  artifacts:
    - path: "client/src/scenes/HUDScene.ts"
      provides: "Minimap rendering with Graphics object, toggle keybind, death markers"
      contains: "redrawMinimap"
    - path: "client/src/scenes/GameScene.ts"
      provides: "Collision grid and map metadata shared via Phaser registry"
      contains: "registry.set"
  key_links:
    - from: "client/src/scenes/GameScene.ts"
      to: "client/src/scenes/HUDScene.ts"
      via: "Phaser game registry (collisionGrid, mapMetadata)"
      pattern: "registry\\.set\\('collisionGrid'"
    - from: "client/src/scenes/HUDScene.ts"
      to: "shared/collisionGrid.ts"
      via: "isSolid() calls for wall rendering"
      pattern: "isSolid\\("
---

<objective>
Implement a semi-transparent minimap overlay on HUDScene showing wall layout, player positions, and powerup locations. Share collision grid data from GameScene via Phaser registry.

Purpose: Give players global arena awareness during gameplay, critical for navigating 1600x1216 arenas at 2x zoom where most of the map is off-screen.
Output: Working minimap overlay with wall blocks, player dots, powerup dots, death markers, toggle keybind, and stage transition visibility management.
</objective>

<execution_context>
@/Users/jonasbrandvik/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jonasbrandvik/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-minimap-music/11-RESEARCH.md
@client/src/scenes/HUDScene.ts
@client/src/scenes/GameScene.ts
@shared/collisionGrid.ts
@shared/maps.ts
@shared/powerups.ts
@client/src/ui/designTokens.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Share collision grid and map metadata via registry from GameScene</name>
  <files>client/src/scenes/GameScene.ts</files>
  <action>
  In GameScene, after the collision grid is built from the tilemap JSON, share it and the map metadata via the Phaser game registry so HUDScene can read them.

  **Find the `createTilemap` method** (or wherever the CollisionGrid is constructed from map data). After the collision grid is assigned to `this.collisionGrid`, add:

  ```typescript
  this.registry.set('collisionGrid', this.collisionGrid);
  ```

  Also share the map metadata (arena dimensions) needed for minimap scaling. After mapMetadata is available, add:

  ```typescript
  this.registry.set('mapMetadata', this.mapMetadata);
  ```

  There may be multiple code paths where the tilemap is created (initial load and stage transition/reconnect). Ensure registry.set is called in ALL paths where collisionGrid/mapMetadata is initialized.

  **Important:** The registry stores object references, not copies. When GameScene's collisionGrid updates (e.g., obstacle destroyed), HUDScene sees the change automatically via the same reference. No additional sync needed.

  Also add registry.set calls in the reconnect path (`attachRoomListeners`) wherever collisionGrid is rebuilt.

  **Do NOT modify any audio-related code in GameScene.** This plan only adds registry.set calls.
  </action>
  <verify>
  - Grep for `registry.set('collisionGrid'` in GameScene.ts -- should find at least 1 occurrence
  - Grep for `registry.set('mapMetadata'` in GameScene.ts -- should find at least 1 occurrence
  - Verify GameScene compiles: `cd client && npx tsc --noEmit`
  </verify>
  <done>
  GameScene shares collisionGrid and mapMetadata via Phaser registry in all code paths (initial load, stage transition, reconnect). HUDScene can read these via registry.get().
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement minimap overlay on HUDScene</name>
  <files>client/src/scenes/HUDScene.ts</files>
  <action>
  Add minimap rendering to HUDScene using `Phaser.GameObjects.Graphics`. This is a substantial addition -- add it as section "11. MINIMAP" following the existing numbered section pattern.

  **New member variables** (add to class declaration, reset in create()):
  ```typescript
  // Minimap
  private minimapGfx: Phaser.GameObjects.Graphics | null = null;
  private minimapVisible: boolean = true;
  private minimapUserToggled: boolean = true; // persists user preference across stages
  private minimapToggleKey: Phaser.Input.Keyboard.Key | null = null;
  private minimapFrameCounter: number = 0;
  private minimapDeathMarkers: Array<{ x: number; y: number; color: number; time: number }> = [];
  private minimapToggleJustPressed: boolean = false;
  ```

  **Reset in create():** All minimap variables must be reset EXCEPT `minimapUserToggled` -- it persists across stages. Add `minimapUserToggled` as a class-level field that is NOT reset in create() (it keeps its value across scene.start reuse). Actually, since HUDScene is launched fresh each time via scene.launch, use the registry to persist it: `this.minimapUserToggled = this.registry.get('minimapUserToggled') ?? true;` in create().

  **In create():**
  1. Create graphics object: `this.minimapGfx = this.add.graphics(); this.minimapGfx.setDepth(150);`
  2. Register M key: `this.minimapToggleKey = this.input.keyboard?.addKey('M') || null;`
  3. Call `this.createMinimap();`

  **createMinimap() method:**
  - Read toggle state from registry: `this.minimapUserToggled = this.registry.get('minimapUserToggled') ?? true;`
  - Set initial visibility: `this.minimapVisible = this.minimapUserToggled;`

  **In update():** Add minimap update calls:
  1. Handle M key toggle (with just-pressed detection to avoid rapid toggling):
     ```typescript
     if (this.minimapToggleKey?.isDown && !this.minimapToggleJustPressed) {
       this.minimapToggleJustPressed = true;
       this.minimapUserToggled = !this.minimapUserToggled;
       this.registry.set('minimapUserToggled', this.minimapUserToggled);
       this.minimapVisible = this.minimapUserToggled;
       // Play toggle SFX (use AudioManager from registry)
       const am = this.registry.get('audioManager');
       if (am) {
         am.playWAVSFX(this.minimapVisible ? 'select_2' : 'select_1');
       }
     }
     if (this.minimapToggleKey && !this.minimapToggleKey.isDown) {
       this.minimapToggleJustPressed = false;
     }
     ```
  2. Throttle minimap redraw to ~10Hz: `this.minimapFrameCounter++; if (this.minimapFrameCounter % 6 === 0) this.redrawMinimap();`

  **redrawMinimap() method:**
  Constants:
  - `mmW = 150, mmH = 115` (minimap dimensions)
  - `mmX = this.W - mmW - 10` (10px margin from right edge)
  - `mmY = 10` (10px margin from top)

  Get data:
  ```typescript
  const grid = this.registry.get('collisionGrid') as CollisionGrid | null;
  const meta = this.registry.get('mapMetadata') as { width: number; height: number } | null;
  if (!grid || !meta || !this.minimapGfx) return;
  if (!this.minimapVisible) { this.minimapGfx.clear(); return; }
  ```

  Import CollisionGrid at top of file: `import { CollisionGrid } from '../../../shared/collisionGrid';`

  Compute scale factors:
  ```typescript
  const scaleX = mmW / meta.width;
  const scaleY = mmH / meta.height;
  const tileSize = 32;
  ```

  Draw:
  1. `this.minimapGfx.clear();`
  2. Semi-transparent black background: `this.minimapGfx.fillStyle(0x000000, 0.4); this.minimapGfx.fillRect(mmX, mmY, mmW, mmH);`
  3. Wall blocks (dark gray): iterate grid rows/cols, for each `grid.isSolid(tx, ty)`, draw scaled fillRect at `(mmX + tx * tileSize * scaleX, mmY + ty * tileSize * scaleY, Math.ceil(tileSize * scaleX), Math.ceil(tileSize * scaleY))` with fillStyle `0x444444, 0.8`.
  4. Powerup dots: iterate `this.room.state.powerups` (if it exists), for each powerup draw a small filled circle. Colors: PowerupType.SPEED=0x50C8C8 (cyan), PowerupType.INVINCIBILITY=0xFFCC00 (gold), PowerupType.PROJECTILE=0xCC44CC (purple). Dot radius: 2px.
  5. Player dots: iterate `this.room.state.players`, for each alive player (health > 0) draw fillCircle with `charColorNum(player.role)` color, radius 3px, at scaled position `(mmX + player.x * scaleX, mmY + player.y * scaleY)`.
  6. Death markers: iterate `this.minimapDeathMarkers`, draw red circles (0xff0000) with alpha based on age (2000ms lifetime, fade from 1.0 to 0.0). Remove markers older than 2000ms.

  **Stage transition / overview visibility:**
  In the consolidated matchState listener (already in setupMatchCountdown), add minimap hide/show logic:
  - When `value === 'playing'`: `this.minimapVisible = this.minimapUserToggled;` (restore user preference)
  - When `value === 'stage_end'` or `value === 'stage_transition'`: `this.minimapVisible = false;`

  Also listen for overview camera state. Add a cross-scene event listener in setupCrossSceneEvents():
  ```typescript
  this.gameScene.events.on('overviewStart', () => { this.minimapVisible = false; }, this);
  this.gameScene.events.on('overviewEnd', () => { this.minimapVisible = this.minimapUserToggled; }, this);
  ```

  In GameScene, emit these events: `this.events.emit('overviewStart')` when overview begins, `this.events.emit('overviewEnd')` when overview completes. Add these at the appropriate points in the overview animation code (where `this.overviewActive = true/false`).

  **Death markers:**
  Listen for the existing 'kill' message (already handled in setupKillFeed). When a kill occurs, find the victim's last known position from room state and add to `minimapDeathMarkers`:
  ```typescript
  // In the existing kill message handler, add:
  this.room.state.players.forEach((player: any, sid: string) => {
    if (player.name === data.victim || player.role === data.victimRole) {
      this.minimapDeathMarkers.push({
        x: player.x, y: player.y,
        color: 0xff0000,
        time: Date.now()
      });
    }
  });
  ```

  **HUD layout conflict resolution (from research pitfall 3):**
  Move ping display below minimap. Change ping Y position from `this.H * 0.03` to `mmY + mmH + 8` (approximately y=133). Update the kill feed base Y to account for new ping position: change from `this.H * 0.08` to `mmY + mmH + 30` (approximately y=155).

  **Cleanup in onShutdown():**
  ```typescript
  if (this.minimapGfx) { this.minimapGfx.destroy(); this.minimapGfx = null; }
  this.minimapDeathMarkers = [];
  ```

  Also clean up overviewStart/overviewEnd event listeners in onShutdown.
  </action>
  <verify>
  - Verify HUDScene compiles: `cd client && npx tsc --noEmit`
  - Grep for `redrawMinimap` in HUDScene.ts
  - Grep for `minimapGfx` in HUDScene.ts
  - Grep for `registry.set('collisionGrid'` in GameScene.ts
  - Verify no file changes outside HUDScene.ts and GameScene.ts
  </verify>
  <done>
  Minimap overlay renders in top-right corner of HUDScene with semi-transparent background, dark gray wall blocks, role-colored player dots, powerup colored dots, and fade-out death markers. Toggle with M key. Hidden during stage transitions and overview camera. Ping and kill feed repositioned below minimap. Collision grid and map metadata shared from GameScene via registry.
  </done>
</task>

</tasks>

<verification>
1. Minimap appears in top-right corner during gameplay (150x115px, 40% opacity background)
2. Wall blocks appear as dark gray rectangles matching arena layout
3. Player dots move in real-time with correct role colors
4. Powerup dots appear and disappear matching server state
5. Pressing M toggles minimap on/off with select SFX
6. Minimap hidden during overview camera and stage transitions
7. Minimap reappears after overview completes (if user had it enabled)
8. Destroyed obstacles disappear from minimap
9. Death markers appear briefly and fade out
10. Ping display and kill feed repositioned below minimap (no overlap)
</verification>

<success_criteria>
Semi-transparent minimap overlay visible during gameplay showing simplified arena layout with wall blocks, player dots, powerup dots, and death markers. Toggleable with M key. Hidden during stage transitions. No HUD element overlap.
</success_criteria>

<output>
After completion, create `.planning/phases/11-minimap-music/11-02-SUMMARY.md`
</output>
