---
phase: 09.1-tilemap-collision-masks
plan: 03
type: execute
wave: 2
depends_on: ["09.1-01", "09.1-02"]
files_modified:
  - server/src/rooms/GameRoom.ts
  - client/src/scenes/GameScene.ts
  - client/src/systems/Prediction.ts
autonomous: true
requirements:
  - COLL-MASK-03
  - COLL-MASK-04
  - COLL-MASK-05

must_haves:
  truths:
    - "Server loads collision shapes from map JSON and passes them to CollisionGrid"
    - "Client loads collision shapes from cached map data and passes them to CollisionGrid"
    - "Projectile collision on server uses isPointInSolidRect instead of isSolid"
    - "Server and client pass identical collision data to CollisionGrid (deterministic prediction)"
    - "F3 key toggles debug overlay showing collision rectangles on all solid tiles"
  artifacts:
    - path: "server/src/rooms/GameRoom.ts"
      provides: "Server collision grid with sub-rect data + projectile sub-rect check"
      contains: "collisionShapes"
    - path: "client/src/scenes/GameScene.ts"
      provides: "Client collision grid with sub-rect data + F3 debug overlay"
      contains: "collisionShapes"
    - path: "client/src/systems/Prediction.ts"
      provides: "Prediction collision grid receives same shapes as GameScene"
  key_links:
    - from: "server/src/rooms/GameRoom.ts"
      to: "shared/collisionGrid.ts"
      via: "CollisionGrid constructor with collisionShapes parameter"
      pattern: "new CollisionGrid.*collisionShapes"
    - from: "client/src/scenes/GameScene.ts"
      to: "shared/collisionGrid.ts"
      via: "CollisionGrid constructor with collisionShapes parameter"
      pattern: "new CollisionGrid.*collisionShapes"
    - from: "server/src/rooms/GameRoom.ts"
      to: "shared/collisionGrid.ts"
      via: "isPointInSolidRect for projectile collision"
      pattern: "isPointInSolidRect"
---

<objective>
Wire the collision shape data from map JSONs into the CollisionGrid on both server and client, update projectile collision to use isPointInSolidRect, and add F3 debug visualization overlay.

Purpose: This is the integration plan that connects the data pipeline (Plan 01) with the algorithm (Plan 02) to produce the actual gameplay change. Without this, the collision shapes exist in the map JSON and the algorithm supports them, but nothing passes the data through.

Output: Modified GameRoom.ts, GameScene.ts, and Prediction.ts with collision shape integration + debug overlay.
</objective>

<execution_context>
@/Users/jonasbrandvik/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jonasbrandvik/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09.1-tilemap-collision-masks-for-precise-wall-obstacle-collisions/09.1-RESEARCH.md
@.planning/phases/09.1-tilemap-collision-masks-for-precise-wall-obstacle-collisions/09.1-01-SUMMARY.md
@.planning/phases/09.1-tilemap-collision-masks-for-precise-wall-obstacle-collisions/09.1-02-SUMMARY.md
@server/src/rooms/GameRoom.ts
@client/src/scenes/GameScene.ts
@client/src/systems/Prediction.ts
@shared/collisionGrid.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Server integration -- loadMap collision shapes + projectile isPointInSolidRect</name>
  <files>server/src/rooms/GameRoom.ts</files>
  <action>
Two changes in GameRoom.ts:

**1. Pass collision shapes to CollisionGrid in loadMap() (around line 90):**

After loading `mapJson` and finding `wallLayer`, extract collision shapes:
```typescript
const collisionShapes = mapJson.tilesets?.[0]?.properties?.collisionShapes || {};
```

Then pass it as the 7th argument to the CollisionGrid constructor:
```typescript
this.collisionGrid = new CollisionGrid(
  wallLayer.data,
  mapJson.width,
  mapJson.height,
  mapJson.tilewidth,
  OBSTACLE_TILE_IDS.destructible,
  OBSTACLE_TILE_IDS.indestructible,
  collisionShapes,
);
```

**2. Update projectile collision to use isPointInSolidRect (around line 627-628):**

Replace:
```typescript
const projTile = this.collisionGrid.worldToTile(proj.x, proj.y);
if (this.collisionGrid.isSolid(projTile.tileX, projTile.tileY)) {
```

With:
```typescript
if (this.collisionGrid.isPointInSolidRect(proj.x, proj.y)) {
```

**BUT PRESERVE the obstacle damage logic below.** The code after the isSolid check uses `projTile.tileX` and `projTile.tileY` to look up obstacle keys. We still need the tile coordinates for obstacle damage. So the change becomes:
```typescript
const projTile = this.collisionGrid.worldToTile(proj.x, proj.y);
if (this.collisionGrid.isPointInSolidRect(proj.x, proj.y)) {
  // Check if destructible obstacle -- damage it
  const obsKey = `${projTile.tileX},${projTile.tileY}`;
  // ... rest of obstacle damage code unchanged ...
```

Keep the `worldToTile` call (needed for obstacle key lookup), but replace the `isSolid` check with `isPointInSolidRect`.

**Import check:** CollisionGrid is already imported from shared/collisionGrid.ts. The `isPointInSolidRect` method is on the class instance, no new imports needed.
  </action>
  <verify>
1. `cd /Users/jonasbrandvik/Projects/banger-game/server && npx tsc --noEmit` -- compiles clean
2. `grep "collisionShapes" server/src/rooms/GameRoom.ts` -- shows extraction + constructor arg
3. `grep "isPointInSolidRect" server/src/rooms/GameRoom.ts` -- shows projectile check
4. `grep "worldToTile" server/src/rooms/GameRoom.ts` -- still present for obstacle key lookup
  </verify>
  <done>
Server loads collision shapes from map JSON and passes to CollisionGrid. Projectile collision uses isPointInSolidRect for sub-rect precision while preserving obstacle damage via worldToTile key lookup.
  </done>
</task>

<task type="auto">
  <name>Task 2: Client integration -- GameScene collision shapes + Prediction pass-through + F3 debug overlay</name>
  <files>client/src/scenes/GameScene.ts, client/src/systems/Prediction.ts</files>
  <action>
**1. GameScene.ts -- Pass collision shapes to CollisionGrid in createTilemap() (around line 1848):**

After getting `mapData` and finding `wallLayerData`, extract collision shapes:
```typescript
const collisionShapes = mapData.data.tilesets?.[0]?.properties?.collisionShapes || {};
```

Pass as 7th argument:
```typescript
this.collisionGrid = new CollisionGrid(
  wallLayerData.data,
  mapData.data.width,
  mapData.data.height,
  mapData.data.tilewidth,
  OBSTACLE_TILE_IDS.destructible,
  OBSTACLE_TILE_IDS.indestructible,
  collisionShapes,
);
```

**2. GameScene.ts -- F3 debug collision overlay:**

Add a member variable:
```typescript
private debugCollisionOverlay: Phaser.GameObjects.Graphics | null = null;
private f3Key: Phaser.Input.Keyboard.Key | null = null;
```

In `create()` (scene initialization), register the F3 key:
```typescript
this.f3Key = this.input.keyboard?.addKey(Phaser.Input.Keyboard.KeyCodes.F3) || null;
```

Also in `create()`, reset the overlay on scene reuse:
```typescript
this.debugCollisionOverlay = null;
```

In `update()`, check for F3 toggle:
```typescript
if (this.f3Key && Phaser.Input.Keyboard.JustDown(this.f3Key)) {
  this.toggleDebugCollisionOverlay();
}
```

Add the toggle method:
```typescript
private toggleDebugCollisionOverlay(): void {
  if (this.debugCollisionOverlay) {
    this.debugCollisionOverlay.destroy();
    this.debugCollisionOverlay = null;
    return;
  }

  if (!this.collisionGrid) return;

  this.debugCollisionOverlay = this.add.graphics();
  this.debugCollisionOverlay.setDepth(999);

  const grid = this.collisionGrid;
  const ts = grid.tileSize;

  for (let ty = 0; ty < grid.height; ty++) {
    for (let tx = 0; tx < grid.width; tx++) {
      const info = grid.getTileInfo(tx, ty);
      if (!info || !info.solid) continue;

      const rect = info.collisionRect;
      const worldX = tx * ts + rect.x;
      const worldY = ty * ts + rect.y;

      // Color by type: red for walls, orange/yellow/green for obstacle tiers
      let color = 0xff0000;  // indestructible walls
      if (info.destructible) {
        if (info.tileId === 101) color = 0xff8800;  // heavy
        else if (info.tileId === 102) color = 0xffff00;  // medium
        else color = 0x00ff00;  // light
      }

      this.debugCollisionOverlay.lineStyle(1, color, 0.6);
      this.debugCollisionOverlay.fillStyle(color, 0.15);
      this.debugCollisionOverlay.fillRect(worldX, worldY, rect.w, rect.h);
      this.debugCollisionOverlay.strokeRect(worldX, worldY, rect.w, rect.h);
    }
  }
}
```

**Important:** When stage transitions destroy the tilemap (between stages), also destroy the debug overlay. Find where `this.currentTilemap` is destroyed (in createTilemap, there should be cleanup of old tilemap) and add:
```typescript
if (this.debugCollisionOverlay) {
  this.debugCollisionOverlay.destroy();
  this.debugCollisionOverlay = null;
}
```

**3. Prediction.ts -- No changes needed.**

The PredictionSystem receives its CollisionGrid via `setCollisionGrid(grid)` which is called in GameScene.createTilemap AFTER the grid is constructed with collision shapes. The Prediction system calls `resolveCollisions()` from shared code which already uses the sub-rect data stored in the grid. No code changes needed in Prediction.ts.

However, verify this is true by checking that:
- `setCollisionGrid` passes the grid object reference (not a copy)
- `resolveCollisions` in shared/collisionGrid.ts accesses `grid.getTileInfo()` which returns TileInfo with collisionRect
- The PredictionSystem doesn't construct its own CollisionGrid (it shouldn't)

If Prediction.ts doesn't need changes, update the `files_modified` note in the summary but the plan stays correct since the verification is valuable.

**Import check:** GameScene already imports CollisionGrid and OBSTACLE_TILE_IDS. The `collisionRect` property is on TileInfo which is used via `getTileInfo()`. No new imports needed for the debug overlay since `Phaser.GameObjects.Graphics` and `Phaser.Input.Keyboard` are already available in a Phaser scene.
  </action>
  <verify>
1. `cd /Users/jonasbrandvik/Projects/banger-game/client && npx tsc --noEmit` -- compiles clean
2. `grep "collisionShapes" client/src/scenes/GameScene.ts` -- shows extraction + constructor arg
3. `grep "debugCollisionOverlay" client/src/scenes/GameScene.ts` -- shows F3 overlay member + toggle
4. `grep "F3" client/src/scenes/GameScene.ts` -- shows key registration
5. `grep "toggleDebugCollisionOverlay" client/src/scenes/GameScene.ts` -- shows method exists
6. Start both server and client (`cd server && npm run dev` / `cd client && npm run dev`), open browser, verify game loads normally (collision behavior unchanged if no collision shapes in map JSON -- but with Plan 01 complete, shapes are present)
7. Press F3 in-game to verify debug overlay appears with colored rectangles on solid tiles
  </verify>
  <done>
Client passes collision shapes to CollisionGrid during tilemap creation. F3 key toggles a debug overlay showing all collision sub-rectangles color-coded by tile type. PredictionSystem inherits sub-rect collision through the shared CollisionGrid passed via setCollisionGrid. Server and client use identical collision data from the same map JSON source.
  </done>
</task>

</tasks>

<verification>
1. Server compiles and loads collision shapes from map JSON into CollisionGrid
2. Server projectile collision uses isPointInSolidRect for precise hit detection
3. Client compiles and loads collision shapes from cached map data into CollisionGrid
4. Client prediction uses same CollisionGrid with sub-rect data (via setCollisionGrid)
5. F3 debug overlay renders colored rectangles matching tile collision bounds
6. Both server and client start successfully and the game plays normally
7. Player collision with walls is visually tighter (matches art edges, not full tile)
8. Projectiles can pass through visual gaps between tiles
</verification>

<success_criteria>
- Server and client both pass collisionShapes to CollisionGrid constructor
- Projectile collision uses isPointInSolidRect (not isSolid)
- F3 debug overlay toggles on/off showing per-tile collision rectangles
- Game plays correctly with tighter collision boundaries
- No prediction desync (server and client use identical collision data)
</success_criteria>

<output>
After completion, create `.planning/phases/09.1-tilemap-collision-masks-for-precise-wall-obstacle-collisions/09.1-03-SUMMARY.md`
</output>
